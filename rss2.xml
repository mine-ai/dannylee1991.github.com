<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>studyAI</title>
    <link>http://studyai.site/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 04 May 2018 03:12:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Docker入门Part6-发布你的app</title>
      <link>http://studyai.site/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/</link>
      <guid>http://studyai.site/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/</guid>
      <pubDate>Thu, 03 May 2018 06:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compos</a>。</li><li>按照Part4部分，获取<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">Docker Machine</a>。</li><li>阅读Part1。</li><li>学习Part2中的如何创建容器。</li><li>确保您的镜像作为一个发布容器在运行。运行这条插入了<code>username</code>、<code>repo</code>和<code>tag</code>信息的命令:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li><li>获取到Part5中的最终版本的<code>compose.yml</code>文件。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>您一直在为整个教程编辑相同的Compose文件。那么，我们有一个好消息，这个Compose文件在生产环境中的效果与你的计算机上的效果是相同的。在这里，我们通过一些选项来运行Docker化的程序。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="Docker社区版（云服务提供者）"><a href="#Docker社区版（云服务提供者）" class="headerlink" title="Docker社区版（云服务提供者）"></a>Docker社区版（云服务提供者）</h3><p>如果您可以在生产环境中使用Docker社区版，那么你可以使用Docker Cloud来帮助您管理应用程序，例如Amazon Web Services，DigitalOcean，和Microsoft Azure等常用的服务提供商。</p><p>设置和部署：</p><ul><li>将Docker Cloud与您的首选提供商连接，授予Docker Cloud权限，以便为您自动配置以及为您”Docker化”VM。</li><li>使用Docker Cloud创建您的计算资源并创建您的swarm。</li><li>部署您的应用。</li></ul><blockquote><p>注意：我们没有链接到Docker Cloud文档。请务必在完成每个步骤后回到此页面。</p></blockquote><h4 id="连接Docker-Cloud"><a href="#连接Docker-Cloud" class="headerlink" title="连接Docker Cloud"></a>连接Docker Cloud</h4><p>你可以在<a href="https://docs.docker.com/docker-cloud/infrastructure/" target="_blank" rel="external">标准模式</a>或<a href="https://docs.docker.com/docker-cloud/cloud-swarm/" target="_blank" rel="external">swarm模式</a>下运行Docker Cloud。</p><p>如果你正在标准模式下运行Docker Cloud，请按照以下说明将您的服务提供商链接到Docker Cloud。</p><ul><li><a href="https://docs.docker.com/docker-cloud/cloud-swarm/link-aws-swarm/" target="_blank" rel="external">Amazon Web Services 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-do/" target="_blank" rel="external">DigitalOcean 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-azure/" target="_blank" rel="external">Microsoft Azure 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-packet/" target="_blank" rel="external">Packet 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-softlayer/" target="_blank" rel="external">SoftLayer 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/" target="_blank" rel="external">使用Docker Cloud 代理来访问自己的主机</a>。</li></ul><p>如果您在Swarm模式下运行（推荐用于Amazon Web Services或Microsoft Azure），那么请跳至下一节关于如何<a href="#创建你的swarm">创建swarm</a>的部分。</p><h3 id="创建你的swarm"><a href="#创建你的swarm" class="headerlink" title="创建你的swarm"></a>创建你的swarm</h3><p>准备好创建一个swarm了吗？</p><ul><li>如果你在使用Amazon Web Services(AWS)，那么你可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-aws/" target="_blank" rel="external">在AWS上自动地创建一个swarm</a>。</li><li>如果你在使用Microsoft Azure，那么你可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-azure/" target="_blank" rel="external">在Azure上自动地创建一个swarm</a>。</li><li>否则，在Docker Cloud UI界面<a href="https://docs.docker.com/docker-cloud/getting-started/your_first_node/" target="_blank" rel="external">创建你的节点</a>，然后运行<code>docker swarm init</code>并执行在Part4部分所学的<code>docker swarm join</code>命令。最后，通过点击屏幕顶部的开关<a href="https://docs.docker.com/docker-cloud/cloud-swarm/using-swarm-mode/" target="_blank" rel="external">启用swarm模式</a>，并<a href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/" target="_blank" rel="external">注册你刚刚创建的swarm</a>。</li></ul><blockquote><p>注意：如果您<a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/" target="_blank" rel="external">使用Docker云代理来自带主机</a>，则此提供程序不支持swarm模式。您可以使用Docker Cloud<a href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/" target="_blank" rel="external">注册您自己的现有的swarm</a>。</p></blockquote><h3 id="在云服务平台上部署你的应用程序"><a href="#在云服务平台上部署你的应用程序" class="headerlink" title="在云服务平台上部署你的应用程序"></a>在云服务平台上部署你的应用程序</h3><ul><li><p>1.<a href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/" target="_blank" rel="external">通过Docker Cloud连接到你自己的swarm</a>。有几种不同的连接方式：</p><ul><li><p>从Swarm模式的Docker Cloud Web界面中，选择页面顶部的Swarms，单击要连接的swarm，然后将给定的命令复制粘贴到命令行终端中。</p><p><img src="/img/18_05_02/004.png" alt=""></p><p>或者。。。</p></li><li><p>在Docker for Mac或Docker for Windows上，您可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/#use-docker-for-mac-or-windows-edge-to-connect-to-swarms" target="_blank" rel="external">通过桌面应用菜单直接连接到swarm</a>。</p><p><img src="/img/18_05_02/005.png" alt=""></p><p>无论哪种方式，都将打开一个终端，其上下文是本地计算机，但其Docker命令会路由到云服务提供商上运行的swarm。您可以直接访问本地文件系统和远程swarm，从而启用纯粹的<code>docker</code>命令。</p></li></ul></li><li><p>2.运行<code>docker stack deploy -c docker-compose.yml getstartedlab</code>在云托管swarm上部署应用程序。</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div><div class="line"></div><div class="line">Creating network getstartedlab_webnet</div><div class="line">Creating service getstartedlab_web</div><div class="line">Creating service getstartedlab_visualizer</div><div class="line">Creating service getstartedlab_redis</div></pre></td></tr></table></figure><p>  您的应用现在运行在了云服务平台上了。</p></li></ul><p><strong>运行一些swarm命令来验证部署：</strong></p><p>你可以使用swarm命令行，就像你之前做的那样，浏览并管理你的swarm。这里有一些你比较熟悉的例子：</p><ul><li>使用<code>docker node ls</code>列出节点。</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[getstartedlab] ~ $ docker node ls</div><div class="line">ID                            HOSTNAME                                      STATUS              AVAILABILITY        MANAGER STATUS</div><div class="line"><span class="number">9442</span>yi1zie2l34lj01frj3lsn     ip<span class="number">-172</span><span class="number">-31</span><span class="number">-5</span><span class="number">-208.</span>us-west<span class="number">-1.</span>compute.internal    Ready               Active              </div><div class="line">jr02vg153pfx6jr0j66624e8a     ip<span class="number">-172</span><span class="number">-31</span><span class="number">-6</span><span class="number">-237.</span>us-west<span class="number">-1.</span>compute.internal    Ready               Active              </div><div class="line">thpgwmoz3qefdvfzp7d9wzfvi     ip<span class="number">-172</span><span class="number">-31</span><span class="number">-18</span><span class="number">-121.</span>us-west<span class="number">-1.</span>compute.internal   Ready               Active              </div><div class="line">n2bsny0r2b8fey6013kwnom3m *   ip<span class="number">-172</span><span class="number">-31</span><span class="number">-20</span><span class="number">-217.</span>us-west<span class="number">-1.</span>compute.internal   Ready               Active              Leader</div></pre></td></tr></table></figure><ul><li>使用<code>docker service ls</code>列出服务。</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[getstartedlab] ~/sandbox/getstart $ docker service ls</div><div class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</div><div class="line"><span class="function"><span class="title">x3jyx6uukog9</span>        dockercloud-server-proxy   global              1/1                 dockercloud/server-proxy          *:2376-&gt;</span><span class="number">2376</span>/tcp</div><div class="line"><span class="function"><span class="title">ioipby1vcxzm</span>        getstartedlab_redis        replicated          0/1                 redis:latest                      *:6379-&gt;</span><span class="number">6379</span>/tcp</div><div class="line"><span class="function"><span class="title">u5cxv7ppv5o0</span>        getstartedlab_visualizer   replicated          0/1                 dockersamples/visualizer:stable   *:8080-&gt;</span><span class="number">8080</span>/tcp</div><div class="line"><span class="function"><span class="title">vy7n2piyqrtr</span>        getstartedlab_web          replicated          5/5                 sam/getstarted:part6    *:80-&gt;</span><span class="number">80</span>/tcp</div></pre></td></tr></table></figure><ul><li>使用<code>docker service ps &lt;service&gt;</code>查看service的任务列表。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[getstartedlab] ~/sandbox/getstart $ docker service ps vy7n2piyqrtr</div><div class="line">ID                  NAME                  IMAGE                            NODE                                          DESIRED STATE       CURRENT STATE            ERROR               PORTS</div><div class="line">qrcd4a9lvjel        getstartedlab_web.<span class="number">1</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">5</span>-<span class="number">208</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>    Running             Running <span class="number">20</span> seconds ago                       </div><div class="line">sknya8t4m51u        getstartedlab_web.<span class="number">2</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">6</span>-<span class="number">237</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>    Running             Running <span class="number">17</span> seconds ago                       </div><div class="line">ia730lfnrslg        getstartedlab_web.<span class="number">3</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">20</span>-<span class="number">217</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>   Running             Running <span class="number">21</span> seconds ago                       </div><div class="line"><span class="number">1</span>edaa97h9u4k        getstartedlab_web.<span class="number">4</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">18</span>-<span class="number">121</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>   Running             Running <span class="number">21</span> seconds ago                       </div><div class="line">uh64ez6ahuew        getstartedlab_web.<span class="number">5</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">18</span>-<span class="number">121</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>   Running             Running <span class="number">22</span> seconds ago</div></pre></td></tr></table></figure><p><strong>在云供应商机器上开放服务端口</strong></p><p>此时，您的应用作为一个swarm部署在您的云提供商服务器上，正如刚刚运行的<code>docker</code>命令所证明的那样。但是，您仍然需要在云服务器上打开端口，以便：</p><ul><li>允许在工作节点上的<code>redis</code>服务和<code>web</code>服务之间进行通信</li><li>允许入站流量通过worker节点上的<code>web</code>服务，以便可以在浏览器访问Hello World和Visualizer。</li><li>允许运行<code>manager</code>的服务器上的入站SSH流量（这可能已在您的云提供商上设置）</li></ul><p>这些是您需要为每项服务公开的端口：</p><table><thead><tr><th style="text-align:left">Service</th><th style="text-align:left">类型</th><th style="text-align:left">协议</th><th style="text-align:left">端口</th></tr></thead><tbody><tr><td style="text-align:left"><code>web</code></td><td style="text-align:left">HTTP</td><td style="text-align:left">TCP</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left"><code>visualizer</code></td><td style="text-align:left">HTTP</td><td style="text-align:left">TCP</td><td style="text-align:left">8080</td></tr><tr><td style="text-align:left"><code>redis</code></td><td style="text-align:left">TCP</td><td style="text-align:left">TCP</td><td style="text-align:left">6379</td></tr></tbody></table><p>具体的做法取决于云服务平台。</p><p>我们以Amazon Web Services（AWS）为例。</p><blockquote><p><strong>redis如何持久化数据？</strong></p><p>为了使<code>redis</code>服务正常工作，在运行<code>docker stack deploy</code>之前，需要<code>ssh</code>进入manager运行的云服务器，并在<code>/home/docker/</code>中创建<code>data/</code>目录。另一种选择是将<code>docker-stack.yml</code>中的数据路径更改为manager服务器上已存在的一个路径。此示例不包含此步骤，因此示例输出中的<code>redis</code>服务未启动。</p></blockquote><p><strong>示例：AWS</strong></p><ul><li>1.登录<a href="https://aws.amazon.com/" target="_blank" rel="external">AWS控制台</a>，转到EC2仪表板，然后单击进入<strong>Running Instances</strong>查看节点。</li><li><p>2.在左侧的按钮，进入Network &amp; Security &gt; <strong>Security Groups</strong>。</p><p>  请参阅<code>getstartedlab-Manager-&lt;xxx&gt;</code>, <code>getstartedlab-Nodes-&lt;xxx&gt;</code>, 和 <code>getstartedlab-SwarmWide-&lt;xxx&gt;</code>的与swarm相关的安全组。</p></li><li><p>3.为swarm选择“节点”安全组。组名是这样的：<code>getstartedlab-NodeVpcSG-9HV9SMHDZT8C</code>。</p></li><li>4.为<code>web</code>，<code>visualizer</code>和<code>redis</code>服务添加入站规则，为每个服务设置类型，协议和端口（如上表所示），然后单击保存以应用规则。</li></ul><p><img src="/img/18_05_02/006.png" alt=""></p><blockquote><p>提示：当你保存新的规则时，会为IPv4和IPv6地址自动创建HTTP和TCP端口。</p></blockquote><p><img src="/img/18_05_02/007.png" alt=""></p><ul><li>5.进入<strong>Running Instances</strong>列表，获取其中一个worker的公共DNS名称，并将其粘贴到浏览器地址栏中。</li></ul><p><img src="/img/18_05_02/008.png" alt=""></p><p>就像本教程的前几部分一样，Hello World应用程序显示在端口<code>80</code>上，而Visualizer显示在端口<code>8080</code>上。</p><p><img src="/img/18_05_02/009.png" alt=""></p><p><img src="/img/18_05_02/010.png" alt=""></p><h3 id="迭代和清理"><a href="#迭代和清理" class="headerlink" title="迭代和清理"></a>迭代和清理</h3><p>从这里你可以完成你在教程前面部分学到的所有知识。</p><ul><li>通过修改<code>docker-compose.yml</code>文件并使用命令<code>docker stack deploy</code>重新发布来扩展你的应用程序。</li><li>通过编辑代码更改应用程序行为，然后重新构建并推送新镜像。（要做到这一点，请按照之前用于<a href="https://docs.docker.com/get-started/part2/#build-the-app" target="_blank" rel="external">构建应用程序</a>和<a href="https://docs.docker.com/get-started/part2/#publish-the-image" target="_blank" rel="external">发布镜像</a>的相同步骤）。</li><li>您可以使用<code>docker stack rm</code>命令来拆卸堆栈。例如：</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> getstartedlab</div></pre></td></tr></table></figure><p>与在本地Docker机器虚拟机上运行swarm的场景不同，不管您是否关闭本地主机，您的swarm和部署在其上的任何应用程序都将继续在云服务器上运行。</p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part5-堆栈</title>
      <link>http://studyai.site/2018/05/02/Docker%E5%85%A5%E9%97%A8Part5-%E5%A0%86%E6%A0%88/</link>
      <guid>http://studyai.site/2018/05/02/Docker%E5%85%A5%E9%97%A8Part5-%E5%A0%86%E6%A0%88/</guid>
      <pubDate>Wed, 02 May 2018 09:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compos</a>。</li><li>按照Part4部分，获取<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">Docker Machine</a>。</li><li>阅读Part1。</li><li>学习Part2中的如何创建容器。</li><li>确保您已发布了那个<a href="https://docs.docker.com/get-started/part2/#share-your-image" target="_blank" rel="external">推送到仓库的</a><code>friendlyhello</code>镜像。我们在这里使用该共享镜像。</li><li>确保你在part4中设置的机器处于运行状态。运行<code>docker-machine ls</code>来验证这一点。如果机器处于停止状态，运行<code>docker-machine start myvm1</code>来启动manager，然后执行<code>docker-machine start myvm2</code>来启动worker。</li><li>让你在Part4创建的swarm处于运行状态并准备就绪。运行<code>docker-machine ssh myvm1 &quot;docker node ls&quot;</code>来验证这一点。如果swarm起来了，那么两个node的状态都是<code>ready</code>。如果不是这样，重新初始化swarm，并按照part4中的方式将worker加入到swarm中。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在part4中，你学到了如何设置一个swarm，这是一群运行Docker的机器，并为其部署了一个应用程序，其中容器在多台机器上运行。</p><p>在这里的Part5中，您将学习到分布式应用程序层次结构的顶部部分：<strong>堆栈(stack)</strong>。堆栈是一组相互关联的服务，它们可以共享依赖关系，并且可以进行协调和缩放。单个堆栈能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个堆栈）。</p><p>一些好消息是，从Part3部分开始，在创建Compose文件并使用<code>docker stack deploy</code>时，从技术上讲，您其实一直都在使用堆栈。但这是在单个主机上运行的单个服务堆栈，通常不会发生在生产环境中。在这里，你可以把你学到的东西，使多个服务相互关联，并在多台机器上运行它们。</p><p>你做得很好，这就是你的主场！</p><h2 id="添加一项新服务并重新部署"><a href="#添加一项新服务并重新部署" class="headerlink" title="添加一项新服务并重新部署"></a>添加一项新服务并重新部署</h2><p>将服务添加到我们的<code>docker-compose.yml</code>文件很容易。首先，我们添加一个免费的可视化工具，让我们看看我们的swarm是如何安排容器的。</p><ul><li>1.打开<code>docker-compose.yml</code>文件，并用以下内容替换它。确保你的<code>username/repo:tag</code>是正确的：</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">version:</span> <span class="string">"3"</span></div><div class="line"><span class="symbol">services:</span></div><div class="line"><span class="symbol">  web:</span></div><div class="line">    <span class="meta"># replace username/repo:tag with your name and image details</span></div><div class="line"><span class="symbol">    image:</span> username/repo:tag</div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      replicas:</span> <span class="number">5</span></div><div class="line"><span class="symbol">      restart_policy:</span></div><div class="line"><span class="symbol">        condition:</span> on-failure</div><div class="line"><span class="symbol">      resources:</span></div><div class="line"><span class="symbol">        limits:</span></div><div class="line"><span class="symbol">          cpus:</span> <span class="string">"0.1"</span></div><div class="line"><span class="symbol">          memory:</span> <span class="number">50</span>M</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"80:80"</span></div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">  visualizer:</span></div><div class="line"><span class="symbol">    image:</span> dockersamples/visualizer:stable</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"8080:8080"</span></div><div class="line"><span class="symbol">    volumes:</span></div><div class="line">      - <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      placement:</span></div><div class="line"><span class="symbol">        constraints:</span> [node.role == manager]</div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">networks:</span></div><div class="line"><span class="symbol">  webnet:</span></div></pre></td></tr></table></figure><p>这里唯一新增的东西就是<code>visualizer</code>。注意到这里有两个新的东西：一个<code>volumes</code>键，让visualizer可以访问Docker主机的socket文件，这项服务职能在swarm manager上运行。这是因为这个容器是由Docker创建的<a href="https://github.com/ManoMarks/docker-swarm-visualizer" target="_blank" rel="external">一个开源项目</a>构建的，它显示了一个图表中的swarm运行的Docker服务。</p><p>我们稍后会详细讨论放置约束和体积。</p><ul><li><p>2.确保你的shell被配置为与myvm1进行通信（完整的例子在<a href="https://docs.docker.com/get-started/part4/#configure-a-docker-machine-shell-to-the-swarm-manager" target="_blank" rel="external">这里</a>）。</p><ul><li>运行<code>docker-machine ls</code>来列出机器，并确保您已连接到<code>myvm1</code>，如旁边的星号所示。</li><li><p>如果需要，重新运行<code>docker-machine env myvm1</code>，然后运行给定的命令来配置shell。</p><p>在Mac或者Linux上，命令如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> myvm1)</div></pre></td></tr></table></figure></li></ul></li></ul><pre><code>在Windows命令如下：<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env myvm1 | Invoke-Expression</div></pre></td></tr></table></figure></code></pre><ul><li>3.在manager上重新运行<code>docker stack deploy</code>命令，并且需要更新的任何服务都会更新：</li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</div><div class="line">Updating service getstartedlab_web (<span class="attribute">id:</span><span class="string"> angi1bf5e4to03qu9f93trnxm</span>)</div><div class="line">Creating service getstartedlab_visualizer (<span class="attribute">id:</span><span class="string"> l9mnwkeq2jiononb5ihz9u7a4</span>)</div></pre></td></tr></table></figure><ul><li><p>4.看一下visualizer。</p><p>  你可以看到compose文件中的<code>visualizer</code>运行在了8080端口。通过运行<code>docker-machine ls</code>可以获取每个节点的IP地址信息。分别访问任意一个IP地址的8080端口，你可以看到visualizer的运行效果：</p><p>  <img src="/img/18_05_02/001.png" alt=""></p><p>  <code>visualizer</code>的单个副本按照您的预期在manager上运行，并且<code>web</code>的5个实例遍布整个swarm。你可以通过运行<code>docker stack ps &lt;stack&gt;</code>来确认可视化的结果：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">stack</span> ps getstartedlab</div></pre></td></tr></table></figure></li></ul><pre><code>可视化器是一个独立的服务，可以在包含它的任何应用程序中运行。它不依赖于其他任何东西。现在让我们创建一个具有依赖关系的服务：提供访问者计数器的Redis服务。</code></pre><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>让我们再次通过相同的工作流程来添加用于存储应用程序数据的Redis数据库。</p><ul><li>1.保存这个在最后位置添加Redis服务的新的<code>docker-compose.yml</code>文件。确保替换镜像详情部分的<code>username/repo:tag</code>。</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">version:</span> <span class="string">"3"</span></div><div class="line"><span class="symbol">services:</span></div><div class="line"><span class="symbol">  web:</span></div><div class="line">    <span class="meta"># replace username/repo:tag with your name and image details</span></div><div class="line"><span class="symbol">    image:</span> username/repo:tag</div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      replicas:</span> <span class="number">5</span></div><div class="line"><span class="symbol">      restart_policy:</span></div><div class="line"><span class="symbol">        condition:</span> on-failure</div><div class="line"><span class="symbol">      resources:</span></div><div class="line"><span class="symbol">        limits:</span></div><div class="line"><span class="symbol">          cpus:</span> <span class="string">"0.1"</span></div><div class="line"><span class="symbol">          memory:</span> <span class="number">50</span>M</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"80:80"</span></div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">  visualizer:</span></div><div class="line"><span class="symbol">    image:</span> dockersamples/visualizer:stable</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"8080:8080"</span></div><div class="line"><span class="symbol">    volumes:</span></div><div class="line">      - <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      placement:</span></div><div class="line"><span class="symbol">        constraints:</span> [node.role == manager]</div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">  redis:</span></div><div class="line"><span class="symbol">    image:</span> redis</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"6379:6379"</span></div><div class="line"><span class="symbol">    volumes:</span></div><div class="line">      - <span class="string">"/home/docker/data:/data"</span></div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      placement:</span></div><div class="line"><span class="symbol">        constraints:</span> [node.role == manager]</div><div class="line"><span class="symbol">    command:</span> redis-server --appendonly yes</div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">networks:</span></div><div class="line"><span class="symbol">  webnet:</span></div></pre></td></tr></table></figure><p>Redis在Docker库中有一个官方镜像，并已被授予<code>redis</code>作为镜像的简称，所以在这里没有<code>username/repo</code>符号。Redis端口6379已经由Redis预配置为从容器暴露给主机，在我们的Compose文件中，我们将它从主机展示给全世界，因此，如果您愿意，您可以将任何节点的IP输入到Redis桌面管理器中，并管理此Redis实例。</p><p>最重要的是，<code>redis</code>规范中有几件事情使数据在这个堆栈的部署之间持续存在：</p><ul><li><code>redis</code>总是在manager上运行，所以它总是使用相同的文件系统。</li><li><code>redis</code>在主机文件系统中访问任意目录作为容器内的<code>/data</code>，这是Redis存储数据的地方。</li></ul><p>这就是在您的主机物理文件系统中为Redis数据创建“真相源”。如果没有这个，Redis会将其数据存储在容器文件系统中的<code>/data</code>中，如果该容器曾经被重新部署，该数据将被清除。</p><p>这个真相的来源有两个组成部分：</p><ul><li>放置在Redis服务上的放置约束，确保它始终使用相同的主机。</li><li>您创建的容器，允许容器作为<code>./data</code>（位于Redis容器内）访问<code>./data</code>（在主机上）。在容器来来去去时，存储在指定主机上的<code>./data</code>文件仍然存在，从而保持连续性。</li></ul><p>您已准备好部署新的供Redis使用的堆栈了。</p><ul><li>2.在manager上创建一个<code>./data</code>目录。</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ssh myvm1 <span class="string">"mkdir ./data"</span></div></pre></td></tr></table></figure><ul><li><p>3.确保你的shell被配置为与<code>myvm1</code>进行通信(完整的例子在<a href="https://docs.docker.com/get-started/part4/#configure-a-docker-machine-shell-to-the-swarm-manager" target="_blank" rel="external">这里</a>)。</p><ul><li>运行<code>docker-machine ls</code>列出机器，并确保你已经连接到了<code>myvm1</code>，由旁边的星号所指示。</li><li><p>如果需要的话，重新运行<code>docker-machine env myvm1</code>，然后运行下面给出的命令来配置shell。</p><p>在Mac或Linux上，命令如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> myvm1)</div></pre></td></tr></table></figure></li></ul></li></ul><pre><code>在Windows上命令如下：<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env myvm1 | Invoke-Expression</div></pre></td></tr></table></figure></code></pre><ul><li>4.再次运行<code>docker stack deploy</code>。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div></pre></td></tr></table></figure><ul><li>5.运行<code>docker service ls</code>来验证三个服务处于运行状态：</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker service ls</div><div class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</div><div class="line"><span class="function"><span class="title">x7uij6xb4foj</span>        getstartedlab_redis        replicated          1/1                 redis:latest                      *:6379-&gt;</span><span class="number">6379</span>/tcp</div><div class="line"><span class="function"><span class="title">n5rvhm52ykq7</span>        getstartedlab_visualizer   replicated          1/1                 dockersamples/visualizer:stable   *:8080-&gt;</span><span class="number">8080</span>/tcp</div><div class="line"><span class="function"><span class="title">mifd433bti1d</span>        getstartedlab_web          replicated          5/5                 orangesnap/getstarted:latest    *:80-&gt;</span><span class="number">80</span>/tcp</div></pre></td></tr></table></figure><ul><li>6.检查位于你的某个节点的网页，例如<code>http://192.168.99.101</code>，然后看访问者计数器的结果，该计数器现在已经存在并将信息存储在Redis上。</li></ul><p><img src="/img/18_05_02/002.png" alt=""></p><p>另外，请检查任一节点IP地址的端口8080处的可视化工具，并注意查看随<code>web</code>和<code>visualizer</code>工具一起运行的<code>redis</code>服务。</p><p><img src="/img/18_05_02/003.png" alt=""></p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/05/02/Docker%E5%85%A5%E9%97%A8Part5-%E5%A0%86%E6%A0%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part4-Swarms</title>
      <link>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/</link>
      <guid>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/</guid>
      <pubDate>Thu, 26 Apr 2018 05:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compos</a>。</li><li>获取预装<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Docker for Mac</a>和<a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="external">Docker for Windows</a>的<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">Docker Machine</a>，但在Linux系统上需要<a href="https://docs.docker.com/machine/install-machine/#installing-machine-directly" target="_blank" rel="external">直接安装它</a>。在没有<em>Hyper-V</em>的Windows 10系统之前以及Windows 10 Home中，使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">Docker Toolbox</a>。</li><li>阅读Part1。</li><li>学习Part2中的如何创建容器。</li><li>确保您已发布了那个<a href="https://docs.docker.com/get-started/part2/#share-your-image" target="_blank" rel="external">推送到仓库的</a><code>friendlyhello</code>镜像。我们在这里使用该共享镜像。</li><li>确定你的镜像作为一个已部署的容器。运行下面这条命令，插入你的<code>username</code>、<code>repo</code>、和<code>tag</code>:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li><li>有一份Part3中的<code>docker-compose.yml</code>。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Part3中，你介绍了在Part2中编写的应用程序，并通过将其转化为service来定义应该如何在生产环境中运行，并在其进程内扩大5倍。</p><p>在Part4部分，您将此应用程序部署到集群上，并在多台机器上运行它。通过将多台机器连接到称为<strong>swarm</strong>的“Dockerized”群集，使多容器，多机器应用成为可能。</p><h2 id="了解Swarm集群"><a href="#了解Swarm集群" class="headerlink" title="了解Swarm集群"></a>了解Swarm集群</h2><p>Swarm是一组运行Docker并加入到集群中的机器。发生这种情况后，您将继续运行您习惯的Docker命令，但现在它们将由<strong>swarm manager</strong>在群集上执行。swarm中的机器可以是物理的或虚拟的。加入swarm后，他们被称为节点。</p><p>swarm管理器可以使用几种策略来运行容器，例如“emptiest node”–它用容器填充最少使用的机器。或者“global”，它可以确保每台机器只获取指定容器的一个实例。您指示swarm manager在Compose文件中使用这些策略，就像您已经使用的策略一样。</p><p>swarm manager是群体中唯一可以执行你的命令，或者授权其他机器作为<strong>worker</strong>加入群体的机器。worker只是提供能力，并没有权力告诉任何其他机器它能做什么和不能做什么。</p><p>到目前为止，您已经在本地机器上以单主机模式使用Docker。但是Docker也可以切换到<strong>swarm模式</strong>，这就是使用群集的原因。立即启用swarm模式使当前的机器成为swarm manager。从此，Docker将运行您在您管理的swarm上执行的命令，而不仅仅是在当前机器上执行。</p><h2 id="设置你的swarm"><a href="#设置你的swarm" class="headerlink" title="设置你的swarm"></a>设置你的swarm</h2><p>一个swarm是由多个节点组成，这些节点可以是物理机或虚拟机。基本概念很简单：运行<code>docker swarm init</code>来启用swarm模式，并使您当前的机器成为swarm管理器，然后在其他机器上运行<code>docker swarm join</code>，使其他机器以worker的身份加入到swarm中。我们将使用虚拟机快速创建一个双机群集，并将其变成swarm。</p><h3 id="创建一个集群"><a href="#创建一个集群" class="headerlink" title="创建一个集群"></a>创建一个集群</h3><h4 id="本地虚拟机（Mac，Linux，Windows-7和8）"><a href="#本地虚拟机（Mac，Linux，Windows-7和8）" class="headerlink" title="本地虚拟机（Mac，Linux，Windows 7和8）"></a>本地虚拟机（Mac，Linux，Windows 7和8）</h4><p>您需要一个可以创建虚拟机（VM）的虚拟机管理程序，因此请为您的计算机的操作系统<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">安装Oracle VirtualBox</a>。</p><blockquote><p>注意：如果你在Windows系统下，并且已经安装了Hyper-V，例如Windows 10，那就没必要安装VirtualBox了，你可以使用Hyper-V替代。如果你正在使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">Docker Toolbox</a>，你应该已经安装好了VirtualBox。</p></blockquote><p>现在，使用<code>docker-machine</code>创建两个虚拟机VM，使用VirtualBox驱动：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker-machine <span class="built_in">create</span> <span class="comment">--driver virtualbox myvm1</span></div><div class="line">docker-machine <span class="built_in">create</span> <span class="comment">--driver virtualbox myvm2</span></div></pre></td></tr></table></figure><h4 id="本地虚拟机（Windows-10-Hyper-V）"><a href="#本地虚拟机（Windows-10-Hyper-V）" class="headerlink" title="本地虚拟机（Windows 10/Hyper-V）"></a>本地虚拟机（Windows 10/Hyper-V）</h4><p>首先，快速为您的虚拟机（VM）创建一个虚拟交换机以便共享，以便它们可以相互连接。</p><ul><li>1.开启 Hyper-V Manager</li><li>2.点击右上角菜单中的<strong>Virtual Switch Manager</strong></li><li>3.单击创建类型为<strong>External</strong>的<strong>虚拟交换机</strong></li><li>4.将它命名为<code>myswitch</code>，然后选中复选框以共享主机的活动网络适配器</li></ul><p>现在，使用我们的节点管理工具<code>docker-machine</code>创建几个虚拟机：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker-machine create -d hyperv --hyperv-<span class="keyword">virtual</span>-<span class="keyword">switch</span> <span class="string">"myswitch"</span> myvm1</div><div class="line">docker-machine create -d hyperv --hyperv-<span class="keyword">virtual</span>-<span class="keyword">switch</span> <span class="string">"myswitch"</span> myvm2</div></pre></td></tr></table></figure><hr><h3 id="列出虚拟机，并显示其IP地址"><a href="#列出虚拟机，并显示其IP地址" class="headerlink" title="列出虚拟机，并显示其IP地址"></a>列出虚拟机，并显示其IP地址</h3><p>你现在创建了两个虚拟机，名叫<code>myvm1</code>和<code>myvm2</code>。</p><p>使用下面的命令来列出这些虚拟机以及他们的IP地址。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine <span class="keyword">ls</span></div></pre></td></tr></table></figure><p>这里是这个命令的输出示例。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</div><div class="line">myvm1   -        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.100</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce   </div><div class="line">myvm2   -        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.101</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div></pre></td></tr></table></figure><h3 id="初始化swarm和节点"><a href="#初始化swarm和节点" class="headerlink" title="初始化swarm和节点"></a>初始化swarm和节点</h3><p>第一台机器作为manager，它负责执行管理命令并认证worker机器加入集群，第二台机器是worker。</p><p>你可以对你的虚拟机通过<code>docker-machine ssh</code>来发送命令。通过执行<code>docker swarm init</code>来指导<code>myvm1</code>来成为swarm manager，然后你会看到像下面这样的输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh myvm1 <span class="string">"docker swarm init --advertise-addr &lt;myvm1 ip&gt;"</span></div><div class="line">Swarm initialized: current node &lt;node ID&gt; is now <span class="keyword">a</span> manager.</div><div class="line"></div><div class="line">To <span class="built_in">add</span> <span class="keyword">a</span> worker <span class="built_in">to</span> this swarm, run <span class="keyword">the</span> following <span class="keyword">command</span>:</div><div class="line"></div><div class="line">  docker swarm join \</div><div class="line">  <span class="comment">--token &lt;token&gt; \</span></div><div class="line">  &lt;myvm ip&gt;:&lt;port&gt;</div><div class="line"></div><div class="line">To <span class="built_in">add</span> <span class="keyword">a</span> manager <span class="built_in">to</span> this swarm, run <span class="string">'docker swarm join-token manager'</span> <span class="keyword">and</span> follow <span class="keyword">the</span> instructions.</div></pre></td></tr></table></figure><blockquote><p><strong>端口2377和2376</strong></p><p>始终使用端口2377（群管理端口）运行<code>docker swarm init</code>和<code>docker swarm join</code>，或根本不指定运行端口，并让其采用默认值。</p><p>由<code>docker-machine ls</code>返回的计算机IP地址包括端口2376，它是Docker守护进程端口。请勿使用此端口，否则<a href="https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2" target="_blank" rel="external">可能会遇到错误</a>。</p><p><strong>无法使用SSH？试试–native-ssh标志</strong></p><p>如果由于某些原因，您无法将命令发送给Swarm管理器，Docker Machine可以<a href="https://docs.docker.com/machine/reference/ssh/#different-types-of-ssh" target="_blank" rel="external">选择让您使用自己的系统的SSH</a>。只需在调用<code>ssh</code>命令时指定<code>--native-ssh</code>标志：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; docker-machine --<span class="keyword">native</span>-ssh ssh myvm1 ...</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>如您所见，对<code>docker swarm init</code>的响应包含一个预配置的<code>docker swarm join</code>命令，您可以在要添加的任何节点上运行该命令。复制这条命令，并通过<code>docker-machine ssh</code>发送到<code>myvm2</code>，使<code>myvm2</code>作为woker的角色来加入到你新创建的集群中。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh myvm2 <span class="string">"docker swarm join \</span></div><div class="line">--token &lt;token&gt; \</div><div class="line">&lt;ip&gt;:2377"</div><div class="line"></div><div class="line">This <span class="keyword">node</span> <span class="title">joined</span> a swarm as a worker.</div></pre></td></tr></table></figure><p>恭喜，您已经创建了您的第一个swarm集群！</p><p>在manager机器上运行<code>docker node ls</code>来查看swarm中的node：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh myvm1 <span class="string">"docker node ls"</span></div><div class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS</div><div class="line">brtu9urxwfd5j0zrmkubhpkbd     myvm2               Ready               <span class="keyword">Active</span></div><div class="line">rihwohkh3ph38fhillhhb84sk *   myvm1               Ready               <span class="keyword">Active</span>              Leader</div></pre></td></tr></table></figure><blockquote><p><strong>离开一个swarm</strong></p><p>如果你的某个节点想要退出集群，你可以在节点上运行<code>docker swarm leave</code>。</p></blockquote><h2 id="发布你的应用到swarm集群"><a href="#发布你的应用到swarm集群" class="headerlink" title="发布你的应用到swarm集群"></a>发布你的应用到swarm集群</h2><p>最困难的部分已经结束了。现在你只需重复第3部分用于部署新swarm的流程即可。请记住，只有像<code>myvm1</code>这样的群集管理器才能执行Docker命令；worker机器只是提供使用而已。</p><h3 id="为swarm-manager配置docker-machine-shell"><a href="#为swarm-manager配置docker-machine-shell" class="headerlink" title="为swarm manager配置docker-machine shell"></a>为swarm manager配置<code>docker-machine</code> shell</h3><p>到目前为止，你已经可以在<code>docker-machine ssh</code>中包裹Docker命令来在虚拟机上执行指令了。另一种选择是运行<code>docker-machine env &lt;machine&gt;</code>来获取并执行一个命令，该命令将当前shell配置为与虚拟机上的Docker守护进程进行通信。此方法对下一步更有利，因为它允许您使用本地<code>docker-compose.yml</code>文件“远程”部署应用程序，而无需将其复制到任何位置。</p><p>键入<code>docker-machine env myvm1</code>，然后复制粘贴并运行作为输出最后一行提供的命令，这样可以将shell配置为swarm manager可以与<code>myvm1</code>进行对话。</p><p>配置shell的命令根据你是Mac，Linux还是Windows而有所不同。</p><h4 id="Mac，Linux"><a href="#Mac，Linux" class="headerlink" title="Mac，Linux"></a>Mac，Linux</h4><p>Mac或Linux上的Docker Machine shell</p><p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker-machine env myvm1</div><div class="line"><span class="built_in">export</span> DOCKER_TLS_VERIFY=<span class="string">"1"</span></div><div class="line"><span class="built_in">export</span> DOCKER_HOST=<span class="string">"tcp://192.168.99.100:2376"</span></div><div class="line"><span class="built_in">export</span> DOCKER_CERT_PATH=<span class="string">"/Users/sam/.docker/machine/machines/myvm1"</span></div><div class="line"><span class="built_in">export</span> DOCKER_MACHINE_NAME=<span class="string">"myvm1"</span></div><div class="line"><span class="comment"># Run this command to configure your shell:</span></div><div class="line"><span class="comment"># eval $(docker-machine env myvm1)</span></div></pre></td></tr></table></figure><p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> myvm1)</div></pre></td></tr></table></figure><p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</div><div class="line">myvm1   *        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.100</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce   </div><div class="line">myvm2   -        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.101</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">PS </span>C:\<span class="string">Users\</span><span class="string">sam\</span><span class="string">sandbox\</span><span class="built_in">get-started&gt;</span> <span class="string">docker-machine </span><span class="string">env </span><span class="string">myvm1</span></div><div class="line">$<span class="string">Env:DOCKER_TLS_VERIFY </span>= <span class="string">"1"</span></div><div class="line">$<span class="string">Env:DOCKER_HOST </span>= <span class="string">"tcp://192.168.203.207:2376"</span></div><div class="line">$<span class="string">Env:DOCKER_CERT_PATH </span>= <span class="string">"C:\Users\sam\.docker\machine\machines\myvm1"</span></div><div class="line">$<span class="string">Env:DOCKER_MACHINE_NAME </span>= <span class="string">"myvm1"</span></div><div class="line">$<span class="string">Env:COMPOSE_CONVERT_WINDOWS_PATHS </span>= <span class="string">"true"</span></div><div class="line"><span class="comment"># Run this command to configure your shell:</span></div><div class="line"><span class="comment"># &amp; "C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe" env myvm1 | Invoke-Expression</span></div></pre></td></tr></table></figure><p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env myvm1 | Invoke-Expression</div></pre></td></tr></table></figure><p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PS C:PATH&gt; docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER   STATE     URL                          SWARM   DOCKER        ERRORS</div><div class="line">myvm1   *        hyperv   Running   tcp://<span class="number">192.168</span><span class="meta">.203</span><span class="meta">.207</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div><div class="line">myvm2   -        hyperv   Running   tcp://<span class="number">192.168</span><span class="meta">.200</span><span class="meta">.181</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div></pre></td></tr></table></figure><h3 id="在swarm-manager上发布应用"><a href="#在swarm-manager上发布应用" class="headerlink" title="在swarm manager上发布应用"></a>在swarm manager上发布应用</h3><p>现在你已经拥有了<code>myvm1</code>，你可以使用它的权力作为swarm manager来部署你的应用，方法是使用第三部分中的<code>docker stack deploy</code>命令将你的本地副本<code>docker-compose.yml</code>发布到<code>myvm1</code>。这个命令也许会花费几秒钟时间来完成这一操作，部署需要花一段时间才能完成。在swarm manager上使用<code>docker service ps &lt;service_name&gt;</code>命令验证所有服务是否已被重新部署。</p><p>您通过<code>docker-machine shell</code>配置链接到<code>myvm1</code>，并且您仍然可以访问本地主机上的文件。确保你和之前在同一个目录下，并且其中包括你在第3部分中创建的<code>docker-compose.yml</code>文件。</p><p>就像之前一样，运行以下命令在<code>myvm1</code>上部署应用程序。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div></pre></td></tr></table></figure><p>就是这样，该应用程序就成功部署在了swarm集群上了！</p><blockquote><p>注意：如果你的镜像保存在了一个私有仓库而不是Docker Hub上，你需要登录到通过命令<code>docker login &lt;your-registry&gt;</code>来登录到这个仓库，并且然后你需要在上面的命令添加<code>--with-registry-auth</code>指令。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker login registry<span class="selector-class">.example</span><span class="selector-class">.com</span></div><div class="line"></div><div class="line">docker stack deploy --with-registry-auth -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>这使用加密的WAL日志将登录令牌从本地客户端传递到部署服务的群集节点。有了这些信息，这些节点就能够登录到仓库并提取镜像。</p></blockquote><p>现在你可以使用Part3中的docker命令。只有这次注意到services（和相关容器）已经在<code>myvm1</code>和<code>myvm2</code>之间分配了。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ <span class="string">docker </span><span class="string">stack </span><span class="string">ps </span><span class="string">getstartedlab</span></div><div class="line"></div><div class="line"><span class="string">ID </span>           <span class="string">NAME </span>                 <span class="string">IMAGE </span>                  <span class="string">NODE </span>  <span class="string">DESIRED </span><span class="string">STATE</span></div><div class="line"><span class="string">jq2g3qp8nzwx </span> <span class="string">getstartedlab_web.</span>1   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm1 </span> <span class="string">Running</span></div><div class="line"><span class="string">88wgshobzoxl </span> <span class="string">getstartedlab_web.</span>2   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm2 </span> <span class="string">Running</span></div><div class="line"><span class="string">vbb1qbkb0o2z </span> <span class="string">getstartedlab_web.</span>3   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm2 </span> <span class="string">Running</span></div><div class="line"><span class="string">ghii74p9budx </span> <span class="string">getstartedlab_web.</span>4   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm1 </span> <span class="string">Running</span></div><div class="line"><span class="string">0prmarhavs87 </span> <span class="string">getstartedlab_web.</span>5   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm2 </span> <span class="string">Running</span></div></pre></td></tr></table></figure><blockquote><p><strong>使用<code>docker-machine env</code>和<code>docker-machine ssh</code>连接到VM</strong></p><ul><li><p>要将shell设置为与<code>myvm2</code>等其他机器通信，只需在相同或不同的shell中重新运行<code>docker-machine env</code>，然后运行给定的命令以指向<code>myvm2</code>。这里指的是当前的shell。如果你更改为未配置的shell或打开一个新的shell，则需要重新运行这些命令。使用<code>docker-machine ls</code>列出机器列表，查看它们所处的状态，获取IP地址，如果有的话，并找出具体连接到的是哪一个地址。更多请参阅<a href="https://docs.docker.com/machine/get-started/#create-a-machine" target="_blank" rel="external">Docker Machine getting started topics</a>。</p></li><li><p>或者，你可以以<code>docker-machine ssh &lt;machine&gt; &quot;&lt;command&gt;&quot;</code>的形式来打包Docker命令，该命令可以直接登陆到VM，但不会立即访问本地主机上的文件。</p></li><li><p>在Mac和Linux上，你可以使用<code>docker-machine scp &lt;file&gt; &lt;machine&gt;:~</code>来在机器间复制文件，但在Windows上，需要使用一个Linux类似<a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git Bash</a>的终端模拟器来完成这类工作。</p></li></ul><p>本教程演示了<code>docker-machine ssh</code>和<code>docker-machine env</code>因为这些都可以通过<code>docker-machine</code>CLI在平台上使用。</p></blockquote><h3 id="访问你的集群"><a href="#访问你的集群" class="headerlink" title="访问你的集群"></a>访问你的集群</h3><p>你可以从<code>myvm1</code>或<code>myvm2</code>的IP地址访问您的应用程序。</p><p>你创建的网络在它们之间共享负载均衡。运行<code>docker-machine ls</code>来获取你的VM的IP地址，并通过浏览器访问其中的任何一个，点击刷新（或者仅仅使用<code>curl</code>来访问）</p><p><img src="/img/18_04_26/002.png" alt=""></p><p>有五个可能的容器ID全部随机循环，体现了负载均衡。</p><p>两个IP地址工作的原因是群中的节点参与<strong>入口路由网格</strong>。这可以确保部署在集群中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。以下是三节点swarm的端口8080上发布的名为<code>my-web</code>的服务的路由网络示意图：</p><p><img src="/img/18_04_26/003.png" alt=""></p><blockquote><p><strong>连接有问题？</strong></p><p>请记住，要使用swarm中的入口网络，在启用swarm模式之前，需要在swarm节点之间打开以下端口：</p><ul><li>端口7946 TCP/UDP （用于容器网络发现）</li><li>端口4789 UDP （用于容器入口网络）</li></ul></blockquote><h2 id="迭代和缩放你的应用程序"><a href="#迭代和缩放你的应用程序" class="headerlink" title="迭代和缩放你的应用程序"></a>迭代和缩放你的应用程序</h2><p>在这里，你可以完成你在Part2和Part3中学到的一切。</p><p>通过修改<code>docker-compose.yml</code>文件，可以缩放应用程序。</p><p>通过编辑代码，来改变应用的行为，然后重新构建，并将新的镜像push上去。（要做到这一点，请按照之前用于构建应用程序和发布镜像的相同步骤）。</p><p>无论是哪种情况，只需要通过再次运行<code>docker stack deploy</code>就可以发布这些变更。</p><p>你可以加入任何虚拟的或物理的机器到这个swarm中，对<code>myvm2</code>使用相同的<code>docker swarm join</code>命令，然后集群的容量就被扩大了。在运行<code>docker stack deploy</code>之后，你的应用程序就可以利用到这些资源了。</p><h2 id="清空并重启"><a href="#清空并重启" class="headerlink" title="清空并重启"></a>清空并重启</h2><h3 id="堆栈和swarm"><a href="#堆栈和swarm" class="headerlink" title="堆栈和swarm"></a>堆栈和swarm</h3><p>你可以通过运行<code>docker stack rm</code>来卸下堆栈。例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> getstartedlab</div></pre></td></tr></table></figure><blockquote><p><strong>保留或删除swarm</strong>？</p><p>在稍后，如果您想要使某个worker离开swarm，可以在worker上使用<code>docker-machine ssh myvm2 &quot;docker swarm leave&quot;</code>来卸下woker，如果是manager的话，可以这样执行<code>docker-machine ssh myvm1 &quot;docker swarm leave --force&quot;</code>，但在后面的Part5的教学中，你还需要它，所以暂时保留。</p></blockquote><h3 id="重置docker-machine-shell变量设置"><a href="#重置docker-machine-shell变量设置" class="headerlink" title="重置docker-machine shell变量设置"></a>重置docker-machine shell变量设置</h3><p>你可以通过你当前的shell执行以下命令来重置<code>docker-machine</code>环境变量。</p><p>在Mac或Linux上，命令如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> -u)</div></pre></td></tr></table></figure><p>在Windows上，命令如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env -u | Invoke-Expression</div></pre></td></tr></table></figure><p>这将shell与<code>docker-machine</code>创建的虚拟机断开连接，并允许你继续在同一个shell中工作，现在使用本机docker命令。更多信息，请见<a href="https://docs.docker.com/machine/get-started/#unset-environment-variables-in-the-current-shell" target="_blank" rel="external">Machine topic on unsetting environment variables</a>。</p><p>重启Docker machines</p><p>如果你关闭本地主机，Docker machines将停止运行。你可以通过运行<code>docker-machine ls</code>来检查机器运行的状态。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls</div><div class="line"><span class="built_in">NAME</span>    ACTIVE   <span class="built_in">DRIVER</span>       STATE     URL   SWARM   DOCKER    ERRORS</div><div class="line">myvm1   -        virtualbox   <span class="built_in">Stopped</span>                 Unknown</div><div class="line">myvm2   -        virtualbox   <span class="built_in">Stopped</span>                 Unknown</div></pre></td></tr></table></figure><p>重启已经停止的机器，运行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine <span class="keyword">start</span> &lt;machine-<span class="keyword">name</span>&gt;</div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ docker-machine <span class="built_in">start</span> myvm1</div><div class="line">Starting <span class="string">"myvm1"</span>...</div><div class="line">(myvm1) Check network <span class="built_in">to</span> re-<span class="built_in">create</span> <span class="keyword">if</span> needed...</div><div class="line">(myvm1) Waiting <span class="keyword">for</span> <span class="keyword">an</span> IP...</div><div class="line">Machine <span class="string">"myvm1"</span> was started.</div><div class="line">Waiting <span class="keyword">for</span> SSH <span class="built_in">to</span> be available...</div><div class="line">Detecting <span class="keyword">the</span> provisioner...</div><div class="line">Started machines may have <span class="built_in">new</span> IP addresses. You may need <span class="built_in">to</span> re-run <span class="keyword">the</span> `docker-machine env` <span class="keyword">command</span>.</div><div class="line"></div><div class="line">$ docker-machine <span class="built_in">start</span> myvm2</div><div class="line">Starting <span class="string">"myvm2"</span>...</div><div class="line">(myvm2) Check network <span class="built_in">to</span> re-<span class="built_in">create</span> <span class="keyword">if</span> needed...</div><div class="line">(myvm2) Waiting <span class="keyword">for</span> <span class="keyword">an</span> IP...</div><div class="line">Machine <span class="string">"myvm2"</span> was started.</div><div class="line">Waiting <span class="keyword">for</span> SSH <span class="built_in">to</span> be available...</div><div class="line">Detecting <span class="keyword">the</span> provisioner...</div><div class="line">Started machines may have <span class="built_in">new</span> IP addresses. You may need <span class="built_in">to</span> re-run <span class="keyword">the</span> `docker-machine env` <span class="keyword">command</span>.</div></pre></td></tr></table></figure><h2 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h2><p>在part4部分，你学习到了什么是swarm，节点在swarm中可以作为worker，也可以作为manager，创建一个swarm，并在上面发布一个应用。你看到Docker的核心命令和part3中并没有什么不同，他们只需要将目标锁定在swarm主机上运行。你还看到了Docker网络的力量，即使它们运行在不同的机器上，也可以跨容器保持请求负载均衡。最后，你学习了如何在集群上迭代和缩放应用程序。以下是您可能想要运行的命令：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver virtualbox myvm1 # Create a VM (<span class="keyword">Mac</span>, Win7, Linux)</div><div class="line">docker-machine create -<span class="keyword">d</span> hyperv --hyperv-virtual-switch <span class="string">"myswitch"</span> myvm1 # Win10</div><div class="line">docker-machine env myvm1                # <span class="keyword">View</span> basic information <span class="keyword">about</span> your node</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker node ls"</span>         # <span class="keyword">List</span> the nodes <span class="keyword">in</span> your swarm</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker node inspect &lt;node ID&gt;"</span>        # <span class="keyword">Inspect</span> a node</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker swarm join-token -q worker"</span>   # <span class="keyword">View</span> join <span class="keyword">token</span></div><div class="line">docker-machine ssh myvm1   # <span class="keyword">Open</span> <span class="keyword">an</span> SSH session with the VM; <span class="keyword">type</span> <span class="string">"exit"</span> to end</div><div class="line">docker node <span class="keyword">ls</span>                # <span class="keyword">View</span> nodes <span class="keyword">in</span> swarm (<span class="keyword">while</span> logged <span class="keyword">on</span> to manager)</div><div class="line">docker-machine ssh myvm2 <span class="string">"docker swarm leave"</span>  # Make the worker leave the swarm</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker swarm leave -f"</span> # Make master leave, kill swarm</div><div class="line">docker-machine <span class="keyword">ls</span> # <span class="keyword">list</span> VMs, asterisk shows <span class="keyword">which</span> VM this <span class="keyword">shell</span> is talking to</div><div class="line">docker-machine start myvm1            # Start a VM that is currently not running</div><div class="line">docker-machine env myvm1      # show environment variables and command <span class="keyword">for</span> myvm1</div><div class="line">eval $(docker-machine env myvm1)         # <span class="keyword">Mac</span> command to connect <span class="keyword">shell</span> to myvm1</div><div class="line">&amp; <span class="string">"C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe"</span> env myvm1 | Invoke-Expression   # Windows command to connect <span class="keyword">shell</span> to myvm1</div><div class="line">docker <span class="keyword">stack</span> deploy -c &lt;<span class="keyword">file</span>&gt; &lt;<span class="keyword">app</span>&gt;  # Deploy <span class="keyword">an</span> <span class="keyword">app</span>; command <span class="keyword">shell</span> must be <span class="keyword">set</span> to talk to manager (myvm1), uses <span class="keyword">local</span> Compose <span class="keyword">file</span></div><div class="line">docker-machine scp docker-compose.yml myvm1:~ # <span class="keyword">Copy</span> <span class="keyword">file</span> to node's home <span class="keyword">dir</span> (only required <span class="keyword">if</span> you <span class="keyword">use</span> ssh to connect to manager and deploy the <span class="keyword">app</span>)</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker stack deploy -c &lt;file&gt; &lt;app&gt;"</span>   # Deploy <span class="keyword">an</span> <span class="keyword">app</span> using ssh (you must have first copied the Compose <span class="keyword">file</span> to myvm1)</div><div class="line">eval $(docker-machine env -<span class="keyword">u</span>)     # Disconnect <span class="keyword">shell</span> from VMs, <span class="keyword">use</span> native docker</div><div class="line">docker-machine stop $(docker-machine <span class="keyword">ls</span> -q)               # Stop all running VMs</div><div class="line">docker-machine <span class="keyword">rm</span> $(docker-machine <span class="keyword">ls</span> -q) # Delete all VMs and their disk images</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part3-服务</title>
      <link>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part3-%E6%9C%8D%E5%8A%A1/</link>
      <guid>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part3-%E6%9C%8D%E5%8A%A1/</guid>
      <pubDate>Thu, 26 Apr 2018 02:12:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compose</a>。在<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Docker for Mac</a>和<a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="external">Docker for Windows</a>中，它已预先安装，这一步很方便。在Linux系统上，您需要<a href="https://github.com/docker/compose/releases" target="_blank" rel="external">直接安装它</a>。在没有<em>Hyper-V</em>的Windows 10系统上，使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">Docker Toolbox</a>。</li><li>阅读Part1部分。</li><li>学习Part2中如何创建容器。</li><li>确定你已经通过<a href="https://docs.docker.com/get-started/part2/#share-your-image" target="_blank" rel="external">上传到仓库</a>的方式发布了<code>friendlyhello</code>镜像。我们在这里使用共享镜像。</li><li>确定你的镜像作为一个已部署的容器。运行下面这条命令，插入你的<code>username</code>、<code>repo</code>、和<code>tag</code>:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在第三部分，我们将扩展我们的应用并实现负载均衡。为了做到这一点，我们必须在分布式应用程序的层次结构中升一级：<strong>service(服务)</strong>。</p><ul><li>Stack</li><li><strong>Services(服务 你在这里)</strong></li><li>Container（参见 part2）</li></ul><h2 id="关于Services"><a href="#关于Services" class="headerlink" title="关于Services"></a>关于Services</h2><p>在一个分布式应用中，应用的不同部分被称为”services”。例如，想象你有一个影片分享站点，它也许包括一个关于将应用数据存储在数据库中的service，一个在用户上传一些东西之后在后台对其进行转码操作的service，一个前端的服务，等等。</p><p>Services实际上只是“生产中的容器”。service只运行一个镜像，但用于编纂镜像的运行方式–应该使用哪个端口，应该运行多少个容器副本以便服务具有所需的容量，等等。缩放service会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多计算资源。</p><p>幸运的是，使用Docker平台定义，运行和扩展services非常简单 – 仅仅写一个<code>docker-compose.yml</code>文件即可。</p><h2 id="你的第一个docker-compose-yml文件"><a href="#你的第一个docker-compose-yml文件" class="headerlink" title="你的第一个docker-compose.yml文件"></a>你的第一个<code>docker-compose.yml</code>文件</h2><p>一个<code>docker-compose.yml</code>文件是一个用于定义Docker容器在生产环境中的行为的YAML文件。</p><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a><code>docker-compose.yml</code></h3><p>将此文件另存为<code>docker-compose.yml</code>，无论你在哪里。确保您已将第2部分中创建的镜像推送到注册表中，并通根据你的镜像的具体的信息替换掉<code>username/repo:tag</code>部分来更新此<code>.yml</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">version</span>: <span class="string">"3"</span></div><div class="line"><span class="attribute">services</span>:</div><div class="line">  <span class="attribute">web</span>:</div><div class="line">    # replace username/<span class="attribute">repo</span>:tag with your name and image details</div><div class="line">    <span class="attribute">image</span>: username/<span class="attribute">repo</span>:tag</div><div class="line">    <span class="attribute">deploy</span>:</div><div class="line">      <span class="attribute">replicas</span>: <span class="number">5</span></div><div class="line">      <span class="attribute">resources</span>:</div><div class="line">        <span class="attribute">limits</span>:</div><div class="line">          <span class="attribute">cpus</span>: <span class="string">"0.1"</span></div><div class="line">          <span class="attribute">memory</span>: <span class="number">50</span>M</div><div class="line">      <span class="attribute">restart_policy</span>:</div><div class="line">        <span class="attribute">condition</span>: on-failure</div><div class="line">    <span class="attribute">ports</span>:</div><div class="line">      - <span class="string">"80:80"</span></div><div class="line">    <span class="attribute">networks</span>:</div><div class="line">      - webnet</div><div class="line"><span class="attribute">networks</span>:</div><div class="line">  <span class="attribute">webnet</span>:</div></pre></td></tr></table></figure><p>这个<code>docker-compose.yml</code>文件告诉Docker要做以下事情：</p><ul><li>按照Part2中的方式从仓库中下拉我们的镜像。</li><li>运行镜像的5个实例作为一个名为<code>web</code>的service，限制每个实例，最多占用10%CPU(所有的核)、50MB的RAM。</li><li>如果一个容器失败了立刻重启。</li><li>将主机上的端口80映射到<code>web</code>的端口80。</li><li>指示<code>web</code>容器通过名为<code>webnet</code>负载均衡网络共享80端口。（在内部，容器本身在临时端口上发布到<code>web</code>的80端口）。</li><li>使用默认设置（这是一个负载均衡覆盖网络）定义<code>webnet</code>网络。</li></ul><h2 id="运行你的全新的负载均衡应用"><a href="#运行你的全新的负载均衡应用" class="headerlink" title="运行你的全新的负载均衡应用"></a>运行你的全新的负载均衡应用</h2><p>在我们可以使用<code>docker stack deploy</code>命令之前，我们首先运行：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">swarm </span>init</div></pre></td></tr></table></figure><blockquote><p>注意：我们在Part4部分深入了解该命令的含义。如果你不运行<code>docker swarm init</code>命令的话，你会得到这样一条错误信息：”this node is not a swarm manager.”。</p></blockquote><p>现在，让我们来运行它吧。你需要给你的应用起一个名字。这里我们起名为<code>getstartedlab</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div></pre></td></tr></table></figure><p>我们的单个service堆栈在一台主机上运行了5个部署映像的容器实例。让我们来进一步了解。</p><p>在我们的应用程序中获取一项service的service ID：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service <span class="keyword">ls</span></div></pre></td></tr></table></figure><p>查找<code>web</code>service的输出信息，找到那个以你的应用程序名称作为前缀信息。如果您将其命名为与此示例中显示的相同，那么这里的名称为<code>getstartedlab_web</code>。还列出了service ID以及副本数量，镜像名称和对外暴露的端口。</p><p>在service中运行的单个容器称为<strong>task(任务)</strong>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">docker</span> service ps getstartedlab_web</div></pre></td></tr></table></figure><p>如果您只列出系统中的所有容器，任务也会显示出来，它不会被service所过滤：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">container</span> <span class="keyword">ls</span> -q</div></pre></td></tr></table></figure><p>你可以运行几次<code>curl -4 http://localhost</code>，或者通过浏览器打开这个链接尝试刷新几次。</p><p><img src="/img/18_04_26/001.png" alt=""></p><p>无论哪种方式，容器ID都会发生变化，从而显示负载均衡;在每个请求中，以循环方式选择5个任务中的一个来响应。容器ID与前一个命令(<code>docker container ls -q</code>)的输出相匹配。</p><blockquote><p><strong>在Windows10下运行？</strong></p><p>Windows10的PowerShell可以使用<code>curl</code>命令，但如果不行的话，你可以尝试获取一个Linux终端模拟器，例如<a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git BASH</a>或者下载很相似的<a href="http://gnuwin32.sourceforge.net/packages/wget.htm" target="_blank" rel="external">wget for Windows</a>。</p><p><strong>响应时间慢？</strong></p><p>根据您的环境的网络配置，容器可能需要长达30秒才能响应HTTP请求。这并不代表Docker或群集性能，而是我们稍后在本教程中讨论的未满足的Redis依赖项。就目前而言，访客柜台并不是出于同样的原因;我们还没有添加service来保存数据。</p></blockquote><h2 id="扩展应用程序"><a href="#扩展应用程序" class="headerlink" title="扩展应用程序"></a>扩展应用程序</h2><p>你可以通过修改<code>docker-compose.yml</code>中<code>replicas</code>的值来扩展应用，保存<code>docker-compose.yml</code>的改变之后，重新运行<code>docker stack deploy</code>命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div></pre></td></tr></table></figure><p>Docker执行一个就地更新，不需要先撤下堆栈或杀死任何容器。</p><p>现在，重新运行<code>docker container ls -q</code>以查看重新配置的已部署实例。如果您扩大副本，则会启动更多任务，因此还会启动更多容器。</p><h3 id="撤下应用和swarm"><a href="#撤下应用和swarm" class="headerlink" title="撤下应用和swarm"></a>撤下应用和swarm</h3><ul><li>通过指令<code>docker stack rm</code>来撤下应用：</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> getstartedlab</div></pre></td></tr></table></figure><ul><li>撤下swarm</li></ul><figure class="highlight nsis"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker swarm <span class="literal">leave</span> --<span class="literal">force</span></div></pre></td></tr></table></figure><p>用Docker新建并扩展您的应用程序非常简单。您已经朝着学习如何在生产中运行容器迈出了一大步。接下来，您将学习如何将这个应用程序作为Docker机器群集上的真正群体运行。</p><blockquote><p>注意：像这里的Compose文件是用于通过Docker来定义应用程序，并且可以通过<a href="https://docs.docker.com/docker-cloud/" target="_blank" rel="external">Docker Cloud</a>上传到云端，或者任何带有<a href="https://www.docker.com/enterprise-edition" target="_blank" rel="external">Docker 企业版</a>的云服务上。</p></blockquote><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>总而言之，在输入<code>docker run</code>运行时非常简单，生产中的容器真正实现将其作为服务运行。服务在Compose文件中编写容器的行为，此文件可用于缩放，限制和重新部署我们的应用程序。对服务的更改可以在运行时适用，使用启动服务的相同命令：<code>docker stack deploy</code>。</p><p>现阶段需要学习的一些命令：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">ls</span>                                            # <span class="keyword">List</span> stacks or apps</div><div class="line">docker <span class="keyword">stack</span> deploy -c &lt;composefile&gt; &lt;appname&gt;  # <span class="keyword">Run</span> the specified Compose <span class="keyword">file</span></div><div class="line">docker service <span class="keyword">ls</span>                 # <span class="keyword">List</span> running services associated with <span class="keyword">an</span> <span class="keyword">app</span></div><div class="line">docker service ps &lt;service&gt;                  # <span class="keyword">List</span> tasks associated with <span class="keyword">an</span> <span class="keyword">app</span></div><div class="line">docker <span class="keyword">inspect</span> &lt;task or container&gt;                   # <span class="keyword">Inspect</span> task or container</div><div class="line">docker container <span class="keyword">ls</span> -q                                      # <span class="keyword">List</span> container IDs</div><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> &lt;appname&gt;                             # Tear down <span class="keyword">an</span> application</div><div class="line">docker swarm leave --force      # Take down a single node swarm from the manager</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part3-%E6%9C%8D%E5%8A%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part2-容器</title>
      <link>http://studyai.site/2018/04/25/Docker%E5%85%A5%E9%97%A8Part2-%E5%AE%B9%E5%99%A8/</link>
      <guid>http://studyai.site/2018/04/25/Docker%E5%85%A5%E9%97%A8Part2-%E5%AE%B9%E5%99%A8/</guid>
      <pubDate>Wed, 25 Apr 2018 08:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot; t
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li><a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">安装Docker1.13或更高版本</a>。</li><li>阅读Part1部分。</li><li>让您的环境快速测试运行，以确保您全部设置完毕：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">run</span> hello-world</div></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现在是开始以Docker方式构建应用程序的时候了。我们从这种应用程序的层次结构的容器的底部开始，进行详细介绍。在这个层次上面是一个服务，它定义了容器在生产中的行为方式，如Part3部分所述。最后，在顶层的堆栈部分定义了Part5部分中涵盖的所有服务的交互。</p><ul><li>Stack （堆栈）</li><li>Services （服务）</li><li><strong>Container</strong>（容器，你在这里）</li></ul><h2 id="您的新开发环境"><a href="#您的新开发环境" class="headerlink" title="您的新开发环境"></a>您的新开发环境</h2><p>之前，如果您要开始编写Python应用程序，您第一个要做的事情就是在您的机器上安装Python运行环境。但是，这会造成您的计算机上的环境需要完美适合您的应用程序按预期运行，并且还需要与您的生产环境相匹配。</p><p>使用Docker，您可以将一个可移植的Python运行环境作为一个镜像获取，无需安装。然后，您的构建可以将基础Python镜像与应用程序代码一起包括在内，确保您的应用程序，依赖项和运行环境都在一起。</p><p>这些可移植的镜像是由称为<code>Dockerfile</code>的东西定义的。</p><h2 id="通过Dockerfile定义一个容器"><a href="#通过Dockerfile定义一个容器" class="headerlink" title="通过Dockerfile定义一个容器"></a>通过<code>Dockerfile</code>定义一个容器</h2><p><code>Dockerfile</code>定义了容器内的环境发生的事情。像访问网络接口以及磁盘驱动器等资源是在此环境内虚拟化的，这与系统的其余部分是隔离开的，因此您需要将端口映射到外部世界，并明确指定要将哪些文件“复制”到该环境中。但是，在完成这些之后，您可以预期，在此<code>Dockerfile</code>中定义的应用程序构建在运行时的行为完全相同。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><code>Dockerfile</code></h3><p>创建一个空目录。改变目录(<code>cd</code>)到这个新的目录下，创建一个叫做<code>Dockerfile</code>的文件，将下面的内容复制粘贴到这个文件中，并保存。注意记下<code>Dockerfile</code>中的注释部分。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use an official Python runtime as a parent image</span></div><div class="line"><span class="comment"># 使用一个官方的Python运行时环境作为父镜像</span></div><div class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</div><div class="line"></div><div class="line"><span class="comment"># Set the working directory to /app</span></div><div class="line"><span class="comment"># 设置工作目录到/app目录下</span></div><div class="line"><span class="keyword">WORKDIR</span> <span class="bash">/app</span></div><div class="line"></div><div class="line"><span class="comment"># Copy the current directory contents into the container at /app</span></div><div class="line"><span class="comment"># 复制当前目录内容到容器的/app目录下</span></div><div class="line"><span class="keyword">ADD</span> <span class="bash">. /app</span></div><div class="line"></div><div class="line"><span class="comment"># Install any needed packages specified in requirements.txt</span></div><div class="line"><span class="comment"># 安装所有requirements.txt中指定的需要的包</span></div><div class="line"><span class="keyword">RUN</span> <span class="bash">pip install --trusted-host pypi.python.org -r requirements.txt</span></div><div class="line"></div><div class="line"><span class="comment"># Make port 80 available to the world outside this container</span></div><div class="line"><span class="comment"># 使得该容器的80端口对外可用</span></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></div><div class="line"></div><div class="line"><span class="comment"># Define environment variable</span></div><div class="line"><span class="comment"># 定义环境变量</span></div><div class="line"><span class="keyword">ENV</span> NAME World</div><div class="line"></div><div class="line"><span class="comment"># Run app.py when the container launches</span></div><div class="line"><span class="comment"># 当容器加载时，运行app.py</span></div><div class="line"><span class="keyword">CMD</span> <span class="bash">[<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></div></pre></td></tr></table></figure><p>这个<code>Dockerfile</code>提到了我们尚未创建的两个文件，名叫<code>app.py</code>和<code>requirements.txt</code>。接下来让我们来创建出来。</p><h2 id="应用程序本身"><a href="#应用程序本身" class="headerlink" title="应用程序本身"></a>应用程序本身</h2><p>创建两个文件<code>requirements.txt</code>和<code>app.py</code>，并把他们放在和<code>Dockerfile</code>相同的目录下。这就完成了我们的应用程序，正如你看到的一样，非常简单。当上面的<code>Dockerfile</code>被内置到镜像中时，由于<code>Dockerfile</code>的<code>ADD</code>命令，<code>app.py</code>和<code>requirements.txt</code>存在，并且<code>app.py</code>的输出可以通过HTTP访问，这要归功于<code>EXPOSE</code>命令。</p><h3 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a><code>requirements.txt</code></h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Flask</span></div><div class="line">Redis</div></pre></td></tr></table></figure><h3 id="app-py"><a href="#app-py" class="headerlink" title="app.py"></a><code>app.py</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis, RedisError</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line"><span class="comment"># Connect to Redis</span></div><div class="line">redis = Redis(host=<span class="string">"redis"</span>, db=<span class="number">0</span>, socket_connect_timeout=<span class="number">2</span>, socket_timeout=<span class="number">2</span>)</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        visits = redis.incr(<span class="string">"counter"</span>)</div><div class="line">    <span class="keyword">except</span> RedisError:</div><div class="line">        visits = <span class="string">"&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;"</span></div><div class="line"></div><div class="line">    html = <span class="string">"&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;"</span> \</div><div class="line">           <span class="string">"&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;"</span> \</div><div class="line">           <span class="string">"&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;"</span></div><div class="line">    <span class="keyword">return</span> html.format(name=os.getenv(<span class="string">"NAME"</span>, <span class="string">"world"</span>), hostname=socket.gethostname(), visits=visits)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">80</span>)</div></pre></td></tr></table></figure><p>现在我们看到<code>pip install -r requirements.txt</code>命令安装了Python的Flask和Redis库，并且应用打印出了环境变量<code>NAME</code>，同时输出了方法<code>socket.gethostname()</code>输出的内容。最后，因为Redis没有运行（因为我们只安装了Python库，而不是Redis本身），所以这里应该会失败，并产生错误消息。</p><blockquote><p>注意：在容器内部访问主机的名称将检索容器ID，这与正在运行的可执行文件的进程ID相似。</p></blockquote><p>就是这样！你的系统上不需要Python或者任何<code>requirements.txt</code>文件，也不需要在你的系统上安装或运行此镜像。这看起来你并没有真正用Python和Flask建立一个运行环境，但事实上已经建立好了。</p><h2 id="构建一个应用"><a href="#构建一个应用" class="headerlink" title="构建一个应用"></a>构建一个应用</h2><p>我们准备构建应用程序。确保您仍然处于新目录的顶层。以下是<code>ls</code>命令应该显示的内容：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">ls</span></div><div class="line">Dockerfile<span class="keyword">app</span>.pyrequirements.txt</div></pre></td></tr></table></figure><p>现在运行build命令。这会创建一个Docker镜像，我们将使用<code>-t</code>标记它，这样可以给它指定一个友好的名称。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t friendlyhello .</div></pre></td></tr></table></figure><p>你构建的镜像在哪里？它在你的机器的本地Docker镜像注册表中：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line"></div><div class="line">REPOSITORY            <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID</div><div class="line">friendlyhello         latest</div></pre></td></tr></table></figure><blockquote><p>Linux用户的故障排除</p><p><em>DNS设置</em></p><p>代理服务器在启动并运行后可以阻止与您的网络应用程序的连接。如果您位于代理服务器的后面，请使用<code>ENV</code>命令为您的代理服务器指定主机和端口，将以下行添加到<code>Dockerfile</code>中：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Set proxy server, replace host:port with values for your servers</span></div><div class="line"><span class="keyword">ENV</span> http_proxy host:port</div><div class="line"><span class="keyword">ENV</span> https_proxy host:port</div></pre></td></tr></table></figure><p><em>代理服务设置</em></p><p>DNS错误配置可能会导致<code>pip</code>出现问题。您需要设置您自己的DNS服务器地址以使<code>pip</code>正常工作。您可能需要更改Docker守护程序的DNS设置。您可以按照以下方式来编辑（或者创建）带有<code>dns</code>信息的配置文件<code>/etc/docker/daemon.json</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"dns"</span>: [<span class="string">"your_dns_address"</span>, <span class="string">"8.8.8.8"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面的例子中，列表的第一个元素是你的DNS服务器的地址。第二项是Google的DNS，当第一项不可用时可以使用它。</p><p>在继续之前，保存`daemon.json并重新启动docker服务。</p><p><code>sudo service docker restart</code></p><p>修复后，重试运行<code>build</code>命令。</p></blockquote><h2 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h2><p>运行应用程序，使用<code>-p</code>将机器的端口4000映射到容器的已发布端口<code>80</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -<span class="selector-tag">p</span> <span class="number">4000</span>:<span class="number">80</span> friendlyhello</div></pre></td></tr></table></figure><p>你可以在<code>http://0.0.0.0:80</code>看到一条消息，Python正在为你的应用程序提供服务。但是，该消息来自容器内部，它不知道您将该容器的端口<code>80</code>映射到<code>4000</code>，从而制作正确的URL<code>http://localhost:4000</code>。</p><p>在网络浏览器中转到该URL以查看网页上显示的显示内容。</p><p><img src="/img/18_04_25/004.png" alt=""></p><blockquote><p>注意：如果你正在在Windows7上使用Docker Toolbox，使用Docker Machine IP来替代<code>localhost</code>。例如：<a href="http://192.168.99.100:4000/。要查找IP地址，请使用该命令`docker-machine" target="_blank" rel="external">http://192.168.99.100:4000/。要查找IP地址，请使用该命令`docker-machine</a> ip`。</p></blockquote><p>您也可以在shell中使用<code>curl</code>命令来查看相同的内容。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl http:<span class="comment">//localhost:4000</span></div><div class="line"></div><div class="line"><span class="params">&lt;h3&gt;</span>Hello World!<span class="params">&lt;/h3&gt;</span><span class="params">&lt;b&gt;</span>Hostname:<span class="params">&lt;/b&gt;</span> <span class="number">8f</span>c990912a14<span class="params">&lt;br/&gt;</span><span class="params">&lt;b&gt;</span>Visits:<span class="params">&lt;/b&gt;</span> <span class="params">&lt;i&gt;</span>cannot connect to Redis, counter disabled<span class="params">&lt;/i&gt;</span></div></pre></td></tr></table></figure><p>这个<code>4000:80</code>的端口重映射是为了演示<code>Dockerfile</code>中的<code>EXPOSE</code>与使用<code>docker run -p</code>发布的内容之间的区别。在后面的步骤中，我们只需将主机上的端口80映射到容器中的端口80并使用<code>http://localhost</code>。</p><p>在终端中点击<code>CTRL + C</code>退出。</p><blockquote><p><strong>在Windows下，显式的停止容器</strong></p><p>在Windows系统下，<code>CTRL+C</code>不会停止容器。到目前为止，首先键入<code>CTRL+C</code>以获取提示（或打开另一个shell），然后输入<code>docker container ls</code>来列出运行中的容器，其次是<code>docker container stop &lt;Container NAME or ID&gt;</code>来停止容器。否则，你会在下一步重新运行容器时得到一个来自守护进程的错误消息。</p></blockquote><p>现在让我们以分离模式在后台运行应用程序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -<span class="selector-tag">p</span> <span class="number">4000</span>:<span class="number">80</span> friendlyhello</div></pre></td></tr></table></figure><p>您可以获取应用的长容器ID，然后将其显示到终端。你的容器在后台运行。你也可以通过<code>docker container ls</code>来看到简短的容器ID（并且在运行命令时可以互换使用）。</p><p>注意到<code>CONTAINER ID</code>与<code>http://localhost:4000</code>上的内容匹配。</p><p>现在我们使用<code>docker container stop</code>来结束指定<code>CONTAINER ID</code><br>的进程，像这样：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container <span class="built_in">stop</span> <span class="number">1</span>fa4ab2cf395</div></pre></td></tr></table></figure><h2 id="分享你的image"><a href="#分享你的image" class="headerlink" title="分享你的image"></a>分享你的image</h2><p>为了演示我们刚才创建的可移植性，我们上传我们构建的镜像并在其他地方运行它。毕竟，当您想要将容器部署到生产环境时，您需要知道如何推送注册表。</p><p>注册表是存储库的集合，而存储库是镜像的集合 - 有点像GitHub存储库，但不同的是这里代码已经创建。注册表上的帐户可以创建许多存储库。 <code>docker</code> CLI默认使用Docker的公共注册表。</p><blockquote><p>注意：我们在这里使用Docker的公共注册表仅仅是因为它是免费和预先配置的，但是有许多公共选项可供选择，您甚至可以使用<a href="https://docs.docker.com/datacenter/dtr/2.2/guides/" target="_blank" rel="external">Docker Trusted Registry</a>设置您自己的私有注册表。</p></blockquote><h3 id="登录你的Docker-ID"><a href="#登录你的Docker-ID" class="headerlink" title="登录你的Docker ID"></a>登录你的Docker ID</h3><p>如果你没有Docker账号，需要在<a href="cloud.docker.com">cloud.docker.com</a>上注册一个。记下你的用户名。</p><p>登录到本地计算机上的Docker公共注册表。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>docker login</div></pre></td></tr></table></figure><h3 id="给镜像打标签"><a href="#给镜像打标签" class="headerlink" title="给镜像打标签"></a>给镜像打标签</h3><p>将本地镜像与注册表中的存储库相关联的符号是<code>username/repository:tag</code>。该tag是可选的，但建议使用，因为它是注册管理机构用于为Docker镜像提供版本的机制。为该上下文提供存储库并标记有意义的名称，例如<code>get-started:part2</code>。这将镜像置于启动存储库中，并将其标记为<code>part2</code>。</p><p>现在，给镜像整体的打上标签。带入你的用户名、仓库名、和标签名运行<code>docker tag image</code>以便将镜像上传到你想要的地址。命令的语法如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">tag</span> <span class="title">image</span> username/repository:<span class="keyword">tag</span></div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">tag</span> <span class="title">friendlyhello</span> john/get-<span class="literal">started</span>:part2</div></pre></td></tr></table></figure><p>运行<code>docker image ls</code>来查看你的新的带有标签信息的镜像：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ <span class="string">docker </span><span class="string">image </span><span class="string">ls</span></div><div class="line"></div><div class="line"><span class="string">REPOSITORY </span>              <span class="string">TAG </span>                <span class="string">IMAGE </span><span class="string">ID </span>           <span class="string">CREATED </span>            <span class="string">SIZE</span></div><div class="line"><span class="string">friendlyhello </span>           <span class="string">latest </span>             <span class="string">d9e555c53008 </span>       3 <span class="string">minutes </span><span class="string">ago </span>      <span class="string">195MB</span></div><div class="line"><span class="string">john/</span><span class="built_in">get-started</span>         <span class="string">part2 </span>              <span class="string">d9e555c53008 </span>       3 <span class="string">minutes </span><span class="string">ago </span>      <span class="string">195MB</span></div><div class="line"><span class="string">python </span>                  2.<span class="string">7-slim </span>           <span class="string">1c7128a655f6 </span>       5 <span class="string">days </span><span class="string">ago </span>         <span class="string">183MB</span></div><div class="line">...</div></pre></td></tr></table></figure><h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><p>上传带有标签信息的镜像到仓库中：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">docker</span> <span class="keyword">push </span>username/repository:tag</div></pre></td></tr></table></figure><p>完成后，此上传的结果将公开发布。如果你登录到<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>，你会在那里看到带有pull命令的新的镜像文件。</p><h3 id="从远程仓库中下拉并且运行镜像"><a href="#从远程仓库中下拉并且运行镜像" class="headerlink" title="从远程仓库中下拉并且运行镜像"></a>从远程仓库中下拉并且运行镜像</h3><p>截止到目前，你可以使用<code>docker run</code>命令来在任何机器上运行你的应用：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -p <span class="attribute">4000</span>:<span class="number">80</span> username/<span class="attribute">repository</span>:tag</div></pre></td></tr></table></figure><p>如果镜像在本地机器上不可用，Docker会从远程仓库中下拉到本地。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ <span class="string">docker </span><span class="string">run </span>-p <span class="string">4000:80 </span><span class="string">john/</span><span class="built_in">get-started:part2</span></div><div class="line"><span class="string">Unable </span><span class="string">to </span><span class="string">find </span><span class="string">image </span><span class="string">'john/get-started:part2'</span> <span class="string">locally</span></div><div class="line"><span class="string">part2:</span> <span class="string">Pulling </span><span class="string">from </span><span class="string">john/</span><span class="built_in">get-started</span></div><div class="line"><span class="string">10a267c67f42:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">f68a39a6a5e4:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">9beaffc0cf19:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">3c1fe835fb6b:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">4c9f1fa8fcb8:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">ee7d8f576a14:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">fbccdcced46e:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">Digest:</span> <span class="string">sha256:0601c866aab2adcc6498200efd0f754037e909e5fd42069adeff72d1e2439068</span></div><div class="line"><span class="string">Status:</span> <span class="string">Downloaded </span><span class="string">newer </span><span class="string">image </span><span class="string">for </span><span class="string">john/</span><span class="built_in">get-started:part2</span></div><div class="line"> * <span class="string">Running </span><span class="string">on </span><span class="string">http:</span>//0.0.0.<span class="string">0:80/</span> (<span class="string">Press </span><span class="string">CTRL+</span>C <span class="string">to </span><span class="string">quit)</span></div></pre></td></tr></table></figure><p>不管<code>docker run</code>在哪里运行，它都会将你的镜像以及Python和<code>requirements.txt</code>中所有的依赖关系一起提取出来，并运行您的代码。它们都在一个整洁的小包中一起旅行，并且Docker不需要您在主机上安装任何东西来运行它。</p><h2 id="Part2结论"><a href="#Part2结论" class="headerlink" title="Part2结论"></a>Part2结论</h2><p>这里列出了这个页面的基本Docker命令，以及一些相关的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">docker build -t friendlyhello .  <span class="comment"># Create image using this directory's Dockerfile</span></div><div class="line">docker run -p 4000:80 friendlyhello  <span class="comment"># Run "friendlyname" mapping port 4000 to 80</span></div><div class="line">docker run <span class="_">-d</span> -p 4000:80 friendlyhello         <span class="comment"># Same thing, but in detached mode</span></div><div class="line">docker container ls                                <span class="comment"># List all running containers</span></div><div class="line">docker container ls <span class="_">-a</span>             <span class="comment"># List all containers, even those not running</span></div><div class="line">docker container stop &lt;<span class="built_in">hash</span>&gt;           <span class="comment"># Gracefully stop the specified container</span></div><div class="line">docker container <span class="built_in">kill</span> &lt;<span class="built_in">hash</span>&gt;         <span class="comment"># Force shutdown of the specified container</span></div><div class="line">docker container rm &lt;<span class="built_in">hash</span>&gt;        <span class="comment"># Remove specified container from this machine</span></div><div class="line">docker container rm $(docker container ls <span class="_">-a</span> -q)         <span class="comment"># Remove all containers</span></div><div class="line">docker image ls <span class="_">-a</span>                             <span class="comment"># List all images on this machine</span></div><div class="line">docker image rm &lt;image id&gt;            <span class="comment"># Remove specified image from this machine</span></div><div class="line">docker image rm $(docker image ls <span class="_">-a</span> -q)   <span class="comment"># Remove all images from this machine</span></div><div class="line">docker login             <span class="comment"># Log in this CLI session using your Docker credentials</span></div><div class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># Tag &lt;image&gt; for upload to registry</span></div><div class="line">docker push username/repository:tag            <span class="comment"># Upload tagged image to registry</span></div><div class="line">docker run username/repository:tag                   <span class="comment"># Run image from a registry</span></div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://studyai.site/2018/04/25/Docker%E5%85%A5%E9%97%A8Part2-%E5%AE%B9%E5%99%A8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
