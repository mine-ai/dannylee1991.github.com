<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>studyAI</title>
    <link>http://studyai.site/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 11 Nov 2018 17:08:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>隐马尔科夫模型</title>
      <link>http://studyai.site/2018/11/11/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/</link>
      <guid>http://studyai.site/2018/11/11/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/</guid>
      <pubDate>Sun, 11 Nov 2018 11:20:58 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;隐马尔可夫模型&quot;&gt;&lt;a href=&quot;#隐马尔可夫模型&quot; class=&quot;headerlink&quot; title=&quot;隐马尔可夫模型&quot;&gt;&lt;/a&gt;隐马尔可夫模型&lt;/h2&gt;&lt;p&gt;解决时序性的预测问题，我们通常会用到HMM模型（隐马尔科夫模型），但在开始介绍HMM模型之前，我们有
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h2><p>解决时序性的预测问题，我们通常会用到HMM模型（隐马尔科夫模型），但在开始介绍HMM模型之前，我们有必要先了解它的前置知识：</p><ul><li>马尔科夫链</li><li>马尔科夫模型</li></ul><h3 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h3><p>现有状态只和上一个状态有关，而未来状态只与现有状态有关:</p><p><img src="/img/18_11_11/001.png" width="400" hegiht="213" align="center"></p><p>满足这样的一种结构，我们就称之为<strong>马尔科夫链</strong>。</p><p>如果一个系统，在做不同状态之间转换的时候，当前状态只受到过的一个状态的影响，和其他状态都没有关系；换句话说，这个系统内的未来的一个状态只受到当前状态的影响，和其他状态都无关，满足这样性质的一个系统，我们就称之为是一个具有<strong>马尔科夫性</strong>的系统。</p><p>一个马尔科夫链，需要具备以下参数：</p><ul><li>初始分布</li><li>转移概率和转移概率矩阵</li></ul><h4 id="初始分布"><a href="#初始分布" class="headerlink" title="初始分布"></a>初始分布</h4><p>其中，初始分布如下：</p><p>$$<br>\pi_j(0) = P\{ξ_0=j\}<br>$$</p><p>这个公式的含义是在一个系统内，各个状态初始时的概率分布情况。其中$\pi$是概率分布的意思。举例说明：</p><p>例如：假设一个系统内只有1、2、3这三种状态，其中状态1出现的概率为0.2，状态2出现的概率是0.3，状态3出现的概率是0.5。这三个概率即初始概率分布。</p><h4 id="转移概率和转移概率矩阵"><a href="#转移概率和转移概率矩阵" class="headerlink" title="转移概率和转移概率矩阵"></a>转移概率和转移概率矩阵</h4><p>继续上面的例子。当我们处于状态1时，下一个状态可能是状态2，可能是状态3，也可能是状态1。如果状态1变为状态2的概率是0.2，状态1变为状态3的概率是0.3，状态1变为状态1的概率是0.5：</p><p><img src="/img/18_11_11/002.png" width="400" hegiht="213" align="center"></p><p>这里的概率就是<strong>转移概率</strong>。</p><p>对于某一个状态来说，具有的转移概率一共有3个，那么对于3种状态来说一共有3x3=9个转移概率。我们可以用一个3x3的矩阵来表示。这个矩阵就被称为<strong>转移概率矩阵</strong>。</p><hr><p>一个具体的例子，<strong>愚蠢的顾客</strong>：</p><ul><li>某同类物品A、B、C的宣传力度不同，愚蠢的顾客在广告宣传的效应下，第一次尝试选择购买A、B、C的概率为0.2，0.4，0.4。经零售商统计，顾客的购买倾向为下表，尝试求某顾客第四次来购买各物品的概率：</li></ul><p><img src="/img/18_11_11/003.png" alt=""></p><p>在这个例子中，第一次购买A、B、C的概率0.2，0.4，0.4就是<strong>初始分布</strong>，上面的那个表就是<strong>状态转移矩阵</strong>。</p><h3 id="可观测的马尔科夫模型"><a href="#可观测的马尔科夫模型" class="headerlink" title="可观测的马尔科夫模型"></a>可观测的马尔科夫模型</h3><p>上面的描述都是关于<strong>马尔科夫链</strong>的，那么什么是<strong>马尔科夫模型</strong>呢？</p><ul><li><p>对于一个问题而言，我们有初始分布$\pi$，转移概率矩阵A，在给定的任意一个时刻t，我们都有一个状态$q_t$，随着时间的变化，一个状态转移到另一个状态，我们便能得到一个观测序列，<strong>即为状态序列</strong>$O=[q_1,q_2,q_3,q_4,…,q_m]$。而且整个问题中一共有n个观测状态。</p></li><li><p>出现这样的序列的概率为：</p></li></ul><p>$$<br>P(O|A,\pi)=P(q_1)\prod_{t=2}^mP(q_t|q_{t-1})<br>$$</p><p>所以一个可观测的马尔科夫模型由一个三元组描述：$(A,\pi,n)$一般情况下简写为$(A,\pi)$。（因为观测状态的数量n可以从状态概率分布$\pi$得出）</p><p>这里的$A$就是转移概率矩阵，$\pi$就是状态初始分布，$n$就是观测状态的数量。</p><p>举个例子：</p><ul><li>有一个抽屉，抽屉里放有三种颜色的球，颜色分别为红蓝绿。某人随机的将球一个一个从抽屉中取出，球的颜色依次构成序列(C1,C2,C3,…)。如果红、蓝、绿三个状态的初始分布为$\pi=(0.5,0.2,0.3)$，转移概率矩阵:</li></ul><p>$$<br>A=\begin{pmatrix}<br>0.4 &amp; 0.3 &amp; 0.3 \\<br>0.2 &amp; 0.6 &amp; 0.2 \\<br>0.1 &amp; 0.1 &amp; 0.8<br>\end{pmatrix}<br>$$</p><ul><li>那么出现颜色序列为：红，红，绿，绿 的概率是多少？</li></ul><p><strong>解答：</strong></p><p>初始概率分布$\pi=(0.5,0.2,0.3)$，可以看出，初始为红色的概率为0.5。</p><p>从状态转移矩阵可以看出，各个颜色变化的概率分布：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">红</th><th style="text-align:center">蓝</th><th style="text-align:center">绿</th></tr></thead><tbody><tr><td style="text-align:center"><strong>红</strong></td><td style="text-align:center">0.4</td><td style="text-align:center">0.3</td><td style="text-align:center">0.3</td></tr><tr><td style="text-align:center"><strong>蓝</strong></td><td style="text-align:center">0.2</td><td style="text-align:center">0.6</td><td style="text-align:center">0.2</td></tr><tr><td style="text-align:center"><strong>绿</strong></td><td style="text-align:center">0.1</td><td style="text-align:center">0.1</td><td style="text-align:center">0.8</td></tr></tbody></table><p>可以看出，红色转移到红色的概率为0.4，红色转移到绿色的概率是0.3，绿色转移到绿色的概率是0.8。所以最终出现序列红，红，绿，绿 的概率为：</p><p>$$<br>P = 0.5 \times 0.4 \times 0.3 \times 0.8 = 0.048<br>$$</p><p>所以上面的那个公式就是将所求的序列O之中的各个状态的转移概率连乘起来得到的最终概率：</p><p>$$<br>P(O|A,\pi)=P(q_1)\prod_{t=2}^mP(q_t|q_{t-1})<br>$$</p><p><strong>问题来了</strong></p><p>那么我们能不能在只知道观测序列的情况下，得知初始分布和转移概率矩阵呢？</p><p><strong>解答：</strong></p><p>如果我们穷举了所有的观测序列，那么：</p><p>$$<br>\pi_i=\frac{以状态i开始的序列的数目}{序列总数}<br>$$</p><p>$$<br>p_{ij}=\frac{从状态i转移到状态j的序列的数目}{从状态i开始的序列的总数}<br>$$</p><p>具体实例，比如我们从抽屉中抽小球，四次的观测序列如下：</p><ul><li>[红，红，红]</li><li>[红，红，蓝]</li><li>[红，蓝，红]</li><li>[蓝，红，红]</li></ul><p>可以得出初始分布为：</p><p>$$<br>\pi={0.75, 0.25}<br>$$</p><p>转移概率为：</p><p>$$<br>p_{红蓝} = 1/3  \\<br>p_{红红} = 2/3  \\<br>p_{蓝蓝} = 0        \\<br>p_{蓝红} = 1<br>$$</p><h3 id="隐马尔科夫模型（Hidden-Markov-Model）"><a href="#隐马尔科夫模型（Hidden-Markov-Model）" class="headerlink" title="隐马尔科夫模型（Hidden Markov Model）"></a>隐马尔科夫模型（Hidden Markov Model）</h3><p>介绍完了上面的可观测的马尔科夫模型，接下来介绍<strong>隐马尔科夫模型</strong>。</p><p>隐马尔科夫模型的基本想法是：系统的状态S无法观测，但我们可以观测到某个其他和状态关联的事物，这个事物出现是伴随系统状态而出现的。</p><p>为什么会有无法观测的情况呢？举个例子：观测天空是否在下雨这个现象可以通过观测苔藓的生长情况来判断。比如下雨天，苔藓生长比较茂盛。所以我们可以通过观察苔藓来判断下雨的概率是否大。</p><p><img src="/img/18_11_11/004.png" alt=""></p><p>一个<strong>隐马尔科夫模型</strong>一般包含以下参数组成：</p><ul><li>观测集合：$R=\{R_1,R_2,R_3,R_4,…,R_m\}$<ul><li>代表我们能观测到的状态有哪些，比如抓小球的例子中就是红蓝绿三种颜色。</li></ul></li><li>观测序列：$O=[o_1,o_2,o_3,o_4,…,o_l]$<ul><li>代表我们能观测到的具体的观测序列</li></ul></li><li>状态集合：$S=\{S_1,S_2,S_3,S_4,…,S_n\}$<ul><li>代表状态的集合，比如上面的下雨天的例子中，状态就是晴天、雨天</li></ul></li><li>状态序列：$Q=[q_1,q_2,q_3,q_4,…,q_l]$<ul><li>就是出现某些状态的序列</li></ul></li><li>观测概率：$P\{o_i=R_k|q_t=S_j\}=b_j(i)$，记$B=[b_j(i)]$<ul><li>观测概率是隐马尔科夫模型特有的，在$t$时刻的时候，出现状态$q$，观测到状态$o_i$为指定状态$R_k$的概率。</li></ul></li></ul><p>所以，隐马尔可夫模型由一个五元组来描述$(A,B,\pi,R,S)$，一般情况下，可以简化为$(A,B,\pi)$。其中$A$是状态转移矩阵，$B$是观测概率，$\pi$是初始分布。</p><p><strong>注意</strong></p><ul><li>不同的状态序列可以产生相同的观测序列（以不同的概率产生）</li><li>状态转移是随机的，系统在一个状态中产生的观测也是随机的</li><li>可观测马尔科夫模型是隐马尔科夫模型的特例：当$m=n$，如果$i=j,b_j(i)=1$否则$b_j(i)=0$。<ul><li>即在马尔科夫模型下，状态序列和观测序列是一样的。</li></ul></li></ul><h4 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h4><p>隐马尔可夫模型一般可以用来解决三个基本问题：</p><ul><li>（1）<strong>估计</strong>：已知模型$(A,B,\pi)$，求观测序列出现的概率<ul><li>解决方法：前后向算法</li></ul></li><li>（2）<strong>预测</strong>：已知模型$(A,B,\pi)$和一个观测序列，求对应的不可观测的状态序列<ul><li>解决方法：Viterbi算法</li></ul></li><li>（3）<strong>学习</strong>：已知一组观测序列，求模型$(A,B,\pi)$<ul><li>解决方法：Baum-Welch算法</li></ul></li></ul><p>下面用一个具体的例子来了解一下这三个基本问题是如何处理的。</p><p><strong>股市预测</strong></p><ul><li>如果股市只有三种状态：牛市、熊市、普通</li><li>而且股票只有三种趋势：涨、跌、不变</li><li>如何利用隐马尔可夫模型进行股市预测？</li></ul><p><img src="/img/18_11_11/005.png" width="400" hegiht="213" align="center"></p><p>那么如果在股市预测问题中，应用隐马尔科夫模型，来解决上面的那三个对应的基本问题，分别如下：</p><ul><li>（1）已知模型，求观测到连续一周出现涨势的概率</li><li>（2）已知模型，观察到一周的变化情况为：涨、不变、涨、不变、跌，问股市的状态变化情况？</li><li>（3）观察到股市一周的变化情况为：涨、不变、涨、不变、跌，求下周一开盘时的涨跌情况？</li></ul><p>隐马尔科夫模型的代码如下<code>hmm.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HMM</span>:</span></span><br><span class="line">    <span class="string">"""Class to implement an HMM.</span></span><br><span class="line"><span class="string">    Defined by:</span></span><br><span class="line"><span class="string">        1. Hidden state transition probability matrix T</span></span><br><span class="line"><span class="string">        2. Observable emission probability matrix E</span></span><br><span class="line"><span class="string">        3. Prior probability matrix 'priors'</span></span><br><span class="line"><span class="string">        4. Vocabulary of possible hidden states M ('states')</span></span><br><span class="line"><span class="string">        5. Vocabulary of possible observable emissions V ('emissions')</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, states, emissions)</span>:</span></span><br><span class="line">        self._states = states</span><br><span class="line">        self._emissions = emissions</span><br><span class="line">        self._T = dict()</span><br><span class="line">        self._E = dict()</span><br><span class="line">        self._priors = dict()</span><br><span class="line">        <span class="comment">#print "Don't forget to set: T, E, and priors..."</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_T</span><span class="params">(self, new_T)</span>:</span></span><br><span class="line">        tf = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> new_T:</span><br><span class="line">            <span class="keyword">if</span> sorted(new_T[key].keys()) != sorted(self._states):</span><br><span class="line">                tf = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> sorted(new_T.keys()) != sorted(self._states):</span><br><span class="line">            tf = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tf: self._T = new_T</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"""Unmatched key -- check dictionary!</span></span><br><span class="line"><span class="string">            T =&gt; T[to state][given state]</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_E</span><span class="params">(self, new_E)</span>:</span></span><br><span class="line">        tf = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> new_E:</span><br><span class="line">            <span class="keyword">if</span> sorted(new_E[key].keys()) != sorted(self._states):</span><br><span class="line">                tf = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> sorted(new_E.keys()) != sorted(self._emissions):</span><br><span class="line">            tf = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tf: self._E = new_E</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"""Unmatched key -- check dictionary!</span></span><br><span class="line"><span class="string">            E =&gt; E[emission][given state]</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_priors</span><span class="params">(self, new_priors)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sorted(new_priors.keys()) == sorted(self._states):</span><br><span class="line">            self._priors = new_priors</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"""Unmatched key -- check dictionary!</span></span><br><span class="line"><span class="string">            priors =&gt; priors[state]</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># **************************************************</span></span><br><span class="line"><span class="comment"># Functions that take an observation sequence and an HMM</span></span><br><span class="line"><span class="comment"># **************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(O, hmm)</span>:</span></span><br><span class="line">    <span class="string">"""Return trellis representing p(theta_t | O_1^t).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># initialize local variables</span></span><br><span class="line">    n = len(O)</span><br><span class="line">    f = &#123;state: list() <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states&#125;</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> O:</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">            f[state].append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct forward trellis</span></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">        f[state][<span class="number">0</span>] = hmm._priors[state] * hmm._E[O[<span class="number">0</span>]][state]</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> hmm._states:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> hmm._states:</span><br><span class="line">                f[j][t] += f[i][t<span class="number">-1</span>] * hmm._T[j][i] * hmm._E[O[t]][j]</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(O, hmm)</span>:</span></span><br><span class="line">    <span class="string">"""Return trellis representing p(O_t+1^N | theta_t == i).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># initialize local variables</span></span><br><span class="line">    n = len(O)</span><br><span class="line">    b = &#123;state: list() <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states&#125;</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> O:</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">            b[state].append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct backward trellis</span></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">        b[state][n<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> hmm._states:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> hmm._states:</span><br><span class="line">                b[i][t] += b[j][t+<span class="number">1</span>] * hmm._T[j][i] * hmm._E[O[t+<span class="number">1</span>]][j]</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">posterior</span><span class="params">(O, hmm)</span>:</span></span><br><span class="line">    <span class="string">"""Return trellis representing p(theta_t | O).</span></span><br><span class="line"><span class="string">    Posterior probabilities would be used to find the maximum likelihood</span></span><br><span class="line"><span class="string">        of a state at a given time step based on the observation sequence</span></span><br><span class="line"><span class="string">        O.  The value returned by the forward algorithm is the O_prob</span></span><br><span class="line"><span class="string">        value returned here.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># get n</span></span><br><span class="line">    n = len(O)</span><br><span class="line">    <span class="comment"># initialize forward, backward, and posterior trellises</span></span><br><span class="line">    f = forward(O, hmm)</span><br><span class="line">    b = backward(O, hmm)</span><br><span class="line">    p = &#123;state: list() <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states&#125;</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> O:</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">            p[state].append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># total probability of sequence O</span></span><br><span class="line">    O_prob = math.fsum([f[state][n<span class="number">-1</span>] <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># build posterior trellis</span></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(n):</span><br><span class="line">            p[state][t] = (f[state][t] * b[state][t]) / O_prob</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_algrithm</span><span class="params">(O, hmm)</span>:</span></span><br><span class="line">    f = forward(O, hmm)</span><br><span class="line">    prop = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> stat <span class="keyword">in</span> hmm._T:</span><br><span class="line">        prop += f[stat][len(O)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">viterbi_path</span><span class="params">(O, hmm)</span>:</span></span><br><span class="line">    <span class="string">"""Return most likely hidden state path given observation sequence O.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = len(O)</span><br><span class="line">    u = &#123;state: list() <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states&#125;</span><br><span class="line">    v = &#123;state: list() <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states&#125;</span><br><span class="line">    bt = list()</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> O:</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> (u, v):</span><br><span class="line">                u[state].append(<span class="number">0</span>)</span><br><span class="line">                v[state].append(str())</span><br><span class="line">        bt.append(str())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">        u[state][<span class="number">0</span>] = hmm._priors[state] * hmm._E[O[<span class="number">0</span>]][state]</span><br><span class="line">        <span class="comment"># v[state][0] not of interest</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> hmm._states:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> hmm._states:</span><br><span class="line">                p = u[i][t<span class="number">-1</span>] * hmm._T[j][i] * hmm._E[O[t]][j]</span><br><span class="line">                <span class="keyword">if</span> p &gt; u[j][t]:</span><br><span class="line">                    u[j][t] = p</span><br><span class="line">                    v[j][t] = i</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">        <span class="keyword">if</span> u[state][n<span class="number">-1</span>] &gt; p:</span><br><span class="line">            p = u[state][n<span class="number">-1</span>]</span><br><span class="line">            bt[n<span class="number">-1</span>] = state</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        bt[t] = v[bt[t+<span class="number">1</span>]][t+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baum_welch</span><span class="params">(O, hmm)</span>:</span></span><br><span class="line">    <span class="string">"""Return new hmm from one iteration of re-estimation."""</span></span><br><span class="line">    n = len(O)</span><br><span class="line">    f = forward(O, hmm)</span><br><span class="line">    b = backward(O, hmm)</span><br><span class="line">    p = posterior(O, hmm)</span><br><span class="line">    E_prime = dict()</span><br><span class="line">    <span class="keyword">for</span> emission <span class="keyword">in</span> hmm._emissions: E_prime[emission] = dict()</span><br><span class="line">    T_prime = dict()</span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states: T_prime[state] = dict()</span><br><span class="line">    priors_prime = dict()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct E_prime</span></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">        den = math.fsum([p[state][t] <span class="keyword">for</span> t <span class="keyword">in</span> range(n)])</span><br><span class="line">        <span class="keyword">for</span> emission <span class="keyword">in</span> hmm._emissions:</span><br><span class="line">            v = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> O[t] == emission: v += p[state][t]</span><br><span class="line">            E_prime[emission][state] = v / den</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct T_prime</span></span><br><span class="line">    p_O = math.fsum([f[s][n<span class="number">-1</span>] <span class="keyword">for</span> s <span class="keyword">in</span> hmm._states])</span><br><span class="line">    <span class="keyword">for</span> given <span class="keyword">in</span> hmm._states:</span><br><span class="line">        den = math.fsum([p[given][t] <span class="keyword">for</span> t <span class="keyword">in</span> range(n)])</span><br><span class="line">        <span class="keyword">for</span> to <span class="keyword">in</span> hmm._states:</span><br><span class="line">            v = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                v += ( f[given][t<span class="number">-1</span>] *</span><br><span class="line">                       b[to][t] *</span><br><span class="line">                       hmm._T[to][given] *</span><br><span class="line">                       hmm._E[O[t]][to]</span><br><span class="line">                      ) / p_O</span><br><span class="line">            T_prime[to][given] = v / den</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct priors_prime</span></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> hmm._states:</span><br><span class="line">        priors_prime[state] = p[state][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    new_hmm = HMM(hmm._states, hmm._emissions)</span><br><span class="line">    new_hmm.set_E(E_prime)</span><br><span class="line">    new_hmm.set_T(T_prime)</span><br><span class="line">    new_hmm.set_priors(priors_prime)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_hmm</span><br></pre></td></tr></table></figure><p>下面我们来用这个模型解决这三个问题。</p><h5 id="估计问题：已知模型，求观测到连续一周出现涨势的概率"><a href="#估计问题：已知模型，求观测到连续一周出现涨势的概率" class="headerlink" title="估计问题：已知模型，求观测到连续一周出现涨势的概率"></a>估计问题：已知模型，求观测到连续一周出现涨势的概率</h5><p>已知模型如下图所示：</p><p><img src="/img/18_11_11/006.png" width="660" hegiht="413" align="center"></p><p>某股民根据经验判断当前为牛市、熊市、普通的概率分别是0.4、0.3、0.3。</p><p>这个问题中，我们的观测状态集合为：牛市、熊市、普通</p><p>我们的发射状态集合为：涨、跌、不变</p><p>初始分布$\pi$为：$(0.4, 0.3, 0.3)$</p><p>转移概率矩阵A：$<br>A=\begin{pmatrix}<br>0.6 &amp; 0.2 &amp; 0.2 \\<br>0.5 &amp; 0.3 &amp; 0.2 \\<br>0.4 &amp; 0.1 &amp; 0.5<br>\end{pmatrix}<br>$</p><p>观测概率矩阵B：$<br>A=\begin{pmatrix}<br>0.7 &amp; 0.1 &amp; 0.2 \\<br>0.1 &amp; 0.6 &amp; 0.3 \\<br>0.3 &amp; 0.3 &amp; 0.4<br>\end{pmatrix}<br>$</p><p>求连续一周出现涨势的概率，我们应该使用<strong>前后向算法</strong><code>forward_algrithm()</code>。改算法接收一个hmm模型。我们在初始化hmm模型的时候，需要设置观测状态<code>states</code>、发射状态<code>emissions</code>，转移概率矩阵<code>set_T()</code>，发射概率矩阵<code>set_E()</code>，以及初始分布<code>set_priors()</code>。</p><p>我们初始化好这些参数：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">def initTestModel():</span><br><span class="line">    model = hmm.HMM([<span class="string">'bull'</span>, <span class="string">'bear'</span>, <span class="string">'normal'</span>], [<span class="string">'up'</span>, <span class="string">'down'</span>, <span class="string">'unchange'</span>])</span><br><span class="line">    transition_matrix = &#123;</span><br><span class="line">        <span class="string">'bull'</span>: &#123;</span><br><span class="line">            <span class="string">'bull'</span>: <span class="number">0</span>.<span class="number">6</span>,</span><br><span class="line">            <span class="string">'bear'</span>: <span class="number">0</span>.<span class="number">2</span>,</span><br><span class="line">            <span class="string">'normal'</span>: <span class="number">0</span>.<span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'bear'</span>: &#123;</span><br><span class="line">            <span class="string">'bull'</span>: <span class="number">0</span>.<span class="number">5</span>,</span><br><span class="line">            <span class="string">'bear'</span>: <span class="number">0</span>.<span class="number">3</span>,</span><br><span class="line">            <span class="string">'normal'</span>: <span class="number">0</span>.<span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'normal'</span>: &#123;</span><br><span class="line">            <span class="string">'bull'</span>: <span class="number">0</span>.<span class="number">4</span>,</span><br><span class="line">            <span class="string">'bear'</span>: <span class="number">0</span>.<span class="number">1</span>,</span><br><span class="line">            <span class="string">'normal'</span>: <span class="number">0</span>.<span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    emission_matrix = &#123;</span><br><span class="line">        <span class="string">'up'</span>: &#123;</span><br><span class="line">            <span class="string">'bull'</span>: <span class="number">0</span>.<span class="number">7</span>,</span><br><span class="line">            <span class="string">'bear'</span>: <span class="number">0</span>.<span class="number">1</span>,</span><br><span class="line">            <span class="string">'normal'</span>: <span class="number">0</span>.<span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'down'</span>: &#123;</span><br><span class="line">            <span class="string">'bull'</span>: <span class="number">0</span>.<span class="number">1</span>,</span><br><span class="line">            <span class="string">'bear'</span>: <span class="number">0</span>.<span class="number">6</span>,</span><br><span class="line">            <span class="string">'normal'</span>: <span class="number">0</span>.<span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'unchange'</span>: &#123;</span><br><span class="line">            <span class="string">'bull'</span>: <span class="number">0</span>.<span class="number">2</span>,</span><br><span class="line">            <span class="string">'bear'</span>: <span class="number">0</span>.<span class="number">3</span>,</span><br><span class="line">            <span class="string">'normal'</span>: <span class="number">0</span>.<span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = &#123;<span class="string">'bull'</span>:<span class="number">0</span>.<span class="number">4</span>, <span class="string">'bear'</span>:<span class="number">0</span>.<span class="number">3</span>, <span class="string">'normal'</span>:<span class="number">0</span>.<span class="number">3</span>&#125;</span><br><span class="line"> </span><br><span class="line">    model.set_T(transition_matrix)</span><br><span class="line">    model.set_E(emission_matrix)</span><br><span class="line">    model.set_priors(p)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p>初始化模型完成之后，调用<code>forward_algrithm()</code>即可得出指定观测序列的预测结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">()</span>:</span></span><br><span class="line">    model = initTestModel()</span><br><span class="line">    prop = model.forward_algrithm([<span class="string">'up'</span>, <span class="string">'up'</span>, <span class="string">'up'</span>, <span class="string">'up'</span>, <span class="string">'up'</span>], model)</span><br><span class="line">    <span class="keyword">print</span> prop</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0232968298</span></span><br></pre></td></tr></table></figure><p>下面的代码可以查看所有组合可能出现的概率：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> generate_weekly_list():</span><br><span class="line">    status = [<span class="string">'up'</span>,<span class="string">'down'</span>,<span class="string">'unchange'</span>]</span><br><span class="line"> </span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    weekly_list = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> statu1 <span class="keyword">in</span> <span class="string">status:</span></span><br><span class="line">        <span class="keyword">for</span> statu2 <span class="keyword">in</span> <span class="string">status:</span></span><br><span class="line">            <span class="keyword">for</span> statu3 <span class="keyword">in</span> <span class="string">status:</span></span><br><span class="line">                <span class="keyword">for</span> statu4 <span class="keyword">in</span> <span class="string">status:</span></span><br><span class="line">                    <span class="keyword">for</span> statu5 <span class="keyword">in</span> <span class="string">status:</span></span><br><span class="line">                        key = statu1 + <span class="string">','</span> + statu2 + <span class="string">','</span> + statu3 + <span class="string">','</span> + statu4 + <span class="string">','</span> + statu5</span><br><span class="line">                        value = [statu1, statu2, statu3, statu4, statu5]</span><br><span class="line">                        weekly_list[key] = value</span><br><span class="line">    <span class="keyword">return</span> weekly_list</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> evaluate():</span><br><span class="line">    model = initTestModel()</span><br><span class="line"> </span><br><span class="line">    all_list = generate_weekly_list()</span><br><span class="line">    prop_list = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="string">all_list:</span></span><br><span class="line">        prop = hmm.forward_algrithm(all_list[key], model)</span><br><span class="line">        prop_list[key] = prop</span><br><span class="line"> </span><br><span class="line">    sort_list = sorted(prop_list.items(), lambda x, <span class="string">y:</span> cmp(x[<span class="number">1</span>], y[<span class="number">1</span>]), reverse=True)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> <span class="string">sort_list:</span></span><br><span class="line">        print (<span class="string">'%.6f:'</span> % value) + key</span><br></pre></td></tr></table></figure><h5 id="预测问题：已知模型-股市变化，求股市状态"><a href="#预测问题：已知模型-股市变化，求股市状态" class="headerlink" title="预测问题：已知模型+股市变化，求股市状态"></a>预测问题：已知模型+股市变化，求股市状态</h5><p>已知模型，观察到一周的变化情况为：涨、不变、涨、不变、跌，问股市的状态变化情况？</p><p>还是同样的模型：</p><p>观测状态集合为：牛市、熊市、普通</p><p>我们的发射状态集合为：涨、跌、不变</p><p>初始分布$\pi$为：$(0.4, 0.3, 0.3)$</p><p>转移概率矩阵A：$<br>A=\begin{pmatrix}<br>0.6 &amp; 0.2 &amp; 0.2 \\<br>0.5 &amp; 0.3 &amp; 0.2 \\<br>0.4 &amp; 0.1 &amp; 0.5<br>\end{pmatrix}<br>$</p><p>观测概率矩阵B：$<br>A=\begin{pmatrix}<br>0.7 &amp; 0.1 &amp; 0.2 \\<br>0.1 &amp; 0.6 &amp; 0.3 \\<br>0.3 &amp; 0.3 &amp; 0.4<br>\end{pmatrix}<br>$</p><p>代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">()</span>:</span></span><br><span class="line">    model = initTestModel()</span><br><span class="line">    <span class="keyword">print</span> hmm.viterbi_path([<span class="string">'up'</span>, <span class="string">'unchange'</span>, <span class="string">'up'</span>, <span class="string">'unchange'</span>, <span class="string">'down'</span>], model)</span><br></pre></td></tr></table></figure><p>结果是:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">'bull</span>', <span class="symbol">'bull</span>', <span class="symbol">'bull</span>', <span class="symbol">'bull</span>', <span class="symbol">'bear</span>']</span><br></pre></td></tr></table></figure><p>我们同样可以写出所有的组合的预测结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">()</span>:</span></span><br><span class="line">    model = initTestModel()</span><br><span class="line">    weekly_list = generate_weekly_list()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> weekly_list:</span><br><span class="line">        <span class="keyword">print</span> key + <span class="string">':'</span></span><br><span class="line">        <span class="keyword">print</span> hmm.viterbi_path(weekly_list[key], model)</span><br></pre></td></tr></table></figure><h5 id="学习问题：已知一堆观测序列，求模型"><a href="#学习问题：已知一堆观测序列，求模型" class="headerlink" title="学习问题：已知一堆观测序列，求模型"></a>学习问题：已知一堆观测序列，求模型</h5><p>某股民连续三周观测到股市的变动情况为：</p><ul><li>涨，不变，涨，跌，涨</li><li>跌，涨，跌，涨，不变</li><li>不变，不变，跌，涨，涨</li></ul><p>问，下周的变化情况？</p><p>这个问题的思路为：</p><p>根据观测序列 -&gt; 求出模型 -&gt; 得到$A,B,\pi$ -&gt; 预测当前状态 -&gt; 利用转移矩阵预测下一个状态。</p><p>代码实现如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def learn():</span><br><span class="line">    <span class="keyword">model</span> = initTestModel()</span><br><span class="line"> </span><br><span class="line">    o_list1 = [<span class="string">'up'</span>, <span class="string">'unchange'</span>, <span class="string">'up'</span>, <span class="string">'down'</span>, <span class="string">'up'</span>]</span><br><span class="line">    o_list2 = [<span class="string">'down'</span>, <span class="string">'up'</span>, <span class="string">'down'</span>, <span class="string">'up'</span>, <span class="string">'unchange'</span>]</span><br><span class="line">    o_list3 = [<span class="string">'unchange'</span>, <span class="string">'unchange'</span>, <span class="string">'down'</span>, <span class="string">'up'</span>, <span class="string">'up'</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">model</span> = hmm.baum_welch(o_list1, <span class="keyword">model</span>)</span><br><span class="line">    <span class="keyword">model</span> = hmm.baum_welch(o_list2, <span class="keyword">model</span>)</span><br><span class="line">    <span class="keyword">model</span> = hmm.baum_welch(o_list3, <span class="keyword">model</span>)</span><br><span class="line"> </span><br><span class="line">    print hmm.viterbi_path(o_list3, <span class="keyword">model</span>)</span><br></pre></td></tr></table></figure><p>得出结果为：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">'normal</span>', <span class="symbol">'bull</span>', <span class="symbol">'bear</span>', <span class="symbol">'bull</span>', <span class="symbol">'bull</span>']</span><br></pre></td></tr></table></figure><p>你也可以将转移概率矩阵打印出来：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">print</span> model._T</span><br></pre></td></tr></table></figure><hr><p>以上就是HMM模型的全部内容。</p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/11/11/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【傅里叶变换及其应用讲义】第一章 傅里叶级数</title>
      <link>http://studyai.site/2018/10/29/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9102-%E5%B0%86%E4%B8%80%E8%88%AC%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%B8%BA%E7%AE%80%E5%8D%95%E5%91%A8%E6%9C%9F/</link>
      <guid>http://studyai.site/2018/10/29/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9102-%E5%B0%86%E4%B8%80%E8%88%AC%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%B8%BA%E7%AE%80%E5%8D%95%E5%91%A8%E6%9C%9F/</guid>
      <pubDate>Sun, 28 Oct 2018 17:52:58 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;傅里叶级数&quot;&gt;&lt;a href=&quot;#傅里叶级数&quot; class=&quot;headerlink&quot; title=&quot;傅里叶级数&quot;&gt;&lt;/a&gt;傅里叶级数&lt;/h1&gt;&lt;h2 id=&quot;介绍和选择&quot;&gt;&lt;a href=&quot;#介绍和选择&quot; class=&quot;headerlink&quot; title=&quot;介绍和
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><h2 id="介绍和选择"><a href="#介绍和选择" class="headerlink" title="介绍和选择"></a>介绍和选择</h2><p>基于傅里叶变换的方法几乎用于所有工程和科学领域，几乎所有工程师和科学家都使用。 比如对于以下领域的初学者：</p><ul><li>电路设计师</li><li>光谱学家</li><li>晶体学家</li><li>从事信号处理和通信工作的任何人</li><li>从事成像工作的人员</li></ul><p>我期待课堂上会有很不同领域的同学，这对我们所有人来说都很重要。 随着兴趣和背景的多样性，并非所有的例子和应用都是大家所熟悉的，并且与所有人相关。 我们都必须互相削减一些内容，这是我们所有人分出的机会。 同样，你也应该意识到这是许多可能课程中傅立叶变换的一门课程。 无论是在数学上还是在应用范围内，主题的丰富性意味着我们将几乎不断地做出选择。 关于这个主题的书看起来不一样，和这份讲义也不太一样 - 甚至用于基本对象和操作的符号也因书而异。 我会试着带大家在合适的时机选择一个合适的方向作为切入点来带领大家了解这门学科，并且我也会说出其他切入点会是什么。</p><hr><p>第一个选择是从哪里开始，我的选择是对傅立叶级数的简要处理。傅立叶分析最初涉及通过傅立叶级数表示和分析周期性现象，然后通过傅立叶将这些见解扩展到非周期性现象。 转变。 实际上，从傅立叶级数到傅立叶变换的一种方法是将非周期性现象（因此几乎任何一般函数）视为周期性现象的极限情况，因为周期趋于无穷大。 周期性情况下的一组离散频率在非周期情况下成为频率的连续体，频谱诞生了，随之而来的是该主题最重要的原则：</p><p><strong>每个信号都有一个频谱，由频谱决定。 您可以在时域（或空间）或频域中分析信号。</strong></p><p>我认为这条格言有资格成为宇宙组成的主要秘密之一。</p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/10/29/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9102-%E5%B0%86%E4%B8%80%E8%88%AC%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%B8%BA%E7%AE%80%E5%8D%95%E5%91%A8%E6%9C%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【傅里叶变换及其应用】01-周期性，三角函数表示复杂函数</title>
      <link>http://studyai.site/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/</link>
      <guid>http://studyai.site/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Sat, 27 Oct 2018 09:03:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://open.163.com/movie/2008/2/C/G/M7Q4BLENR_M7QBP61CG.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;课程视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本质上，傅里叶级数可以看做是&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://open.163.com/movie/2008/2/C/G/M7Q4BLENR_M7QBP61CG.html" target="_blank" rel="external">课程视频地址</a></p><p>本质上，傅里叶级数可以看做是<strong>用数学的手段研究周期性现象</strong>的一门学科。</p><p>我们在初中高中学过cos和sin这些三角函数，我们是否可以使用这些三角函数来建模非常广泛的周期性现象呢？这正是这节课需要解决的问题。</p><h3 id="如何使用简单的sin-t-，cos-t-来建模复杂的周期性现象？"><a href="#如何使用简单的sin-t-，cos-t-来建模复杂的周期性现象？" class="headerlink" title="如何使用简单的sin(t)，cos(t)来建模复杂的周期性现象？"></a>如何使用简单的sin(t)，cos(t)来建模复杂的周期性现象？</h3><p>首先，我们这里说的<strong>复杂的周期性现象</strong>会普遍到什么程度呢？我们希望把这些方法应用在普遍的条件下，但是并不是所有的现象都是周期性的（其实甚至在一些周期性的现象中，这个假定也未必行得通）。所以，<strong>并不是所有的现象都试用这个方法</strong>。</p><p>其实现实生活中的现象，最终都会结束，我们只观察某一个特定时间段的现象。而数学函数，比如正余弦函数，都是无始无终的。那么如何用它们来描述那些会结束的现象呢？</p><p>在面对实际的现象时，比如下面这种现象：</p><p><img src="/img/18_10_27/001.png" width="500" hegiht="313" align="center"></p><p>只存在于一个有限的时间段内，画出一个这样的信号。这并不是一个周期现象，但如果我们重复绘制这个图像，就可以强制使其成为周期性的函数了。</p><p><img src="/img/18_10_27/002.png" alt=""></p><p>或许我们只是对其中的一部分感兴趣，但对于数学分析，如果使其具有周期性，就对所有的都适用了。这个过程叫做<strong>信号的周期化（periodization of a signal）</strong>。它可以用于研究非周期性信号。</p><h4 id="信号周期化"><a href="#信号周期化" class="headerlink" title="信号周期化"></a>信号周期化</h4><p>我们通常把周期函数的周期设定为1，这样更加方便。因此函数$f(t)$需要满足：</p><ul><li>对任何$t$均有$f(t+1)=f(t)$，</li></ul><p>因此我们的信号模型可以表示为：</p><p>$$sin(2πt) \tag{1-1} $$    </p><p>以及</p><p>$$cos(2πt) \tag{1-2}$$</p><p><strong><em>如果我们知道一个周期为1的周期性函数在任意一个单位为1的时间间隔内的形式，那么我们就可以知道整个函数了。</em></strong></p><h4 id="生成复杂的周期函数"><a href="#生成复杂的周期函数" class="headerlink" title="生成复杂的周期函数"></a>生成复杂的周期函数</h4><p>那么我们如何用简单的sin和cos函数来表示各种复杂的周期现象呢？</p><p>事实上，我们可以通过对$sin(2πt)$和$cos(2πt)$进行变换和相加的方式来得到相当普遍的周期为1的周期函数。</p><h5 id="对正余弦函数进行变换"><a href="#对正余弦函数进行变换" class="headerlink" title="对正余弦函数进行变换"></a>对正余弦函数进行变换</h5><p>下图是$sin(2πt)$的函数图像，其周期为1，频率为1：</p><p><img src="/img/18_10_27/003.png" width="500" hegiht="313" align="center"></p><p>经过变换之后，$sin(4πt)$的函数图像如下，其周期为$1/2$，频率为2：</p><p><img src="/img/18_10_27/004.png" width="500" hegiht="313" align="center"></p><blockquote><p>其实你也可以说他的周期是1。因为一秒之内它经历了两个完整的周期，你可以把这两个完整的周期看做一个周期，图形在整个坐标轴上一直在重复这个原始信号。</p></blockquote><p>再次变换之后，$sin(6πt)$的函数图像如下，其周期为$1/3$，频率为3：</p><p><img src="/img/18_10_27/005.png" width="500" hegiht="313" align="center"></p><blockquote><p>同样，也可以把它看做周期是1。</p></blockquote><h5 id="对正余弦函数进行合并"><a href="#对正余弦函数进行合并" class="headerlink" title="对正余弦函数进行合并"></a>对正余弦函数进行合并</h5><p>现在把上面的三个函数合并：</p><p>$$<br>y=sin(2πt) + sin(4πt) + sin(6πt)<br>$$</p><p>其效果如下：</p><p><img src="/img/18_10_27/006.png" width="300" hegiht="313" align="center"></p><p>组合之后的函数周期为1，它由3个不同频率的周期函数组成，频率分布为1，2，3。但把它们组合起来之后，却只有一个周期：周期为1。</p><p>我们不仅可以改变频率，也可以单独改变幅度，并且可以改变其中每一个的相位。</p><h4 id="表示一个复杂的周期函数的几种方式"><a href="#表示一个复杂的周期函数的几种方式" class="headerlink" title="表示一个复杂的周期函数的几种方式"></a>表示一个复杂的周期函数的几种方式</h4><h5 id="最基本的形式"><a href="#最基本的形式" class="headerlink" title="最基本的形式"></a>最基本的形式</h5><p>一个复杂的周期为1的信号，可以通过变换一系列的正余弦函数的<strong>频率</strong>、<strong>幅度</strong>和<strong>相位</strong>，然后将它们<strong>加起来</strong>，来得到。</p><p>$$<br>y=\sum_{k=1}^N A_ksin(2πkt+φ_k) \tag{1-3}<br>$$</p><p>这是表示一个复杂周期的<strong>最一般</strong>的形式。</p><h5 id="利用和角公式来表示"><a href="#利用和角公式来表示" class="headerlink" title="利用和角公式来表示"></a>利用和角公式来表示</h5><p>正余弦和角公式：</p><p>$$<br>sin(2πkt+φ_k)=sin(2πkt) + cosφ_k + cos(2πkt) + sinφ_k<br>\tag{1-4}<br>$$ </p><p>因此我们可以将上面的公式$(1-3)$展开成以下形式：</p><p>$$<br>\begin{align*}<br>y&amp;=\sum_{k=1}^N A_k(sin(2πkt) + cosφ_k + cos(2πkt) + sinφ_k)\\<br>&amp;=\sum_k^N  (a_kcos(2πkt)+b_ksin(2πkt))<br>\tag{1-5}<br>\end{align*}<br>$$</p><p>这里的$a_k$和$b_k$是由A计算出的。</p><h5 id="加一个常数项的形式（直流分量形式）"><a href="#加一个常数项的形式（直流分量形式）" class="headerlink" title="加一个常数项的形式（直流分量形式）"></a>加一个常数项的形式（直流分量形式）</h5><p>$$<br>y = \frac{a_0}{2} + \sum_{k=1}^N  (a_kcos(2πkt)+b_ksin(2πkt))<br>\tag{1-6}<br>$$</p><p>这里的$\frac{a_0}{2}$是一个常数项，电器工程师常称之为<strong>直流分量(dc component)</strong>。因为电器工程师在研究交流电或直流电的过程中，发现有一部分是不随着周期发生改变的，这一部分称之为<strong>直流分量</strong>。</p><h5 id="复指数的表示形式"><a href="#复指数的表示形式" class="headerlink" title="复指数的表示形式"></a>复指数的表示形式</h5><p>上面几种都是比较常用的一些用于表示一个复杂信号的表示形式。但是迄今为止，最方便使用的还是用<strong>复指数</strong>的形式来表示：</p><p>$$<br>e^{2πkt}=cos(2πkt) + i*sin(2πkt)<br>\tag{1-7}<br>$$</p><p>在这里$i$的值为：</p><p>$$<br>i=\sqrt{-1}<br>\tag{1-8}<br>$$</p><p>根据著名的<strong>欧拉公式</strong>，我们可以用复指数的形式来表示正余弦函数，其中$cos$是实部，$sin$是虚部：</p><p>$$<br>cos(2πkt)=\frac{e^{2πikt}+e^{-2πikt}}{2}<br>\\<br>sin(2πkt)=\frac{e^{2πikt}-e^{-2πikt}}{2i}<br>\tag{1-9}<br>$$</p><p>你也可以将上面公式$(1-5)$的三角函数表示的和式的形式写成这种形式：</p><p>$$<br>\sum_{k=-n}^n C_ke^{2πikt}<br>\tag{1-10}<br>$$</p><p>在这里$C_k$是复数。</p><blockquote><p><strong>共轭</strong></p><p>对于复数$a + bi$来说，其共轭为$a - bi$。<br>复数$C_k$的共轭表示为$\bar{C_k}$</p><p>另外，如果一个复数等于其自身的共轭意味着什么呢？$C_0=\bar{C_0}$</p><p>这意味着这个数本身是实数。</p></blockquote><p>如果你试着把余弦表示的方式全部转成了复指数的形式，你会发现$C_k$不仅仅是复数，它同时还满足<strong>对称性</strong>。并且由于它的对称性，所以$\sum_{k=-n}^n C_k $的总和为实数。</p><p>即：$ C_{-k} $等于$C_k$的共轭：</p><p>$$<br>C_-k=\bar{C_k}<br>\tag{1-11}<br>$$</p><p>这是一条重要的性质。</p><p>反过来，如果和式的系数满足对称性，那么总和就应该是实数。这是因为可以把所有项分成正项和负项两组，并且由于$(1-11)$的对称关系，复数和复数的共轭的和结果是实数，可以得出这个结论。</p><h4 id="我们生成的复杂的周期函数，其普遍性有多强？"><a href="#我们生成的复杂的周期函数，其普遍性有多强？" class="headerlink" title="我们生成的复杂的周期函数，其普遍性有多强？"></a>我们生成的复杂的周期函数，其普遍性有多强？</h4><p>$f(t)$是周期为1的周期函数，我们可以把$f(t)$写成$(1-10)$那种形式吗？</p><p>$$<br>f(t)=\sum_{k=-n}^n C_ke^{2πikt}<br>\tag{1-12}<br>$$</p><p>换句话说，一个周期为1的复杂的周期函数，我们能用正余弦函数通过叠加变化以及组合来生成出来吗？</p><h5 id="假设我们能做到"><a href="#假设我们能做到" class="headerlink" title="假设我们能做到"></a>假设我们能做到</h5><p>假设我们可以做到用$(1-12)$来表示所有复杂的周期为1的周期函数，那么对于未知系数$C_k$我们如何求得呢？</p><p>以下是求$C_k$的过程：</p><p>$$<br>\begin{align*}<br>f(t)&amp;=\sum_{k=-n}^n C_ke^{2πikt}\\<br>&amp;=…+C_km^{2πikt}+…<br>\end{align*}<br>$$</p><p><img src="/img/18_10_27/007.png" alt=""></p><p>两边同时乘以$e^{-2\pi imt}$：</p><p><img src="/img/18_10_27/008.png" alt=""></p><p><img src="/img/18_10_27/009.png" alt=""></p><p>然后对两边同时求积分，积分区间是0到1，因为我们的频率是1：</p><p><img src="/img/18_10_27/010.png" alt=""></p><p>由于：</p><p><img src="/img/18_10_27/011.png" alt=""></p><p>所以：</p><p><img src="/img/18_10_27/012.png" alt=""></p><p><img src="/img/18_10_27/013.png" alt=""></p><p>其中：</p><p><img src="/img/18_10_27/014.png" alt=""></p><p><img src="/img/18_10_27/015.png" alt=""></p><p><img src="/img/18_10_27/016.png" alt=""></p><p><img src="/img/18_10_27/017.png" alt=""></p><p>这里的:</p><p><img src="/img/18_10_27/018.png" alt=""></p><p>是一个整数，就像$sin(2π)$乘以一个整数，这个整数是1，所以这里的结果是0。</p><p><img src="/img/18_10_27/019.png" alt=""></p><p>所以我们的$C_m$可以得到下面的结果：</p><p><img src="/img/18_10_27/020.png" alt=""></p><p>期初我们设定$f(t)$是已知的，所以我们就可以求得$C_m$了。</p><hr><p><strong>结论:</strong>给定周期为1的周期函数$f(t)$，如果能把$f(t)$写成和式的形式：$f(t)=\sum_{k=-n}^nC_ke^{2\pi ikt}$，那么溪水会按照这个公式给出，其中$C_k=\int_0^{1}e^{-2\pi ikt}f(t)dt$。</p><p>下节课我们将介绍，我们得到的这些参数，将带来什么意义。</p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NumPy入门教程</title>
      <link>http://studyai.site/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</link>
      <guid>http://studyai.site/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Fri, 11 May 2018 03:43:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;快速入门教程&quot;&gt;&lt;a href=&quot;#快速入门教程&quot; class=&quot;headerlink&quot; title=&quot;快速入门教程&quot;&gt;&lt;/a&gt;快速入门教程&lt;/h2&gt;&lt;h3 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="快速入门教程"><a href="#快速入门教程" class="headerlink" title="快速入门教程"></a>快速入门教程</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开始本教程之前，你需要有一定的Python基础。如果你想要回顾一下Python相关的知识点，你可以看一下<a href="http://docs.python.org/tut/" target="_blank" rel="external">这份教程</a>。</p><p>如果你希望运行本教程中的示例，那么需要在您机器上安装一些软件。有关说明，请参阅<a href="http://scipy.org/install.html" target="_blank" rel="external">http://scipy.org/install.html</a>。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>NumPy的主要对象是齐次多维数组。它是一个元素的表（元素通常是数字），所有的元素拥有相同的类型，可以被一个正整数元组来索引。在NumPy中维度称之为<strong><em>axis（轴）</em></strong>。</p><p>例如，在3D空间中的一个坐标点<code>[1, 2, 1]</code>拥有一个axis。这个axis拥有3个元素，所以我们说它的长度是3。在下面的例子中，有2个axis。第一个axis的长度是2，第二个axis的长度是3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[ <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</div><div class="line">[ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>]]</div></pre></td></tr></table></figure><pre><code>[[1.0, 0.0, 0.0], [0.0, 1.0, 2.0]]</code></pre><p>NumPy的数组class称之为<code>ndarray</code>。它还有另外一个别名：<code>array</code>。注意<code>numpy.array</code>与标准Python库中的<code>array.array</code>不一样，标准库中的<code>array</code>只可以操作以为数组，并且只能提供少量的方法。<code>ndarray</code>更重要的一些属性如下：</p><p><strong>ndarray.ndim</strong></p><pre><code>数组的axis(维度)数量</code></pre><p><strong>ndarray.shape</strong></p><pre><code>数组的维度。这是一个整数类型的元组，指示了数组在每个维度下的尺寸信息。对于一个n行m列的矩阵来说，它的`shape`是`(n,m)`。因此`shape`元组的长度，也是axis的数量，即`ndim`。</code></pre><p><strong>ndarray.size</strong></p><pre><code>数组的元素总数。值等于`shape`中的元素的乘积。</code></pre><p><strong>ndarray.dtype</strong></p><pre><code>一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外，也可以使用NumPy自己提供的一些类型。例如`numpy.int32`,`numpy.int16`和`numpy.float64`。</code></pre><p><strong>ndarray.itemsize</strong></p><pre><code>数组中每个元素占用的bytes大小。例如，一个数组的元素类型为`float64`，它的`itemsize`就是8(=64/8)，另一个数组的元素类型为`complex32`的`itemsize`值为4(=32/8)。这个值相当于`ndarray.dtype.itemsize`。</code></pre><p><strong>ndarray.data</strong></p><pre><code>该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引来访问数组中的元素。</code></pre><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 5)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.ndim</div></pre></td></tr></table></figure><pre><code>2</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.dtype.name</div></pre></td></tr></table></figure><pre><code>&apos;int64&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.itemsize</div></pre></td></tr></table></figure><pre><code>8</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.size</div></pre></td></tr></table></figure><pre><code>15</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type(a)</div></pre></td></tr></table></figure><pre><code>numpy.ndarray</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([6, 7, 8])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type(b)</div></pre></td></tr></table></figure><pre><code>numpy.ndarray</code></pre><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><p>有几种可以创建数组的方式。</p><p>例如，你可以通过使用<code>array</code>方法，从一个标准的Python列表或元组来创建一个numpy数组。数组的类型由序列中元素的类型自动推导得出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([2, 3, 4])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.dtype</div></pre></td></tr></table></figure><pre><code>dtype(&apos;int64&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.array([<span class="number">1.2</span>, <span class="number">3.5</span>, <span class="number">5.1</span>])</div><div class="line">b.dtype</div></pre></td></tr></table></figure><pre><code>dtype(&apos;float64&apos;)</code></pre><p>在调用<code>array</code>方法来创建数组时，有一种常见的错误，就是在方法中传入了多个数字，而不是通过传入一个包含一组数字的list作为参数。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   # WRONG</div><div class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) # RIGHT</div></pre></td></tr></table></figure><p><code>array</code>函数将序列的序列转换为二维数组，将序列的序列的序列转换成3维数组，等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.array([(<span class="number">1.5</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)])</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 1.5,  2. ,  3. ],       [ 4. ,  5. ,  6. ]])</code></pre><p>数组的类型也可以在创建的时候，显式的指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=complex)</div><div class="line">c</div></pre></td></tr></table></figure><pre><code>array([[ 1.+0.j,  2.+0.j],       [ 3.+0.j,  4.+0.j]])</code></pre><p>通常，数组的元素在初始状态下是未知的，但尺寸已知。因此，NumPy提供了一些方法来创建以初始化占位符填充的数组。这最大限度地减少了增加数组的开销，这是一项昂贵的操作。</p><p>方法<code>zeros</code>创建一个全部由0填充的数组，方法<code>ones</code>创建一个全部由1填充的数组，方法<code>empty</code>创建了一个全部由随机的数字填充的数组，随机数的值取决于内存当前的状态。默认情况下，创建出来的数组类型为<code>folat64</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.zeros((<span class="number">3</span>,<span class="number">4</span>))</div></pre></td></tr></table></figure><pre><code>array([[ 0.,  0.,  0.,  0.],       [ 0.,  0.,  0.,  0.],       [ 0.,  0.,  0.,  0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), dtype=np.int16) <span class="comment"># dtype可以被指定</span></div></pre></td></tr></table></figure><pre><code>array([[[1, 1, 1, 1],        [1, 1, 1, 1],        [1, 1, 1, 1]],       [[1, 1, 1, 1],        [1, 1, 1, 1],        [1, 1, 1, 1]]], dtype=int16)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 未初始化，输出可能不同</span></div></pre></td></tr></table></figure><pre><code>array([[ 0.,  0.,  0.],       [ 0.,  0.,  0.]])</code></pre><p>为了创建数字序列，NumPy提供了一个类似于<code>range</code>的返回数组而不是列表的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.arange(<span class="number">10</span>, <span class="number">30</span>, <span class="number">5</span>)</div></pre></td></tr></table></figure><pre><code>array([10, 15, 20, 25])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.arange(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0.3</span>) <span class="comment"># 可以接受float类型的参数</span></div></pre></td></tr></table></figure><pre><code>array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])</code></pre><p>当<code>arange</code>与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数<code>linspace</code>来接收我们想要的元素数量作为参数，而不是步长：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> pi</div><div class="line">np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>)  <span class="comment"># 创建9个数字，均匀分布在0到2之间</span></div></pre></td></tr></table></figure><pre><code>array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = np.linspace( <span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">100</span>)</div><div class="line">f = np.sin(x)</div></pre></td></tr></table></figure><h4 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h4><p>当你打印一个数组时，NumPy以一种类似嵌套列表的形式来展示，同时具有以下布局：</p><ul><li>最后一个axis从左向右打印</li><li>倒数第二个axis从上到下打印</li><li>其余的也是从上到下打印的，每个切片与下一个由空行分开。</li></ul><p>然后将一维数组打印为行，将二维数组作为矩阵，将三维数组作为矩阵列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># 一维数组</span></div><div class="line">print(a)</div></pre></td></tr></table></figure><pre><code>[0 1 2 3 4 5]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>)  <span class="comment"># 二维数组</span></div><div class="line">print(b)</div></pre></td></tr></table></figure><pre><code>[[ 0  1  2] [ 3  4  5] [ 6  7  8] [ 9 10 11]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 三维数组</span></div><div class="line">print(c)</div></pre></td></tr></table></figure><pre><code>[[[ 0  1  2  3]  [ 4  5  6  7]  [ 8  9 10 11]] [[12 13 14 15]  [16 17 18 19]  [20 21 22 23]]]</code></pre><p>如果数组太大而无法打印，NumPy将自动跳过数组的中心部分并仅打印角点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(np.arange(<span class="number">10000</span>))</div></pre></td></tr></table></figure><pre><code>[   0    1    2 ..., 9997 9998 9999]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>,<span class="number">100</span>))</div></pre></td></tr></table></figure><pre><code>[[   0    1    2 ...,   97   98   99] [ 100  101  102 ...,  197  198  199] [ 200  201  202 ...,  297  298  299] ...,  [9700 9701 9702 ..., 9797 9798 9799] [9800 9801 9802 ..., 9897 9898 9899] [9900 9901 9902 ..., 9997 9998 9999]]</code></pre><p>要禁用此行为并强制NumPy打印整个数组，可以使用<code>set_printoptions</code>更改打印选项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.set_printoptions(threshold=np.nan)</div></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>数组上的算术运算符应用于元素。一个新的数组被创建并填充结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = np.array([<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.arange(<span class="number">4</span>)</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = a-b</div><div class="line">c</div></pre></td></tr></table></figure><pre><code>array([20, 29, 38, 47])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b**<span class="number">2</span></div></pre></td></tr></table></figure><pre><code>array([0, 1, 4, 9])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>*np.sin(a)</div></pre></td></tr></table></figure><pre><code>array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a&lt;<span class="number">35</span></div></pre></td></tr></table></figure><pre><code>array([ True,  True, False, False], dtype=bool)</code></pre><p>不像其他的矩阵语言那样，<code>*</code>操作符在NumPy中是元素间的乘法。矩阵乘法可以使用<code>dot</code>方法来实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</div><div class="line">B = np.array([[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>]])</div><div class="line">A*B    <span class="comment"># 元素间的乘积</span></div></pre></td></tr></table></figure><pre><code>array([[2, 0],       [0, 4]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A.dot(B)   <span class="comment"># 矩阵乘法</span></div></pre></td></tr></table></figure><pre><code>array([[5, 4],       [3, 4]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.dot(A, B) <span class="comment"># 矩阵乘法的另一种实现</span></div></pre></td></tr></table></figure><pre><code>array([[5, 4],       [3, 4]])</code></pre><p>一些例如<code>+=</code>和<code>-=</code>的操作符，实现的方式是通过修改现有的矩阵而不是创建新的矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>), dtype=int)</div><div class="line">b = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</div><div class="line">a *= <span class="number">3</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[3, 3, 3],       [3, 3, 3]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b += a</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 3.05432455,  3.59941571,  3.65058751],       [ 3.85091779,  3.45890823,  3.55943444]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a += b <span class="comment"># b 不会自动的转型成为 integer 类型</span></div></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-87-3054fce39e6f&gt; in &lt;module&gt;()----&gt; 1 a += bTypeError: Cannot cast ufunc add output from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) with casting rule &apos;same_kind&apos;</code></pre><p>在使用不同类型的数组时，结果数组的类型对应于更一般或精确的数组（称为向上转型）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.ones(<span class="number">3</span>, dtype=np.int32)</div><div class="line">b = np.linspace(<span class="number">0</span>, pi, <span class="number">3</span>)</div><div class="line">b.dtype.name</div></pre></td></tr></table></figure><pre><code>&apos;float64&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = a+b</div><div class="line">c</div></pre></td></tr></table></figure><pre><code>array([ 1.        ,  2.57079633,  4.14159265])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.dtype.name</div></pre></td></tr></table></figure><pre><code>&apos;float64&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = np.exp(c*<span class="number">1j</span>)</div><div class="line">d</div></pre></td></tr></table></figure><pre><code>array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,       -0.54030231-0.84147098j])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d.dtype.name</div></pre></td></tr></table></figure><pre><code>&apos;complex128&apos;</code></pre><p>许多一元运算，例如计算数组中所有元素的总和，都是作为<code>ndarray</code>类的方法来实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 0.48681264,  0.52685408,  0.53980305],       [ 0.27958753,  0.55125855,  0.70834892]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.sum()</div></pre></td></tr></table></figure><pre><code>3.0926647737313067</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.min()</div></pre></td></tr></table></figure><pre><code>0.27958753466020847</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.max()</div></pre></td></tr></table></figure><pre><code>0.70834891569018965</code></pre><p>默认情况下，这些操作适用于数组，就好像它是数字列表一样，无论其形状如何。但是，通过指定<code>axis</code>参数，可以沿着数组的指定轴(axis)应用操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b.sum(axis=<span class="number">0</span>)    <span class="comment"># 每一列的和</span></div></pre></td></tr></table></figure><pre><code>array([12, 15, 18, 21])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b.min(axis=<span class="number">1</span>)    <span class="comment"># 每一行的最小值</span></div></pre></td></tr></table></figure><pre><code>array([0, 4, 8])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b.cumsum(axis=<span class="number">1</span>)   <span class="comment"># 每行的累加值</span></div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  3,  6],       [ 4,  9, 15, 22],       [ 8, 17, 27, 38]])</code></pre><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><p>NumPy提供了一些常见的数学运算方法，例如sin，cos和exp。在NumPy中，这些方法被称作”通用方法”(<code>ufunc</code>)。在NumPy中，这些方法操作在数组中的每个元素上，产生一个数组作为输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">B = np.arange(<span class="number">3</span>)</div><div class="line">B</div></pre></td></tr></table></figure><pre><code>array([0, 1, 2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.exp(B)</div></pre></td></tr></table></figure><pre><code>array([ 1.        ,  2.71828183,  7.3890561 ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.sqrt(B)</div></pre></td></tr></table></figure><pre><code>array([ 0.        ,  1.        ,  1.41421356])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C = np.array([<span class="number">2.</span>, <span class="number">-1.</span>, <span class="number">4.</span>])</div><div class="line">np.add(B, C)</div></pre></td></tr></table></figure><pre><code>array([ 2.,  0.,  6.])</code></pre><h4 id="索引，切片和迭代"><a href="#索引，切片和迭代" class="headerlink" title="索引，切片和迭代"></a>索引，切片和迭代</h4><p><strong>一维</strong>数组可以像Python中的list或其他序列一样进行索引、切片和迭代操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">10</span>)**<span class="number">3</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[<span class="number">2</span>]</div></pre></td></tr></table></figure><pre><code>8</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[<span class="number">2</span>:<span class="number">5</span>]</div></pre></td></tr></table></figure><pre><code>array([ 8, 27, 64])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[:<span class="number">6</span>:<span class="number">2</span>] = <span class="number">-1000</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[::<span class="number">-1</span>]</div></pre></td></tr></table></figure><pre><code>array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</div><div class="line">    print(i**(<span class="number">1</span>/<span class="number">3.</span>))</div></pre></td></tr></table></figure><pre><code>nan1.0nan3.0nan5.06.07.08.09.0/usr/local/Homebrew/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in power</code></pre><p><strong>多维</strong>数组每个轴（axis）都有一个索引。这些索引以逗号分隔的元组给出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">10</span>*x + y</div><div class="line"></div><div class="line">b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype=int)</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2,  3],       [10, 11, 12, 13],       [20, 21, 22, 23],       [30, 31, 32, 33],       [40, 41, 42, 43]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[<span class="number">2</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure><pre><code>23</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[<span class="number">0</span>:<span class="number">5</span>, <span class="number">1</span>] <span class="comment"># 输出第2列的每一行的元素</span></div></pre></td></tr></table></figure><pre><code>array([ 1, 11, 21, 31, 41])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[:, <span class="number">1</span>] <span class="comment"># 与上一步操作等价</span></div></pre></td></tr></table></figure><pre><code>array([ 1, 11, 21, 31, 41])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[<span class="number">1</span>:<span class="number">3</span>, :] <span class="comment"># 输出第2和第3行的每个列元素</span></div></pre></td></tr></table></figure><pre><code>array([[10, 11, 12, 13],       [20, 21, 22, 23]])</code></pre><p>当提供的索引数量少于axis的数量时，缺失的索引被视为完整的切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[<span class="number">-1</span>] <span class="comment"># 输出最后一行。相当于 b[-1,:]</span></div></pre></td></tr></table></figure><pre><code>array([40, 41, 42, 43])</code></pre><p>表达式<code>b[i]</code>的这种表示形式，意味着在<code>i</code>后面还有多个<code>:</code>，<code>:</code>的数量取决于剩余的axis数量。NumPy也允许你使用<code>...</code>来表示这一形式：<code>b[i,...]</code>。</p><p><strong>点</strong>(<code>...</code>)表示产生完整索引元组所需要的冒号。例如，如果<code>x</code>是一个5轴数组，那么：</p><ul><li><code>x[1,2,...]</code>等价于<code>x[1,2,:,:,:]</code>，</li><li><code>x[...,3]</code>等价于<code>x[:,:,:,:,3]</code>，</li><li><code>x[4,...,5,:]</code>等价于<code>x[4,:,:,5,:]</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一个3D数组（由两个2D数组粘贴而成）</span></div><div class="line">c = np.array([[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</div><div class="line">              [<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]],</div><div class="line">              [[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],</div><div class="line">              [<span class="number">110</span>,<span class="number">112</span>,<span class="number">113</span>]]</div><div class="line">             ])</div><div class="line">c.shape</div></pre></td></tr></table></figure><pre><code>(2, 2, 3)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c[<span class="number">1</span>,...]  <span class="comment"># 相当于 c[1,:,:] 或 c[1]</span></div></pre></td></tr></table></figure><pre><code>array([[100, 101, 102],       [110, 112, 113]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c[...,<span class="number">2</span>]  <span class="comment"># 相当于 c[:,:,2]</span></div></pre></td></tr></table></figure><pre><code>array([[  2,  13],       [102, 113]])</code></pre><p><strong>迭代</strong>多维数组是相对于第一个axis完成的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> b:</div><div class="line">    print(row)</div></pre></td></tr></table></figure><pre><code>[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43]</code></pre><p>但是，如果想要对数组中的每个元素执行操作，可以使用<code>flat</code>属性，该属性是数组中所有元素的迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</div><div class="line">    print(element)</div></pre></td></tr></table></figure><pre><code>012310111213202122233031323340414243</code></pre><h3 id="Shape操作"><a href="#Shape操作" class="headerlink" title="Shape操作"></a>Shape操作</h3><h4 id="改变一个array的shape"><a href="#改变一个array的shape" class="headerlink" title="改变一个array的shape"></a>改变一个array的shape</h4><p>一个数组的形状由这个数组每个轴上的元素数量给出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.,  6.,  4.],       [ 7.,  5.,  7.,  7.],       [ 3.,  1.,  8.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 4)</code></pre><p>数组的形状可以通过各种命令进行更改。请注意，以下三个命令都返回一个修改后的数组，但都没有改变原数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.ravel()  <span class="comment"># 返回展开的数组</span></div></pre></td></tr></table></figure><pre><code>array([ 8.,  3.,  6.,  4.,  7.,  5.,  7.,  7.,  3.,  1.,  8.,  8.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.reshape(<span class="number">6</span>,<span class="number">2</span>)  <span class="comment"># 返回一个改变了shape的数组</span></div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.],       [ 6.,  4.],       [ 7.,  5.],       [ 7.,  7.],       [ 3.,  1.],       [ 8.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.T  <span class="comment"># 返回数组的转置</span></div></pre></td></tr></table></figure><pre><code>array([[ 8.,  7.,  3.],       [ 3.,  5.,  1.],       [ 6.,  7.,  8.],       [ 4.,  7.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.T.shape</div></pre></td></tr></table></figure><pre><code>(4, 3)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 4)</code></pre><p>由ravel()产生的数组元素的顺序通常是”C-style”的，即最右边的索引“变化最快”，因此[0,0]之后的元素是[0,1]。如果一个数组变形为其他形状，数组再次被视为”C-style”。NumPy通常创建按次顺序存储的数组，因此<code>ravel()</code>通常不需要复制数组，但如果数组是通过对另一个数组进行切片操作，或者使用不寻常的方式创建的，则可能需要复制它。函数<code>ravel()</code>和<code>reshape()</code>也可以通过使用可选参数来使用FORTRAN-style的数组，其中最左侧的索引更改速度最快。</p><p><code>reshape</code>方法返回的结果是一个变形后的数组，而<code>ndarray.resize</code>方法会更改数组本身的形状：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.,  6.,  4.],       [ 7.,  5.,  7.,  7.],       [ 3.,  1.,  8.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a.resize((<span class="number">2</span>,<span class="number">6</span>))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.,  6.,  4.,  7.,  5.],       [ 7.,  7.,  3.,  1.,  8.,  8.]])</code></pre><p>如果在reshape操作中将尺寸参数传入-1，则会自动计算这一位置的尺寸：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.reshape(<span class="number">3</span>,<span class="number">-1</span>)</div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.,  6.,  4.],       [ 7.,  5.,  7.,  7.],       [ 3.,  1.,  8.,  8.]])</code></pre><h4 id="将不同的数组粘贴起来"><a href="#将不同的数组粘贴起来" class="headerlink" title="将不同的数组粘贴起来"></a>将不同的数组粘贴起来</h4><p>多个数组可以按照不同的axis来粘贴起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 9.,  9.],       [ 8.,  6.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 5.,  3.],       [ 0.,  4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.vstack((a,b))</div></pre></td></tr></table></figure><pre><code>array([[ 9.,  9.],       [ 8.,  6.],       [ 5.,  3.],       [ 0.,  4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hstack((a,b))</div></pre></td></tr></table></figure><pre><code>array([[ 9.,  9.,  5.,  3.],       [ 8.,  6.,  0.,  4.]])</code></pre><p>函数<code>column_stack</code>将1D数组作为列堆叠到2D数组中。它相当于仅用于2D数组的<code>hstack</code>操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> newaxis</div><div class="line">np.column_stack((a,b))   <span class="comment"># 仅作用于2D数组</span></div></pre></td></tr></table></figure><pre><code>array([[ 9.,  9.,  5.,  3.],       [ 8.,  6.,  0.,  4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.array([<span class="number">4.</span>, <span class="number">2.</span>])</div><div class="line">b = np.array([<span class="number">3.</span>, <span class="number">8.</span>])</div><div class="line">np.column_stack((a,b))  <span class="comment"># 返回一个2D数组</span></div></pre></td></tr></table></figure><pre><code>array([[ 4.,  3.],       [ 2.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hstack((a,b))  <span class="comment"># 得到不同的结果</span></div></pre></td></tr></table></figure><pre><code>array([ 4.,  2.,  3.,  8.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[:,newaxis]  <span class="comment"># 这将得到一个2D列向量</span></div></pre></td></tr></table></figure><pre><code>array([[ 4.],       [ 2.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.column_stack((a[:,newaxis],b[:,newaxis]))</div></pre></td></tr></table></figure><pre><code>array([[ 4.,  3.],       [ 2.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hstack((a[:,newaxis],b[:,newaxis]))  <span class="comment"># 结果是一样的</span></div></pre></td></tr></table></figure><pre><code>array([[ 4.,  3.],       [ 2.,  8.]])</code></pre><p>另一方面，函数<code>row_stack</code>相当于对任何数组进行<code>vstack</code>操作。一般情况下，对于具有两个以上维度的数组，<code>hstack</code>操作沿着它的第二个axis进行堆叠，<code>vstack</code>沿着它的第一个axis堆叠，<code>concatenate</code>沿着指定axis的方向进度堆叠。</p><p><strong>注意</strong></p><p>在复杂的情况下，<code>r_</code>和<code>c_</code>可用于通过沿着一个轴堆积数字来创建数组。他们允许使用表示范围的<code>:</code>操作符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>]</div></pre></td></tr></table></figure><pre><code>array([1, 2, 3, 0, 4])</code></pre><p>当使用数组作为参数时，<code>r_</code>和<code>c_</code>与默认行为的<code>vstack</code>和<code>hstack</code>类似，可以通过可选参数指定所要连接的轴的序号。</p><h4 id="将一个数组拆分成几个较小的数组"><a href="#将一个数组拆分成几个较小的数组" class="headerlink" title="将一个数组拆分成几个较小的数组"></a>将一个数组拆分成几个较小的数组</h4><p>使用<code>hsplit</code>，可以沿着水平轴来切割数组，或者通过指定返回的数组的形状来切割数组，或者通过指定需要分割的列来分割数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">12</span>)))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 4.,  3.,  3.,  1.,  2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],       [ 5.,  1.,  1.,  2.,  9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hsplit(a,<span class="number">3</span>)  <span class="comment"># 将a切分成3份</span></div></pre></td></tr></table></figure><pre><code>[array([[ 4.,  3.,  3.,  1.],        [ 5.,  1.,  1.,  2.]]), array([[ 2.,  5.,  2.,  5.],        [ 9.,  6.,  5.,  5.]]), array([[ 5.,  8.,  2.,  2.],        [ 0.,  8.,  8.,  7.]])]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hsplit(a,(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 沿着第3和第4列来切分数组</span></div></pre></td></tr></table></figure><pre><code>[array([[ 4.,  3.,  3.],        [ 5.,  1.,  1.]]), array([[ 1.],        [ 2.]]), array([[ 2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],        [ 9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])]</code></pre><p><code>vspilt</code>沿着垂直轴进行分割，<code>array_split</code>允许指定沿着那个轴来进行分割。</p><h3 id="副本和视图"><a href="#副本和视图" class="headerlink" title="副本和视图"></a>副本和视图</h3><p>当操作一个数组时，它们的数据有时会被复制到一个新的数组中，有时则不会。这通常会让新手感到困惑。下面是3个例子：</p><h4 id="完全没有复制"><a href="#完全没有复制" class="headerlink" title="完全没有复制"></a>完全没有复制</h4><p>简单的赋值不会复制数组对象或数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>)</div><div class="line">b = a    <span class="comment"># 没有新的对象被创建</span></div><div class="line">b <span class="keyword">is</span> a   <span class="comment"># a 和 b 是同一个ndarray对象的两个名字</span></div></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b.shape = <span class="number">3</span>,<span class="number">4</span>  <span class="comment"># 改变a的shape</span></div><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 4)</code></pre><p>Python将可变对象作为引用传递，所以函数调用不会执行复制操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    print(id(x))</div><div class="line">    </div><div class="line">id(a)      <span class="comment"># id 是一个对象的唯一标识</span></div></pre></td></tr></table></figure><pre><code>4449897488</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(a)</div></pre></td></tr></table></figure><pre><code>4449897488</code></pre><h4 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h4><p>不同的数组对象可以共享相同的数据。<code>view</code>函数创建一个新的数组对象，但它和原数组持有相同的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = a.view()</div><div class="line">c <span class="keyword">is</span> a</div></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.base <span class="keyword">is</span> a  <span class="comment"># c 是 一个a数据所创建出来的视图</span></div></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.flags.owndata</div></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c.shape = <span class="number">2</span>,<span class="number">6</span>  <span class="comment"># a的shape并不发生改变</span></div><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 4)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span>  <span class="comment"># a的数据发生改变</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[   0,    1,    2,    3],       [1234,    5,    6,    7],       [   8,    9,   10,   11]])</code></pre><p>对一个数组进行切片操作，返回它的一个视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = a[ : , <span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 也可以被写作 s = a[:,1:3]</span></div><div class="line">s[:] = <span class="number">10</span>  <span class="comment"># s[:] 是一个s的视图。注意这里 s = 10 和 s[:] = 10 的区别</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[   0,   10,   10,    3],       [1234,   10,   10,    7],       [   8,   10,   10,   11]])</code></pre><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><code>copy</code>方法可以构造数组以及数据的完整副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = a.copy()    <span class="comment"># 一个由新数据构成的新的数组对象被创建了</span></div><div class="line">d <span class="keyword">is</span> a</div></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d.base <span class="keyword">is</span> a     <span class="comment"># d 与 a 不共享任何东西</span></div></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">9999</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[   0,   10,   10,    3],       [1234,   10,   10,    7],       [   8,   10,   10,   11]])</code></pre><h4 id="方法预览"><a href="#方法预览" class="headerlink" title="方法预览"></a>方法预览</h4><p>这里有一个NumPy中各种类型的比较有用的方法列表。</p><ul><li><p><strong>数组创建</strong></p><p><code>arange</code>,<code>array</code>,<code>copy</code>,<code>empty</code>,<code>empty_like</code>,<code>eye</code>,<code>fromfile</code>,<code>fromfunction</code>,<code>identity</code>,<code>linspace</code>,<code>logspace</code>,<code>mgrid</code>,<code>ogrid</code>,<code>ones</code>,<code>ones_like</code>,<code>zeros</code>,<code>zeros_like</code></p></li><li><p><strong>转换</strong></p><p>  <code>ndarray.astype</code>,<code>atleast_1d</code>,<code>atleast_2d</code>,<code>atleast_3d</code>,<code>mat</code></p></li><li><p><strong>手法</strong></p><p>  <code>array_split</code>, <code>column_stack</code>, <code>concatenate</code>, <code>diagonal</code>, <code>dsplit, dstack</code>, <code>hsplit</code>, <code>hstack</code>, <code>ndarray.item</code>, <code>newaxis</code>, <code>ravel</code>, <code>repeat</code>, <code>reshape</code>, <code>resize</code>, <code>squeeze</code>, <code>swapaxes</code>, <code>take</code>, <code>transpose</code>, <code>vsplit</code>, <code>vstack</code></p></li><li><p><strong>问题</strong></p><p>  <code>all</code>, <code>any</code>, <code>nonzero</code>, <code>where</code></p></li><li><p><strong>排序</strong></p><p>  <code>argmax</code>, <code>argmin</code>, <code>argsort</code>, <code>max</code>, <code>min</code>, <code>ptp</code>, <code>searchsorted</code>, <code>sort</code></p></li><li><p><strong>操作</strong></p><p>  <code>choose</code>, <code>compress</code>, <code>cumprod</code>, <code>cumsum</code>, <code>inner</code>, <code>ndarray.fill</code>, <code>imag</code>, <code>prod</code>, <code>put</code>, <code>putmask</code>, <code>real</code>, <code>sum</code></p></li><li><p><strong>基本统计</strong></p><p>  <code>cov</code>,<code>mean</code>,<code>std</code>,<code>var</code></p></li><li><p><strong>基本线性代数</strong></p><p>  <code>cross</code>,<code>dot</code>,<code>outer</code>,<code>linalg.svd</code>,<code>vdot</code></p></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><p>广播允许通用方法以有意义的方式处理形状不完全相同的输入。</p><p>广播第一法则是，如果所有的输入数组维度不都相同，一个“1”将被重复地添加在维度较小的数组上直至所有的数组拥有一样的维度。</p><p>广播第二法则确定长度为1的数组沿着特殊的方向表现地好像它有沿着那个方向最大形状的大小。对数组来说，沿着那个维度的数组元素的值理应相同。</p><p>应用广播法则之后，所有数组的大小必须匹配。更多细节可以从这个<a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="external">文档</a>找到。</p><h3 id="花哨的索引和索引技巧"><a href="#花哨的索引和索引技巧" class="headerlink" title="花哨的索引和索引技巧"></a>花哨的索引和索引技巧</h3><p>NumPy提供比常规Python序列更多的索引功能。正如我们前面看到的，除了通过整数和切片进行索引之外，还可以使用整数和布尔数组数组对索引进行索引。</p><h4 id="通过数组索引"><a href="#通过数组索引" class="headerlink" title="通过数组索引"></a>通过数组索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>)**<span class="number">2</span>          <span class="comment"># 前12个方格</span></div><div class="line">i = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>])     <span class="comment"># 一个索引数组</span></div><div class="line">a[i]                          <span class="comment"># 一个在位置i的元素</span></div></pre></td></tr></table></figure><pre><code>array([ 1,  1,  9, 64, 25])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">j = np.array([[ <span class="number">3</span>, <span class="number">4</span>], [ <span class="number">9</span>, <span class="number">7</span>]])  <span class="comment"># 一个二维索引数组</span></div><div class="line">a[j]                              <span class="comment"># 与j的shape相同</span></div></pre></td></tr></table></figure><pre><code>array([[ 9, 16],       [81, 49]])</code></pre><p>当被索引数组<code>a</code>是多维的时，每一个唯一的索引数列指向<code>a</code>的第一维。以下示例通过将图片标签用调色版转换成色彩图像展示了这种行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">palette = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],           <span class="comment"># 黑</span></div><div class="line">                    [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],         <span class="comment"># 红</span></div><div class="line">                    [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],         <span class="comment"># 绿</span></div><div class="line">                    [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],         <span class="comment"># 蓝</span></div><div class="line">                    [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]      <span class="comment"># 白</span></div><div class="line">                   ])</div><div class="line">image = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],           <span class="comment"># 每个值对应调色板中的颜色</span></div><div class="line">                  [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>]</div><div class="line">                 ])</div><div class="line"></div><div class="line">palette[image]</div></pre></td></tr></table></figure><pre><code>array([[[  0,   0,   0],        [255,   0,   0],        [  0, 255,   0],        [  0,   0,   0]],       [[  0,   0,   0],        [  0,   0, 255],        [255, 255, 255],        [  0,   0,   0]]])</code></pre><p>我们也可以给出不不止一维的索引，每一维的索引数组必须有相同的形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i = np.array([[<span class="number">0</span>,<span class="number">1</span>],    <span class="comment"># indices for the first dim of a</span></div><div class="line">             [<span class="number">1</span>,<span class="number">2</span>]])</div><div class="line"></div><div class="line">j = np.array([[<span class="number">2</span>,<span class="number">1</span>],    <span class="comment"># indices for the second dim</span></div><div class="line">             [<span class="number">3</span>,<span class="number">3</span>]])</div><div class="line"></div><div class="line">a[i,j]                  <span class="comment"># i 和 j必须拥有相同的shape</span></div></pre></td></tr></table></figure><pre><code>array([[ 2,  5],       [ 7, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[i,<span class="number">2</span>]</div></pre></td></tr></table></figure><pre><code>array([[ 2,  6],       [ 6, 10]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[:,j]</div></pre></td></tr></table></figure><pre><code>array([[[ 2,  1],        [ 3,  3]],       [[ 6,  5],        [ 7,  7]],       [[10,  9],        [11, 11]]])</code></pre><p>当然，我们可以将<code>i</code>和<code>j</code>放入一个序列中（比如说一个列表），然后用列表进行索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">l = [i,j]</div><div class="line">a[l]        <span class="comment"># 相当于一个[i,j]</span></div></pre></td></tr></table></figure><pre><code>array([[ 2,  5],       [ 7, 11]])</code></pre><p>但是，我们不能将<code>i</code>和<code>j</code>放进一个数组，因为这个数组将被解读为a的第一个维度的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = np.array([i,j])</div><div class="line">a[s]     <span class="comment"># 结果不是我们想要的</span></div></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------IndexError                                Traceback (most recent call last)&lt;ipython-input-204-79ccae1d198c&gt; in &lt;module&gt;()      1 s = np.array([i,j])----&gt; 2 a[s]     # 结果不是我们想要的IndexError: index 3 is out of bounds for axis 0 with size 3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[tuple(s)]     <span class="comment"># 与 a[i,j]相同</span></div></pre></td></tr></table></figure><pre><code>array([[ 2,  5],       [ 7, 11]])</code></pre><p>另一个常用的数组索引用法是搜索时间序列最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">time = np.linspace(<span class="number">20</span>, <span class="number">145</span>, <span class="number">5</span>)    <span class="comment"># 时间尺度</span></div><div class="line">data = np.sin(np.arange(<span class="number">20</span>)).reshape(<span class="number">5</span>,<span class="number">4</span>)  <span class="comment"># 4个时间依赖序列</span></div><div class="line">time</div></pre></td></tr></table></figure><pre><code>array([  20.  ,   51.25,   82.5 ,  113.75,  145.  ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data</div></pre></td></tr></table></figure><pre><code>array([[ 0.        ,  0.84147098,  0.90929743,  0.14112001],       [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],       [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],       [-0.53657292,  0.42016704,  0.99060736,  0.65028784],       [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ind = data.argmax(axis=<span class="number">0</span>)    <span class="comment"># 每个序列的最大值的索引</span></div><div class="line">ind</div></pre></td></tr></table></figure><pre><code>array([2, 0, 3, 1])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">time_max = time[ind]         <span class="comment"># 时间序列对应的最大值</span></div><div class="line">data_max = data[ind, range(data.shape[<span class="number">1</span>])]  <span class="comment"># =&gt; data[ind[0],0], data[ind[1],1]...</span></div><div class="line"></div><div class="line">time_max</div></pre></td></tr></table></figure><pre><code>array([  82.5 ,   20.  ,  113.75,   51.25])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data_max</div></pre></td></tr></table></figure><pre><code>array([ 0.98935825,  0.84147098,  0.99060736,  0.6569866 ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.all(data_max == data.max(axis=<span class="number">0</span>))</div></pre></td></tr></table></figure><pre><code>True</code></pre><p>你也可以使用数组索引作为目标来赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">5</span>)</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3, 4])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]] = <span class="number">0</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([0, 0, 2, 0, 0])</code></pre><p>然而，当一个索引列表包含重复时，赋值被多次完成，保留最后一次的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">5</span>)</div><div class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([2, 1, 3, 3, 4])</code></pre><p>这足够合理，但是小心如果你想用Python的<code>+=</code>结构，可能结果并非你所期望：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">5</span>)</div><div class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]] += <span class="number">1</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([1, 1, 3, 3, 4])</code></pre><p>即使0在索引列表中出现两次，索引为0的元素仅仅增加一次。这是因为Python要求<code>a+=1</code>和<code>a=a+1</code>等同。</p><h4 id="通过布尔数组索引"><a href="#通过布尔数组索引" class="headerlink" title="通过布尔数组索引"></a>通过布尔数组索引</h4><p>当我们使用整数数组索引数组时，我们提供一个索引列表去选择。通过布尔数组索引的方法是不同的我们显式地选择数组中我们想要和不想要的元素。</p><p>我们能想到的使用布尔数组的索引最自然方式就是使用和原数组一样形状的布尔数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">b = a &gt; <span class="number">4</span></div><div class="line">b                   <span class="comment"># b 是一个和a形状相同的boolean数组</span></div></pre></td></tr></table></figure><pre><code>array([[False, False, False, False],       [False,  True,  True,  True],       [ True,  True,  True,  True]], dtype=bool)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[b]                <span class="comment"># 经过筛选后的1维数组</span></div></pre></td></tr></table></figure><pre><code>array([ 5,  6,  7,  8,  9, 10, 11])</code></pre><p>这个属性在赋值时非常有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a[b] = <span class="number">0</span>            <span class="comment"># 将a中所有比4大的元素赋值为0</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[0, 1, 2, 3],       [4, 0, 0, 0],       [0, 0, 0, 0]])</code></pre><p>你可以参考曼德博集合示例看看如何使用布尔索引来生成<a href="http://en.wikipedia.org/wiki/Mandelbrot_set" target="_blank" rel="external">曼德博集合</a>的图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mandelbrot</span><span class="params">(h,w,maxit=<span class="number">20</span>)</span>:</span></div><div class="line">    <span class="string">"""返回一个尺寸为（h,w）的曼德博分形图"""</span></div><div class="line">    y,x = np.ogrid[ <span class="number">-1.4</span>:<span class="number">1.4</span>:h*<span class="number">1j</span>, <span class="number">-2</span>:<span class="number">0.8</span>:w*<span class="number">1j</span>]</div><div class="line">    c = x+y * <span class="number">1j</span></div><div class="line">    z = c</div><div class="line">    divtime = maxit + np.zeros(z.shape,dtype=int)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(maxit):</div><div class="line">        z = z**<span class="number">2</span> + c</div><div class="line">        diverge = z*np.conj(z) &gt; <span class="number">2</span>**<span class="number">2</span>    <span class="comment"># who is diverging</span></div><div class="line">        div_now = diverge &amp; (divtime == maxit)  <span class="comment"># who is diverging now</span></div><div class="line">        divtime[div_now] = i                    <span class="comment"># note when</span></div><div class="line">        z[diverge] = <span class="number">2</span>                          <span class="comment"># avoid diverging too much</span></div><div class="line">        </div><div class="line">    <span class="keyword">return</span> divtime</div><div class="line"></div><div class="line">plt.imshow(mandelbrot(<span class="number">400</span>,<span class="number">400</span>))</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/img/18_05_11/output_194_0.png" alt="png"></p><p>第二种通过布尔来索引的方法更近似于整数索引；对数组的每个维度我们给一个一维布尔数组来选择我们想要的切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">b1 = np.array([<span class="keyword">False</span>,<span class="keyword">True</span>,<span class="keyword">True</span>])    <span class="comment"># 第一维的筛选</span></div><div class="line">b2 = np.array([<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="keyword">True</span>,<span class="keyword">False</span>])  <span class="comment"># 第二维的筛选</span></div><div class="line"></div><div class="line">a[b1,:]       <span class="comment"># 选择行</span></div></pre></td></tr></table></figure><pre><code>array([[ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[b1]         <span class="comment"># 和上面相同</span></div></pre></td></tr></table></figure><pre><code>array([[ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[:,b2]       <span class="comment"># 选择列</span></div></pre></td></tr></table></figure><pre><code>array([[ 0,  2],       [ 4,  6],       [ 8, 10]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[b1,b2]      <span class="comment"># 一个奇怪的结果</span></div></pre></td></tr></table></figure><pre><code>array([ 4, 10])</code></pre><p>注意一维数组的长度必须和你想要切片的维度或轴的长度一致，在之前的例子中，<code>b1</code>是一个秩为1长度为三的数组(<code>a</code>的行数)，<code>b2</code>(长度为4)与<code>a</code>的第二秩(列)相一致。</p><h4 id="ix-函数"><a href="#ix-函数" class="headerlink" title="ix_()函数"></a>ix_()函数</h4><p><code>ix_</code>函数可以为了获得多元组的结果而用来结合不同向量。例如，如果你想要用所有向量a、b和c元素组成的三元组来计算a+b*c：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line">b = np.array([<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>])</div><div class="line">c = np.array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>])</div><div class="line">ax,bx,cx = np.ix_(a,b,c)</div><div class="line">ax</div></pre></td></tr></table></figure><pre><code>array([[[2]],       [[3]],       [[4]],       [[5]]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bx</div></pre></td></tr></table></figure><pre><code>array([[[8],        [5],        [4]]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cx</div></pre></td></tr></table></figure><pre><code>array([[[5, 4, 6, 8, 3]]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ax.shape, bx.shape, cx.shape</div></pre></td></tr></table></figure><pre><code>((4, 1, 1), (1, 3, 1), (1, 1, 5))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = ax + bx * cx</div><div class="line">result</div></pre></td></tr></table></figure><pre><code>array([[[42, 34, 50, 66, 26],        [27, 22, 32, 42, 17],        [22, 18, 26, 34, 14]],       [[43, 35, 51, 67, 27],        [28, 23, 33, 43, 18],        [23, 19, 27, 35, 15]],       [[44, 36, 52, 68, 28],        [29, 24, 34, 44, 19],        [24, 20, 28, 36, 16]],       [[45, 37, 53, 69, 29],        [30, 25, 35, 45, 20],        [25, 21, 29, 37, 17]]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</div></pre></td></tr></table></figure><pre><code>17</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[<span class="number">3</span>] + b[<span class="number">2</span>] * c[<span class="number">4</span>]</div></pre></td></tr></table></figure><pre><code>17</code></pre><p>你也可以实行如下简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ufunc_reduce</span><span class="params">(ufct, *vectors)</span>:</span></div><div class="line">    vs = np.ix_(*vectors)</div><div class="line">    r = ufct.identity</div><div class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> vs:</div><div class="line">        r = ufct(r,v)</div><div class="line">    <span class="keyword">return</span> r</div></pre></td></tr></table></figure><p>然后这样使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ufunc_reduce(np.add,a,b,c)</div></pre></td></tr></table></figure><pre><code>array([[[15, 14, 16, 18, 13],        [12, 11, 13, 15, 10],        [11, 10, 12, 14,  9]],       [[16, 15, 17, 19, 14],        [13, 12, 14, 16, 11],        [12, 11, 13, 15, 10]],       [[17, 16, 18, 20, 15],        [14, 13, 15, 17, 12],        [13, 12, 14, 16, 11]],       [[18, 17, 19, 21, 16],        [15, 14, 16, 18, 13],        [14, 13, 15, 17, 12]]])</code></pre><p>这个reduce与ufunc.reduce(比如说add.reduce)相比的优势在于它利用了广播法则，避免了创建一个输出大小乘以向量个数的参数数组。</p><h4 id="用字符串索引"><a href="#用字符串索引" class="headerlink" title="用字符串索引"></a>用字符串索引</h4><p>参加<a href="https://docs.scipy.org/doc/numpy/user/basics.rec.html#structured-arrays" target="_blank" rel="external">结构化数组</a>。</p><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>继续前进，基本线性代数包含在这里。</p><h4 id="简单数组运算"><a href="#简单数组运算" class="headerlink" title="简单数组运算"></a>简单数组运算</h4><p>参考numpy文件夹中的linalg.py获得更多信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">a = np.array([[<span class="number">1.0</span>,<span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</div><div class="line">print(a)</div></pre></td></tr></table></figure><pre><code>[[ 1.  2.] [ 3.  4.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.transpose()</div></pre></td></tr></table></figure><pre><code>array([[ 1.,  3.],       [ 2.,  4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.linalg.inv(a)</div></pre></td></tr></table></figure><pre><code>array([[-2. ,  1. ],       [ 1.5, -0.5]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">u = np.eye(<span class="number">2</span>) <span class="comment"># unit 2x2 matrix; "eye" represents "I"  单位矩阵</span></div><div class="line">u</div></pre></td></tr></table></figure><pre><code>array([[ 1.,  0.],       [ 0.,  1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">j = np.array([[<span class="number">0.0</span>, <span class="number">-1.0</span>], [<span class="number">1.0</span>, <span class="number">0.0</span>]])</div><div class="line">np.dot(j, j)   <span class="comment"># 矩阵乘法</span></div></pre></td></tr></table></figure><pre><code>array([[-1.,  0.],       [ 0., -1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.trace(u)    <span class="comment"># trace</span></div></pre></td></tr></table></figure><pre><code>2.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y = np.array([[<span class="number">5.</span>],[<span class="number">7.</span>]])</div><div class="line">np.linalg.solve(a, y)</div></pre></td></tr></table></figure><pre><code>array([[-3.],       [ 4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.linalg.eig(j)</div></pre></td></tr></table></figure><pre><code>(array([ 0.+1.j,  0.-1.j]), array([[ 0.70710678+0.j        ,  0.70710678-0.j        ],        [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]]))</code></pre><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Parameters</span>:</div><div class="line">    square matrix</div><div class="line"><span class="symbol">Returns</span></div><div class="line">    <span class="symbol">The</span> eigenvalues, each repeated according to its multiplicity.</div><div class="line">    <span class="symbol">The</span> normalized (unit <span class="string">"length"</span>) eigenvectors, such that the</div><div class="line">    column <span class="string">``</span>v[:,i]<span class="string">``</span> is the eigenvector corresponding to the</div><div class="line">    eigenvalue <span class="string">``</span>w[i]<span class="string">``</span> .</div></pre></td></tr></table></figure><h3 id="技巧和提示"><a href="#技巧和提示" class="headerlink" title="技巧和提示"></a>技巧和提示</h3><p>下面我们给出简短和有用的提示。</p><h4 id="“自动”改变形状"><a href="#“自动”改变形状" class="headerlink" title="“自动”改变形状"></a>“自动”改变形状</h4><p>更改数组的维度，你可以省略一个尺寸，它将被自动推导出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">30</span>)</div><div class="line">a.shape = <span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>  <span class="comment"># -1 意味着 “无论需要什么”</span></div><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(2, 5, 3)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[[ 0,  1,  2],        [ 3,  4,  5],        [ 6,  7,  8],        [ 9, 10, 11],        [12, 13, 14]],       [[15, 16, 17],        [18, 19, 20],        [21, 22, 23],        [24, 25, 26],        [27, 28, 29]]])</code></pre><h4 id="向量组合-stacking"><a href="#向量组合-stacking" class="headerlink" title="向量组合(stacking)"></a>向量组合(stacking)</h4><p>我们如何用两个相同尺寸的行向量列表构建一个二维数组？在MATLAB中这非常简单：如果<code>x</code>和<code>y</code>是两个相同长度的向量，你仅仅需要做<code>m=[x;y]</code>。在NumPy中这个过程通过函数<code>column_stack</code>、<code>dstack</code>、<code>hstack</code>和<code>vstack</code>来完成，取决于你想要在那个维度上组合。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)      <span class="comment"># x = ([0,2,4,6,8])</span></div><div class="line">y = np.arange(<span class="number">5</span>)           <span class="comment"># y = ([0,1,2,3,4])</span></div><div class="line">m = np.vstack([x,y])       <span class="comment"># m=([[0,2,4,6,8],</span></div><div class="line">                           <span class="comment">#     [0,1,2,3,4]])</span></div><div class="line">m</div></pre></td></tr></table></figure><pre><code>array([[0, 2, 4, 6, 8],       [0, 1, 2, 3, 4]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xy = np.hstack([x,y])      <span class="comment"># xy = ([0,2,4,6,8,0,1,2,3,4])</span></div><div class="line">xy</div></pre></td></tr></table></figure><pre><code>array([0, 2, 4, 6, 8, 0, 1, 2, 3, 4])</code></pre><h4 id="直方图-histogram"><a href="#直方图-histogram" class="headerlink" title="直方图(histogram)"></a>直方图(histogram)</h4><p>NumPy中<code>histogram</code>函数应用到一个数组返回一对变量：直方图数组和箱式向量。注意：<code>matplotlib</code>也有一个用来建立直方图的函数(叫作<code>hist</code>,正如matlab中一样)与NumPy中的不同。主要的差别是<code>pylab.hist</code>自动绘制直方图，而<code>numpy.histogram</code>仅仅产生数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="comment"># 简历一个拥有10000个元素的正态分布的向量，方差为0.5^2，均值为2</span></div><div class="line">mu, sigma = <span class="number">2</span>, <span class="number">0.5</span></div><div class="line">v = np.random.normal(mu,sigma,<span class="number">10000</span>)</div><div class="line"><span class="comment"># 绘制分成50份的正态分布直方图</span></div><div class="line">plt.hist(v, bins=<span class="number">50</span>, normed=<span class="number">1</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/img/18_05_11/output_232_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用numpy计算直方图然后绘制它</span></div><div class="line">(n, bins) = np.histogram(v, bins=<span class="number">50</span>, normed=<span class="keyword">True</span>)  <span class="comment"># NumPy version (no plot)</span></div><div class="line">plt.plot(<span class="number">.5</span>*(bins[<span class="number">1</span>:]+bins[:<span class="number">-1</span>]), n)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/img/18_05_11/output_233_0.png" alt="png"></p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part6-发布你的app</title>
      <link>http://studyai.site/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/</link>
      <guid>http://studyai.site/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/</guid>
      <pubDate>Thu, 03 May 2018 06:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compos</a>。</li><li>按照Part4部分，获取<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">Docker Machine</a>。</li><li>阅读Part1。</li><li>学习Part2中的如何创建容器。</li><li>确保您的镜像作为一个发布容器在运行。运行这条插入了<code>username</code>、<code>repo</code>和<code>tag</code>信息的命令:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li><li>获取到Part5中的最终版本的<code>compose.yml</code>文件。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>您一直在为整个教程编辑相同的Compose文件。那么，我们有一个好消息，这个Compose文件在生产环境中的效果与你的计算机上的效果是相同的。在这里，我们通过一些选项来运行Docker化的程序。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="Docker社区版（云服务提供者）"><a href="#Docker社区版（云服务提供者）" class="headerlink" title="Docker社区版（云服务提供者）"></a>Docker社区版（云服务提供者）</h3><p>如果您可以在生产环境中使用Docker社区版，那么你可以使用Docker Cloud来帮助您管理应用程序，例如Amazon Web Services，DigitalOcean，和Microsoft Azure等常用的服务提供商。</p><p>设置和部署：</p><ul><li>将Docker Cloud与您的首选提供商连接，授予Docker Cloud权限，以便为您自动配置以及为您”Docker化”VM。</li><li>使用Docker Cloud创建您的计算资源并创建您的swarm。</li><li>部署您的应用。</li></ul><blockquote><p>注意：我们没有链接到Docker Cloud文档。请务必在完成每个步骤后回到此页面。</p></blockquote><h4 id="连接Docker-Cloud"><a href="#连接Docker-Cloud" class="headerlink" title="连接Docker Cloud"></a>连接Docker Cloud</h4><p>你可以在<a href="https://docs.docker.com/docker-cloud/infrastructure/" target="_blank" rel="external">标准模式</a>或<a href="https://docs.docker.com/docker-cloud/cloud-swarm/" target="_blank" rel="external">swarm模式</a>下运行Docker Cloud。</p><p>如果你正在标准模式下运行Docker Cloud，请按照以下说明将您的服务提供商链接到Docker Cloud。</p><ul><li><a href="https://docs.docker.com/docker-cloud/cloud-swarm/link-aws-swarm/" target="_blank" rel="external">Amazon Web Services 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-do/" target="_blank" rel="external">DigitalOcean 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-azure/" target="_blank" rel="external">Microsoft Azure 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-packet/" target="_blank" rel="external">Packet 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-softlayer/" target="_blank" rel="external">SoftLayer 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/" target="_blank" rel="external">使用Docker Cloud 代理来访问自己的主机</a>。</li></ul><p>如果您在Swarm模式下运行（推荐用于Amazon Web Services或Microsoft Azure），那么请跳至下一节关于如何<a href="#创建你的swarm">创建swarm</a>的部分。</p><h3 id="创建你的swarm"><a href="#创建你的swarm" class="headerlink" title="创建你的swarm"></a>创建你的swarm</h3><p>准备好创建一个swarm了吗？</p><ul><li>如果你在使用Amazon Web Services(AWS)，那么你可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-aws/" target="_blank" rel="external">在AWS上自动地创建一个swarm</a>。</li><li>如果你在使用Microsoft Azure，那么你可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-azure/" target="_blank" rel="external">在Azure上自动地创建一个swarm</a>。</li><li>否则，在Docker Cloud UI界面<a href="https://docs.docker.com/docker-cloud/getting-started/your_first_node/" target="_blank" rel="external">创建你的节点</a>，然后运行<code>docker swarm init</code>并执行在Part4部分所学的<code>docker swarm join</code>命令。最后，通过点击屏幕顶部的开关<a href="https://docs.docker.com/docker-cloud/cloud-swarm/using-swarm-mode/" target="_blank" rel="external">启用swarm模式</a>，并<a href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/" target="_blank" rel="external">注册你刚刚创建的swarm</a>。</li></ul><blockquote><p>注意：如果您<a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/" target="_blank" rel="external">使用Docker云代理来自带主机</a>，则此提供程序不支持swarm模式。您可以使用Docker Cloud<a href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/" target="_blank" rel="external">注册您自己的现有的swarm</a>。</p></blockquote><h3 id="在云服务平台上部署你的应用程序"><a href="#在云服务平台上部署你的应用程序" class="headerlink" title="在云服务平台上部署你的应用程序"></a>在云服务平台上部署你的应用程序</h3><ul><li><p>1.<a href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/" target="_blank" rel="external">通过Docker Cloud连接到你自己的swarm</a>。有几种不同的连接方式：</p><ul><li><p>从Swarm模式的Docker Cloud Web界面中，选择页面顶部的Swarms，单击要连接的swarm，然后将给定的命令复制粘贴到命令行终端中。</p><p><img src="/img/18_05_02/004.png" alt=""></p><p>或者。。。</p></li><li><p>在Docker for Mac或Docker for Windows上，您可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/#use-docker-for-mac-or-windows-edge-to-connect-to-swarms" target="_blank" rel="external">通过桌面应用菜单直接连接到swarm</a>。</p><p><img src="/img/18_05_02/005.png" alt=""></p><p>无论哪种方式，都将打开一个终端，其上下文是本地计算机，但其Docker命令会路由到云服务提供商上运行的swarm。您可以直接访问本地文件系统和远程swarm，从而启用纯粹的<code>docker</code>命令。</p></li></ul></li><li><p>2.运行<code>docker stack deploy -c docker-compose.yml getstartedlab</code>在云托管swarm上部署应用程序。</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div><div class="line"></div><div class="line">Creating network getstartedlab_webnet</div><div class="line">Creating service getstartedlab_web</div><div class="line">Creating service getstartedlab_visualizer</div><div class="line">Creating service getstartedlab_redis</div></pre></td></tr></table></figure><p>  您的应用现在运行在了云服务平台上了。</p></li></ul><p><strong>运行一些swarm命令来验证部署：</strong></p><p>你可以使用swarm命令行，就像你之前做的那样，浏览并管理你的swarm。这里有一些你比较熟悉的例子：</p><ul><li>使用<code>docker node ls</code>列出节点。</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[getstartedlab] ~ $ docker node ls</div><div class="line">ID                            HOSTNAME                                      STATUS              AVAILABILITY        MANAGER STATUS</div><div class="line"><span class="number">9442</span>yi1zie2l34lj01frj3lsn     ip<span class="number">-172</span><span class="number">-31</span><span class="number">-5</span><span class="number">-208.</span>us-west<span class="number">-1.</span>compute.internal    Ready               Active              </div><div class="line">jr02vg153pfx6jr0j66624e8a     ip<span class="number">-172</span><span class="number">-31</span><span class="number">-6</span><span class="number">-237.</span>us-west<span class="number">-1.</span>compute.internal    Ready               Active              </div><div class="line">thpgwmoz3qefdvfzp7d9wzfvi     ip<span class="number">-172</span><span class="number">-31</span><span class="number">-18</span><span class="number">-121.</span>us-west<span class="number">-1.</span>compute.internal   Ready               Active              </div><div class="line">n2bsny0r2b8fey6013kwnom3m *   ip<span class="number">-172</span><span class="number">-31</span><span class="number">-20</span><span class="number">-217.</span>us-west<span class="number">-1.</span>compute.internal   Ready               Active              Leader</div></pre></td></tr></table></figure><ul><li>使用<code>docker service ls</code>列出服务。</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[getstartedlab] ~/sandbox/getstart $ docker service ls</div><div class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</div><div class="line"><span class="function"><span class="title">x3jyx6uukog9</span>        dockercloud-server-proxy   global              1/1                 dockercloud/server-proxy          *:2376-&gt;</span><span class="number">2376</span>/tcp</div><div class="line"><span class="function"><span class="title">ioipby1vcxzm</span>        getstartedlab_redis        replicated          0/1                 redis:latest                      *:6379-&gt;</span><span class="number">6379</span>/tcp</div><div class="line"><span class="function"><span class="title">u5cxv7ppv5o0</span>        getstartedlab_visualizer   replicated          0/1                 dockersamples/visualizer:stable   *:8080-&gt;</span><span class="number">8080</span>/tcp</div><div class="line"><span class="function"><span class="title">vy7n2piyqrtr</span>        getstartedlab_web          replicated          5/5                 sam/getstarted:part6    *:80-&gt;</span><span class="number">80</span>/tcp</div></pre></td></tr></table></figure><ul><li>使用<code>docker service ps &lt;service&gt;</code>查看service的任务列表。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[getstartedlab] ~/sandbox/getstart $ docker service ps vy7n2piyqrtr</div><div class="line">ID                  NAME                  IMAGE                            NODE                                          DESIRED STATE       CURRENT STATE            ERROR               PORTS</div><div class="line">qrcd4a9lvjel        getstartedlab_web.<span class="number">1</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">5</span>-<span class="number">208</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>    Running             Running <span class="number">20</span> seconds ago                       </div><div class="line">sknya8t4m51u        getstartedlab_web.<span class="number">2</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">6</span>-<span class="number">237</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>    Running             Running <span class="number">17</span> seconds ago                       </div><div class="line">ia730lfnrslg        getstartedlab_web.<span class="number">3</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">20</span>-<span class="number">217</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>   Running             Running <span class="number">21</span> seconds ago                       </div><div class="line"><span class="number">1</span>edaa97h9u4k        getstartedlab_web.<span class="number">4</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">18</span>-<span class="number">121</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>   Running             Running <span class="number">21</span> seconds ago                       </div><div class="line">uh64ez6ahuew        getstartedlab_web.<span class="number">5</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">18</span>-<span class="number">121</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>   Running             Running <span class="number">22</span> seconds ago</div></pre></td></tr></table></figure><p><strong>在云供应商机器上开放服务端口</strong></p><p>此时，您的应用作为一个swarm部署在您的云提供商服务器上，正如刚刚运行的<code>docker</code>命令所证明的那样。但是，您仍然需要在云服务器上打开端口，以便：</p><ul><li>允许在工作节点上的<code>redis</code>服务和<code>web</code>服务之间进行通信</li><li>允许入站流量通过worker节点上的<code>web</code>服务，以便可以在浏览器访问Hello World和Visualizer。</li><li>允许运行<code>manager</code>的服务器上的入站SSH流量（这可能已在您的云提供商上设置）</li></ul><p>这些是您需要为每项服务公开的端口：</p><table><thead><tr><th style="text-align:left">Service</th><th style="text-align:left">类型</th><th style="text-align:left">协议</th><th style="text-align:left">端口</th></tr></thead><tbody><tr><td style="text-align:left"><code>web</code></td><td style="text-align:left">HTTP</td><td style="text-align:left">TCP</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left"><code>visualizer</code></td><td style="text-align:left">HTTP</td><td style="text-align:left">TCP</td><td style="text-align:left">8080</td></tr><tr><td style="text-align:left"><code>redis</code></td><td style="text-align:left">TCP</td><td style="text-align:left">TCP</td><td style="text-align:left">6379</td></tr></tbody></table><p>具体的做法取决于云服务平台。</p><p>我们以Amazon Web Services（AWS）为例。</p><blockquote><p><strong>redis如何持久化数据？</strong></p><p>为了使<code>redis</code>服务正常工作，在运行<code>docker stack deploy</code>之前，需要<code>ssh</code>进入manager运行的云服务器，并在<code>/home/docker/</code>中创建<code>data/</code>目录。另一种选择是将<code>docker-stack.yml</code>中的数据路径更改为manager服务器上已存在的一个路径。此示例不包含此步骤，因此示例输出中的<code>redis</code>服务未启动。</p></blockquote><p><strong>示例：AWS</strong></p><ul><li>1.登录<a href="https://aws.amazon.com/" target="_blank" rel="external">AWS控制台</a>，转到EC2仪表板，然后单击进入<strong>Running Instances</strong>查看节点。</li><li><p>2.在左侧的按钮，进入Network &amp; Security &gt; <strong>Security Groups</strong>。</p><p>  请参阅<code>getstartedlab-Manager-&lt;xxx&gt;</code>, <code>getstartedlab-Nodes-&lt;xxx&gt;</code>, 和 <code>getstartedlab-SwarmWide-&lt;xxx&gt;</code>的与swarm相关的安全组。</p></li><li><p>3.为swarm选择“节点”安全组。组名是这样的：<code>getstartedlab-NodeVpcSG-9HV9SMHDZT8C</code>。</p></li><li>4.为<code>web</code>，<code>visualizer</code>和<code>redis</code>服务添加入站规则，为每个服务设置类型，协议和端口（如上表所示），然后单击保存以应用规则。</li></ul><p><img src="/img/18_05_02/006.png" alt=""></p><blockquote><p>提示：当你保存新的规则时，会为IPv4和IPv6地址自动创建HTTP和TCP端口。</p></blockquote><p><img src="/img/18_05_02/007.png" alt=""></p><ul><li>5.进入<strong>Running Instances</strong>列表，获取其中一个worker的公共DNS名称，并将其粘贴到浏览器地址栏中。</li></ul><p><img src="/img/18_05_02/008.png" alt=""></p><p>就像本教程的前几部分一样，Hello World应用程序显示在端口<code>80</code>上，而Visualizer显示在端口<code>8080</code>上。</p><p><img src="/img/18_05_02/009.png" alt=""></p><p><img src="/img/18_05_02/010.png" alt=""></p><h3 id="迭代和清理"><a href="#迭代和清理" class="headerlink" title="迭代和清理"></a>迭代和清理</h3><p>从这里你可以完成你在教程前面部分学到的所有知识。</p><ul><li>通过修改<code>docker-compose.yml</code>文件并使用命令<code>docker stack deploy</code>重新发布来扩展你的应用程序。</li><li>通过编辑代码更改应用程序行为，然后重新构建并推送新镜像。（要做到这一点，请按照之前用于<a href="https://docs.docker.com/get-started/part2/#build-the-app" target="_blank" rel="external">构建应用程序</a>和<a href="https://docs.docker.com/get-started/part2/#publish-the-image" target="_blank" rel="external">发布镜像</a>的相同步骤）。</li><li>您可以使用<code>docker stack rm</code>命令来拆卸堆栈。例如：</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> getstartedlab</div></pre></td></tr></table></figure><p>与在本地Docker机器虚拟机上运行swarm的场景不同，不管您是否关闭本地主机，您的swarm和部署在其上的任何应用程序都将继续在云服务器上运行。</p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
