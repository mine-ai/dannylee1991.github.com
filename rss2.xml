<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>studyAI</title>
    <link>http://studyai.site/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 02 May 2018 09:28:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Docker入门Part4-Swarms</title>
      <link>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/</link>
      <guid>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/</guid>
      <pubDate>Thu, 26 Apr 2018 05:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compos</a>。</li><li>获取预装<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Docker for Mac</a>和<a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="external">Docker for Windows</a>的<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">Docker Machine</a>，但在Linux系统上需要<a href="https://docs.docker.com/machine/install-machine/#installing-machine-directly" target="_blank" rel="external">直接安装它</a>。在没有<em>Hyper-V</em>的Windows 10系统之前以及Windows 10 Home中，使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">Docker Toolbox</a>。</li><li>阅读Part1。</li><li>学习Part2中的如何创建容器。</li><li>确保您已发布了那个<a href="https://docs.docker.com/get-started/part2/#share-your-image" target="_blank" rel="external">推送到仓库的</a><code>friendlyhello</code>镜像。我们在这里使用该共享镜像。</li><li>确定你的镜像作为一个已部署的容器。运行下面这条命令，插入你的<code>username</code>、<code>repo</code>、和<code>tag</code>:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li><li>有一份Part3中的<code>docker-compose.yml</code>。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Part3中，你介绍了在Part2中编写的应用程序，并通过将其转化为service来定义应该如何在生产环境中运行，并在其进程内扩大5倍。</p><p>在Part4部分，您将此应用程序部署到集群上，并在多台机器上运行它。通过将多台机器连接到称为<strong>swarm</strong>的“Dockerized”群集，使多容器，多机器应用成为可能。</p><h2 id="了解Swarm集群"><a href="#了解Swarm集群" class="headerlink" title="了解Swarm集群"></a>了解Swarm集群</h2><p>Swarm是一组运行Docker并加入到集群中的机器。发生这种情况后，您将继续运行您习惯的Docker命令，但现在它们将由<strong>swarm manager</strong>在群集上执行。swarm中的机器可以是物理的或虚拟的。加入swarm后，他们被称为节点。</p><p>swarm管理器可以使用几种策略来运行容器，例如“emptiest node”–它用容器填充最少使用的机器。或者“global”，它可以确保每台机器只获取指定容器的一个实例。您指示swarm manager在Compose文件中使用这些策略，就像您已经使用的策略一样。</p><p>swarm manager是群体中唯一可以执行你的命令，或者授权其他机器作为<strong>worker</strong>加入群体的机器。worker只是提供能力，并没有权力告诉任何其他机器它能做什么和不能做什么。</p><p>到目前为止，您已经在本地机器上以单主机模式使用Docker。但是Docker也可以切换到<strong>swarm模式</strong>，这就是使用群集的原因。立即启用swarm模式使当前的机器成为swarm manager。从此，Docker将运行您在您管理的swarm上执行的命令，而不仅仅是在当前机器上执行。</p><h2 id="设置你的swarm"><a href="#设置你的swarm" class="headerlink" title="设置你的swarm"></a>设置你的swarm</h2><p>一个swarm是由多个节点组成，这些节点可以是物理机或虚拟机。基本概念很简单：运行<code>docker swarm init</code>来启用swarm模式，并使您当前的机器成为swarm管理器，然后在其他机器上运行<code>docker swarm join</code>，使其他机器以worker的身份加入到swarm中。我们将使用虚拟机快速创建一个双机群集，并将其变成swarm。</p><h3 id="创建一个集群"><a href="#创建一个集群" class="headerlink" title="创建一个集群"></a>创建一个集群</h3><h4 id="本地虚拟机（Mac，Linux，Windows-7和8）"><a href="#本地虚拟机（Mac，Linux，Windows-7和8）" class="headerlink" title="本地虚拟机（Mac，Linux，Windows 7和8）"></a>本地虚拟机（Mac，Linux，Windows 7和8）</h4><p>您需要一个可以创建虚拟机（VM）的虚拟机管理程序，因此请为您的计算机的操作系统<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">安装Oracle VirtualBox</a>。</p><blockquote><p>注意：如果你在Windows系统下，并且已经安装了Hyper-V，例如Windows 10，那就没必要安装VirtualBox了，你可以使用Hyper-V替代。如果你正在使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">Docker Toolbox</a>，你应该已经安装好了VirtualBox。</p></blockquote><p>现在，使用<code>docker-machine</code>创建两个虚拟机VM，使用VirtualBox驱动：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker-machine <span class="built_in">create</span> <span class="comment">--driver virtualbox myvm1</span></div><div class="line">docker-machine <span class="built_in">create</span> <span class="comment">--driver virtualbox myvm2</span></div></pre></td></tr></table></figure><h4 id="本地虚拟机（Windows-10-Hyper-V）"><a href="#本地虚拟机（Windows-10-Hyper-V）" class="headerlink" title="本地虚拟机（Windows 10/Hyper-V）"></a>本地虚拟机（Windows 10/Hyper-V）</h4><p>首先，快速为您的虚拟机（VM）创建一个虚拟交换机以便共享，以便它们可以相互连接。</p><ul><li>1.开启 Hyper-V Manager</li><li>2.点击右上角菜单中的<strong>Virtual Switch Manager</strong></li><li>3.单击创建类型为<strong>External</strong>的<strong>虚拟交换机</strong></li><li>4.将它命名为<code>myswitch</code>，然后选中复选框以共享主机的活动网络适配器</li></ul><p>现在，使用我们的节点管理工具<code>docker-machine</code>创建几个虚拟机：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker-machine create -d hyperv --hyperv-<span class="keyword">virtual</span>-<span class="keyword">switch</span> <span class="string">"myswitch"</span> myvm1</div><div class="line">docker-machine create -d hyperv --hyperv-<span class="keyword">virtual</span>-<span class="keyword">switch</span> <span class="string">"myswitch"</span> myvm2</div></pre></td></tr></table></figure><hr><h3 id="列出虚拟机，并显示其IP地址"><a href="#列出虚拟机，并显示其IP地址" class="headerlink" title="列出虚拟机，并显示其IP地址"></a>列出虚拟机，并显示其IP地址</h3><p>你现在创建了两个虚拟机，名叫<code>myvm1</code>和<code>myvm2</code>。</p><p>使用下面的命令来列出这些虚拟机以及他们的IP地址。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine <span class="keyword">ls</span></div></pre></td></tr></table></figure><p>这里是这个命令的输出示例。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</div><div class="line">myvm1   -        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.100</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce   </div><div class="line">myvm2   -        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.101</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div></pre></td></tr></table></figure><h3 id="初始化swarm和节点"><a href="#初始化swarm和节点" class="headerlink" title="初始化swarm和节点"></a>初始化swarm和节点</h3><p>第一台机器作为manager，它负责执行管理命令并认证worker机器加入集群，第二台机器是worker。</p><p>你可以对你的虚拟机通过<code>docker-machine ssh</code>来发送命令。通过执行<code>docker swarm init</code>来指导<code>myvm1</code>来成为swarm manager，然后你会看到像下面这样的输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh myvm1 <span class="string">"docker swarm init --advertise-addr &lt;myvm1 ip&gt;"</span></div><div class="line">Swarm initialized: current node &lt;node ID&gt; is now <span class="keyword">a</span> manager.</div><div class="line"></div><div class="line">To <span class="built_in">add</span> <span class="keyword">a</span> worker <span class="built_in">to</span> this swarm, run <span class="keyword">the</span> following <span class="keyword">command</span>:</div><div class="line"></div><div class="line">  docker swarm join \</div><div class="line">  <span class="comment">--token &lt;token&gt; \</span></div><div class="line">  &lt;myvm ip&gt;:&lt;port&gt;</div><div class="line"></div><div class="line">To <span class="built_in">add</span> <span class="keyword">a</span> manager <span class="built_in">to</span> this swarm, run <span class="string">'docker swarm join-token manager'</span> <span class="keyword">and</span> follow <span class="keyword">the</span> instructions.</div></pre></td></tr></table></figure><blockquote><p><strong>端口2377和2376</strong></p><p>始终使用端口2377（群管理端口）运行<code>docker swarm init</code>和<code>docker swarm join</code>，或根本不指定运行端口，并让其采用默认值。</p><p>由<code>docker-machine ls</code>返回的计算机IP地址包括端口2376，它是Docker守护进程端口。请勿使用此端口，否则<a href="https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2" target="_blank" rel="external">可能会遇到错误</a>。</p><p><strong>无法使用SSH？试试–native-ssh标志</strong></p><p>如果由于某些原因，您无法将命令发送给Swarm管理器，Docker Machine可以<a href="https://docs.docker.com/machine/reference/ssh/#different-types-of-ssh" target="_blank" rel="external">选择让您使用自己的系统的SSH</a>。只需在调用<code>ssh</code>命令时指定<code>--native-ssh</code>标志：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; docker-machine --<span class="keyword">native</span>-ssh ssh myvm1 ...</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>如您所见，对<code>docker swarm init</code>的响应包含一个预配置的<code>docker swarm join</code>命令，您可以在要添加的任何节点上运行该命令。复制这条命令，并通过<code>docker-machine ssh</code>发送到<code>myvm2</code>，使<code>myvm2</code>作为woker的角色来加入到你新创建的集群中。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh myvm2 <span class="string">"docker swarm join \</span></div><div class="line">--token &lt;token&gt; \</div><div class="line">&lt;ip&gt;:2377"</div><div class="line"></div><div class="line">This <span class="keyword">node</span> <span class="title">joined</span> a swarm as a worker.</div></pre></td></tr></table></figure><p>恭喜，您已经创建了您的第一个swarm集群！</p><p>在manager机器上运行<code>docker node ls</code>来查看swarm中的node：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh myvm1 <span class="string">"docker node ls"</span></div><div class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS</div><div class="line">brtu9urxwfd5j0zrmkubhpkbd     myvm2               Ready               <span class="keyword">Active</span></div><div class="line">rihwohkh3ph38fhillhhb84sk *   myvm1               Ready               <span class="keyword">Active</span>              Leader</div></pre></td></tr></table></figure><blockquote><p><strong>离开一个swarm</strong></p><p>如果你的某个节点想要退出集群，你可以在节点上运行<code>docker swarm leave</code>。</p></blockquote><h2 id="发布你的应用到swarm集群"><a href="#发布你的应用到swarm集群" class="headerlink" title="发布你的应用到swarm集群"></a>发布你的应用到swarm集群</h2><p>最困难的部分已经结束了。现在你只需重复第3部分用于部署新swarm的流程即可。请记住，只有像<code>myvm1</code>这样的群集管理器才能执行Docker命令；worker机器只是提供使用而已。</p><h3 id="为swarm-manager配置docker-machine-shell"><a href="#为swarm-manager配置docker-machine-shell" class="headerlink" title="为swarm manager配置docker-machine shell"></a>为swarm manager配置<code>docker-machine</code> shell</h3><p>到目前为止，你已经可以在<code>docker-machine ssh</code>中包裹Docker命令来在虚拟机上执行指令了。另一种选择是运行<code>docker-machine env &lt;machine&gt;</code>来获取并执行一个命令，该命令将当前shell配置为与虚拟机上的Docker守护进程进行通信。此方法对下一步更有利，因为它允许您使用本地<code>docker-compose.yml</code>文件“远程”部署应用程序，而无需将其复制到任何位置。</p><p>键入<code>docker-machine env myvm1</code>，然后复制粘贴并运行作为输出最后一行提供的命令，这样可以将shell配置为swarm manager可以与<code>myvm1</code>进行对话。</p><p>配置shell的命令根据你是Mac，Linux还是Windows而有所不同。</p><h4 id="Mac，Linux"><a href="#Mac，Linux" class="headerlink" title="Mac，Linux"></a>Mac，Linux</h4><p>Mac或Linux上的Docker Machine shell</p><p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker-machine env myvm1</div><div class="line"><span class="built_in">export</span> DOCKER_TLS_VERIFY=<span class="string">"1"</span></div><div class="line"><span class="built_in">export</span> DOCKER_HOST=<span class="string">"tcp://192.168.99.100:2376"</span></div><div class="line"><span class="built_in">export</span> DOCKER_CERT_PATH=<span class="string">"/Users/sam/.docker/machine/machines/myvm1"</span></div><div class="line"><span class="built_in">export</span> DOCKER_MACHINE_NAME=<span class="string">"myvm1"</span></div><div class="line"><span class="comment"># Run this command to configure your shell:</span></div><div class="line"><span class="comment"># eval $(docker-machine env myvm1)</span></div></pre></td></tr></table></figure><p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> myvm1)</div></pre></td></tr></table></figure><p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</div><div class="line">myvm1   *        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.100</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce   </div><div class="line">myvm2   -        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.101</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">PS </span>C:\<span class="string">Users\</span><span class="string">sam\</span><span class="string">sandbox\</span><span class="built_in">get-started&gt;</span> <span class="string">docker-machine </span><span class="string">env </span><span class="string">myvm1</span></div><div class="line">$<span class="string">Env:DOCKER_TLS_VERIFY </span>= <span class="string">"1"</span></div><div class="line">$<span class="string">Env:DOCKER_HOST </span>= <span class="string">"tcp://192.168.203.207:2376"</span></div><div class="line">$<span class="string">Env:DOCKER_CERT_PATH </span>= <span class="string">"C:\Users\sam\.docker\machine\machines\myvm1"</span></div><div class="line">$<span class="string">Env:DOCKER_MACHINE_NAME </span>= <span class="string">"myvm1"</span></div><div class="line">$<span class="string">Env:COMPOSE_CONVERT_WINDOWS_PATHS </span>= <span class="string">"true"</span></div><div class="line"><span class="comment"># Run this command to configure your shell:</span></div><div class="line"><span class="comment"># &amp; "C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe" env myvm1 | Invoke-Expression</span></div></pre></td></tr></table></figure><p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env myvm1 | Invoke-Expression</div></pre></td></tr></table></figure><p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PS C:PATH&gt; docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER   STATE     URL                          SWARM   DOCKER        ERRORS</div><div class="line">myvm1   *        hyperv   Running   tcp://<span class="number">192.168</span><span class="meta">.203</span><span class="meta">.207</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div><div class="line">myvm2   -        hyperv   Running   tcp://<span class="number">192.168</span><span class="meta">.200</span><span class="meta">.181</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div></pre></td></tr></table></figure><h3 id="在swarm-manager上发布应用"><a href="#在swarm-manager上发布应用" class="headerlink" title="在swarm manager上发布应用"></a>在swarm manager上发布应用</h3><p>现在你已经拥有了<code>myvm1</code>，你可以使用它的权力作为swarm manager来部署你的应用，方法是使用第三部分中的<code>docker stack deploy</code>命令将你的本地副本<code>docker-compose.yml</code>发布到<code>myvm1</code>。这个命令也许会花费几秒钟时间来完成这一操作，部署需要花一段时间才能完成。在swarm manager上使用<code>docker service ps &lt;service_name&gt;</code>命令验证所有服务是否已被重新部署。</p><p>您通过<code>docker-machine shell</code>配置链接到<code>myvm1</code>，并且您仍然可以访问本地主机上的文件。确保你和之前在同一个目录下，并且其中包括你在第3部分中创建的<code>docker-compose.yml</code>文件。</p><p>就像之前一样，运行以下命令在<code>myvm1</code>上部署应用程序。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div></pre></td></tr></table></figure><p>就是这样，该应用程序就成功部署在了swarm集群上了！</p><blockquote><p>注意：如果你的镜像保存在了一个私有仓库而不是Docker Hub上，你需要登录到通过命令<code>docker login &lt;your-registry&gt;</code>来登录到这个仓库，并且然后你需要在上面的命令添加<code>--with-registry-auth</code>指令。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker login registry<span class="selector-class">.example</span><span class="selector-class">.com</span></div><div class="line"></div><div class="line">docker stack deploy --with-registry-auth -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>这使用加密的WAL日志将登录令牌从本地客户端传递到部署服务的群集节点。有了这些信息，这些节点就能够登录到仓库并提取镜像。</p></blockquote><p>现在你可以使用Part3中的docker命令。只有这次注意到services（和相关容器）已经在<code>myvm1</code>和<code>myvm2</code>之间分配了。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ <span class="string">docker </span><span class="string">stack </span><span class="string">ps </span><span class="string">getstartedlab</span></div><div class="line"></div><div class="line"><span class="string">ID </span>           <span class="string">NAME </span>                 <span class="string">IMAGE </span>                  <span class="string">NODE </span>  <span class="string">DESIRED </span><span class="string">STATE</span></div><div class="line"><span class="string">jq2g3qp8nzwx </span> <span class="string">getstartedlab_web.</span>1   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm1 </span> <span class="string">Running</span></div><div class="line"><span class="string">88wgshobzoxl </span> <span class="string">getstartedlab_web.</span>2   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm2 </span> <span class="string">Running</span></div><div class="line"><span class="string">vbb1qbkb0o2z </span> <span class="string">getstartedlab_web.</span>3   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm2 </span> <span class="string">Running</span></div><div class="line"><span class="string">ghii74p9budx </span> <span class="string">getstartedlab_web.</span>4   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm1 </span> <span class="string">Running</span></div><div class="line"><span class="string">0prmarhavs87 </span> <span class="string">getstartedlab_web.</span>5   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm2 </span> <span class="string">Running</span></div></pre></td></tr></table></figure><blockquote><p><strong>使用<code>docker-machine env</code>和<code>docker-machine ssh</code>连接到VM</strong></p><ul><li><p>要将shell设置为与<code>myvm2</code>等其他机器通信，只需在相同或不同的shell中重新运行<code>docker-machine env</code>，然后运行给定的命令以指向<code>myvm2</code>。这里指的是当前的shell。如果你更改为未配置的shell或打开一个新的shell，则需要重新运行这些命令。使用<code>docker-machine ls</code>列出机器列表，查看它们所处的状态，获取IP地址，如果有的话，并找出具体连接到的是哪一个地址。更多请参阅<a href="https://docs.docker.com/machine/get-started/#create-a-machine" target="_blank" rel="external">Docker Machine getting started topics</a>。</p></li><li><p>或者，你可以以<code>docker-machine ssh &lt;machine&gt; &quot;&lt;command&gt;&quot;</code>的形式来打包Docker命令，该命令可以直接登陆到VM，但不会立即访问本地主机上的文件。</p></li><li><p>在Mac和Linux上，你可以使用<code>docker-machine scp &lt;file&gt; &lt;machine&gt;:~</code>来在机器间复制文件，但在Windows上，需要使用一个Linux类似<a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git Bash</a>的终端模拟器来完成这类工作。</p></li></ul><p>本教程演示了<code>docker-machine ssh</code>和<code>docker-machine env</code>因为这些都可以通过<code>docker-machine</code>CLI在平台上使用。</p></blockquote><h3 id="访问你的集群"><a href="#访问你的集群" class="headerlink" title="访问你的集群"></a>访问你的集群</h3><p>你可以从<code>myvm1</code>或<code>myvm2</code>的IP地址访问您的应用程序。</p><p>你创建的网络在它们之间共享负载均衡。运行<code>docker-machine ls</code>来获取你的VM的IP地址，并通过浏览器访问其中的任何一个，点击刷新（或者仅仅使用<code>curl</code>来访问）</p><p><img src="/img/18_04_26/002.png" alt=""></p><p>有五个可能的容器ID全部随机循环，体现了负载均衡。</p><p>两个IP地址工作的原因是群中的节点参与<strong>入口路由网格</strong>。这可以确保部署在集群中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。以下是三节点swarm的端口8080上发布的名为<code>my-web</code>的服务的路由网络示意图：</p><p><img src="/img/18_04_26/003.png" alt=""></p><blockquote><p><strong>连接有问题？</strong></p><p>请记住，要使用swarm中的入口网络，在启用swarm模式之前，需要在swarm节点之间打开以下端口：</p><ul><li>端口7946 TCP/UDP （用于容器网络发现）</li><li>端口4789 UDP （用于容器入口网络）</li></ul></blockquote><h2 id="迭代和缩放你的应用程序"><a href="#迭代和缩放你的应用程序" class="headerlink" title="迭代和缩放你的应用程序"></a>迭代和缩放你的应用程序</h2><p>在这里，你可以完成你在Part2和Part3中学到的一切。</p><p>通过修改<code>docker-compose.yml</code>文件，可以缩放应用程序。</p><p>通过编辑代码，来改变应用的行为，然后重新构建，并将新的镜像push上去。（要做到这一点，请按照之前用于构建应用程序和发布镜像的相同步骤）。</p><p>无论是哪种情况，只需要通过再次运行<code>docker stack deploy</code>就可以发布这些变更。</p><p>你可以加入任何虚拟的或物理的机器到这个swarm中，对<code>myvm2</code>使用相同的<code>docker swarm join</code>命令，然后集群的容量就被扩大了。在运行<code>docker stack deploy</code>之后，你的应用程序就可以利用到这些资源了。</p><h2 id="清空并重启"><a href="#清空并重启" class="headerlink" title="清空并重启"></a>清空并重启</h2><h3 id="堆栈和swarm"><a href="#堆栈和swarm" class="headerlink" title="堆栈和swarm"></a>堆栈和swarm</h3><p>你可以通过运行<code>docker stack rm</code>来卸下堆栈。例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> getstartedlab</div></pre></td></tr></table></figure><blockquote><p><strong>保留或删除swarm</strong>？</p><p>在稍后，如果您想要使某个worker离开swarm，可以在worker上使用<code>docker-machine ssh myvm2 &quot;docker swarm leave&quot;</code>来卸下woker，如果是manager的话，可以这样执行<code>docker-machine ssh myvm1 &quot;docker swarm leave --force&quot;</code>，但在后面的Part5的教学中，你还需要它，所以暂时保留。</p></blockquote><h3 id="重置docker-machine-shell变量设置"><a href="#重置docker-machine-shell变量设置" class="headerlink" title="重置docker-machine shell变量设置"></a>重置docker-machine shell变量设置</h3><p>你可以通过你当前的shell执行以下命令来重置<code>docker-machine</code>环境变量。</p><p>在Mac或Linux上，命令如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> -u)</div></pre></td></tr></table></figure><p>在Windows上，命令如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env -u | Invoke-Expression</div></pre></td></tr></table></figure><p>这将shell与<code>docker-machine</code>创建的虚拟机断开连接，并允许你继续在同一个shell中工作，现在使用本机docker命令。更多信息，请见<a href="https://docs.docker.com/machine/get-started/#unset-environment-variables-in-the-current-shell" target="_blank" rel="external">Machine topic on unsetting environment variables</a>。</p><p>重启Docker machines</p><p>如果你关闭本地主机，Docker machines将停止运行。你可以通过运行<code>docker-machine ls</code>来检查机器运行的状态。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls</div><div class="line"><span class="built_in">NAME</span>    ACTIVE   <span class="built_in">DRIVER</span>       STATE     URL   SWARM   DOCKER    ERRORS</div><div class="line">myvm1   -        virtualbox   <span class="built_in">Stopped</span>                 Unknown</div><div class="line">myvm2   -        virtualbox   <span class="built_in">Stopped</span>                 Unknown</div></pre></td></tr></table></figure><p>重启已经停止的机器，运行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine <span class="keyword">start</span> &lt;machine-<span class="keyword">name</span>&gt;</div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ docker-machine <span class="built_in">start</span> myvm1</div><div class="line">Starting <span class="string">"myvm1"</span>...</div><div class="line">(myvm1) Check network <span class="built_in">to</span> re-<span class="built_in">create</span> <span class="keyword">if</span> needed...</div><div class="line">(myvm1) Waiting <span class="keyword">for</span> <span class="keyword">an</span> IP...</div><div class="line">Machine <span class="string">"myvm1"</span> was started.</div><div class="line">Waiting <span class="keyword">for</span> SSH <span class="built_in">to</span> be available...</div><div class="line">Detecting <span class="keyword">the</span> provisioner...</div><div class="line">Started machines may have <span class="built_in">new</span> IP addresses. You may need <span class="built_in">to</span> re-run <span class="keyword">the</span> `docker-machine env` <span class="keyword">command</span>.</div><div class="line"></div><div class="line">$ docker-machine <span class="built_in">start</span> myvm2</div><div class="line">Starting <span class="string">"myvm2"</span>...</div><div class="line">(myvm2) Check network <span class="built_in">to</span> re-<span class="built_in">create</span> <span class="keyword">if</span> needed...</div><div class="line">(myvm2) Waiting <span class="keyword">for</span> <span class="keyword">an</span> IP...</div><div class="line">Machine <span class="string">"myvm2"</span> was started.</div><div class="line">Waiting <span class="keyword">for</span> SSH <span class="built_in">to</span> be available...</div><div class="line">Detecting <span class="keyword">the</span> provisioner...</div><div class="line">Started machines may have <span class="built_in">new</span> IP addresses. You may need <span class="built_in">to</span> re-run <span class="keyword">the</span> `docker-machine env` <span class="keyword">command</span>.</div></pre></td></tr></table></figure><h2 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h2><p>在part4部分，你学习到了什么是swarm，节点在swarm中可以作为worker，也可以作为manager，创建一个swarm，并在上面发布一个应用。你看到Docker的核心命令和part3中并没有什么不同，他们只需要将目标锁定在swarm主机上运行。你还看到了Docker网络的力量，即使它们运行在不同的机器上，也可以跨容器保持请求负载均衡。最后，你学习了如何在集群上迭代和缩放应用程序。以下是您可能想要运行的命令：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver virtualbox myvm1 # Create a VM (<span class="keyword">Mac</span>, Win7, Linux)</div><div class="line">docker-machine create -<span class="keyword">d</span> hyperv --hyperv-virtual-switch <span class="string">"myswitch"</span> myvm1 # Win10</div><div class="line">docker-machine env myvm1                # <span class="keyword">View</span> basic information <span class="keyword">about</span> your node</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker node ls"</span>         # <span class="keyword">List</span> the nodes <span class="keyword">in</span> your swarm</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker node inspect &lt;node ID&gt;"</span>        # <span class="keyword">Inspect</span> a node</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker swarm join-token -q worker"</span>   # <span class="keyword">View</span> join <span class="keyword">token</span></div><div class="line">docker-machine ssh myvm1   # <span class="keyword">Open</span> <span class="keyword">an</span> SSH session with the VM; <span class="keyword">type</span> <span class="string">"exit"</span> to end</div><div class="line">docker node <span class="keyword">ls</span>                # <span class="keyword">View</span> nodes <span class="keyword">in</span> swarm (<span class="keyword">while</span> logged <span class="keyword">on</span> to manager)</div><div class="line">docker-machine ssh myvm2 <span class="string">"docker swarm leave"</span>  # Make the worker leave the swarm</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker swarm leave -f"</span> # Make master leave, kill swarm</div><div class="line">docker-machine <span class="keyword">ls</span> # <span class="keyword">list</span> VMs, asterisk shows <span class="keyword">which</span> VM this <span class="keyword">shell</span> is talking to</div><div class="line">docker-machine start myvm1            # Start a VM that is currently not running</div><div class="line">docker-machine env myvm1      # show environment variables and command <span class="keyword">for</span> myvm1</div><div class="line">eval $(docker-machine env myvm1)         # <span class="keyword">Mac</span> command to connect <span class="keyword">shell</span> to myvm1</div><div class="line">&amp; <span class="string">"C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe"</span> env myvm1 | Invoke-Expression   # Windows command to connect <span class="keyword">shell</span> to myvm1</div><div class="line">docker <span class="keyword">stack</span> deploy -c &lt;<span class="keyword">file</span>&gt; &lt;<span class="keyword">app</span>&gt;  # Deploy <span class="keyword">an</span> <span class="keyword">app</span>; command <span class="keyword">shell</span> must be <span class="keyword">set</span> to talk to manager (myvm1), uses <span class="keyword">local</span> Compose <span class="keyword">file</span></div><div class="line">docker-machine scp docker-compose.yml myvm1:~ # <span class="keyword">Copy</span> <span class="keyword">file</span> to node's home <span class="keyword">dir</span> (only required <span class="keyword">if</span> you <span class="keyword">use</span> ssh to connect to manager and deploy the <span class="keyword">app</span>)</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker stack deploy -c &lt;file&gt; &lt;app&gt;"</span>   # Deploy <span class="keyword">an</span> <span class="keyword">app</span> using ssh (you must have first copied the Compose <span class="keyword">file</span> to myvm1)</div><div class="line">eval $(docker-machine env -<span class="keyword">u</span>)     # Disconnect <span class="keyword">shell</span> from VMs, <span class="keyword">use</span> native docker</div><div class="line">docker-machine stop $(docker-machine <span class="keyword">ls</span> -q)               # Stop all running VMs</div><div class="line">docker-machine <span class="keyword">rm</span> $(docker-machine <span class="keyword">ls</span> -q) # Delete all VMs and their disk images</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part3-服务</title>
      <link>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part3-%E6%9C%8D%E5%8A%A1/</link>
      <guid>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part3-%E6%9C%8D%E5%8A%A1/</guid>
      <pubDate>Thu, 26 Apr 2018 02:12:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compose</a>。在<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Docker for Mac</a>和<a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="external">Docker for Windows</a>中，它已预先安装，这一步很方便。在Linux系统上，您需要<a href="https://github.com/docker/compose/releases" target="_blank" rel="external">直接安装它</a>。在没有<em>Hyper-V</em>的Windows 10系统上，使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">Docker Toolbox</a>。</li><li>阅读Part1部分。</li><li>学习Part2中如何创建容器。</li><li>确定你已经通过<a href="https://docs.docker.com/get-started/part2/#share-your-image" target="_blank" rel="external">上传到仓库</a>的方式发布了<code>friendlyhello</code>镜像。我们在这里使用共享镜像。</li><li>确定你的镜像作为一个已部署的容器。运行下面这条命令，插入你的<code>username</code>、<code>repo</code>、和<code>tag</code>:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在第三部分，我们将扩展我们的应用并实现负载均衡。为了做到这一点，我们必须在分布式应用程序的层次结构中升一级：<strong>service(服务)</strong>。</p><ul><li>Stack</li><li><strong>Services(服务 你在这里)</strong></li><li>Container（参见 part2）</li></ul><h2 id="关于Services"><a href="#关于Services" class="headerlink" title="关于Services"></a>关于Services</h2><p>在一个分布式应用中，应用的不同部分被称为”services”。例如，想象你有一个影片分享站点，它也许包括一个关于将应用数据存储在数据库中的service，一个在用户上传一些东西之后在后台对其进行转码操作的service，一个前端的服务，等等。</p><p>Services实际上只是“生产中的容器”。service只运行一个镜像，但用于编纂镜像的运行方式–应该使用哪个端口，应该运行多少个容器副本以便服务具有所需的容量，等等。缩放service会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多计算资源。</p><p>幸运的是，使用Docker平台定义，运行和扩展services非常简单 – 仅仅写一个<code>docker-compose.yml</code>文件即可。</p><h2 id="你的第一个docker-compose-yml文件"><a href="#你的第一个docker-compose-yml文件" class="headerlink" title="你的第一个docker-compose.yml文件"></a>你的第一个<code>docker-compose.yml</code>文件</h2><p>一个<code>docker-compose.yml</code>文件是一个用于定义Docker容器在生产环境中的行为的YAML文件。</p><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a><code>docker-compose.yml</code></h3><p>将此文件另存为<code>docker-compose.yml</code>，无论你在哪里。确保您已将第2部分中创建的镜像推送到注册表中，并通根据你的镜像的具体的信息替换掉<code>username/repo:tag</code>部分来更新此<code>.yml</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">version</span>: <span class="string">"3"</span></div><div class="line"><span class="attribute">services</span>:</div><div class="line">  <span class="attribute">web</span>:</div><div class="line">    # replace username/<span class="attribute">repo</span>:tag with your name and image details</div><div class="line">    <span class="attribute">image</span>: username/<span class="attribute">repo</span>:tag</div><div class="line">    <span class="attribute">deploy</span>:</div><div class="line">      <span class="attribute">replicas</span>: <span class="number">5</span></div><div class="line">      <span class="attribute">resources</span>:</div><div class="line">        <span class="attribute">limits</span>:</div><div class="line">          <span class="attribute">cpus</span>: <span class="string">"0.1"</span></div><div class="line">          <span class="attribute">memory</span>: <span class="number">50</span>M</div><div class="line">      <span class="attribute">restart_policy</span>:</div><div class="line">        <span class="attribute">condition</span>: on-failure</div><div class="line">    <span class="attribute">ports</span>:</div><div class="line">      - <span class="string">"80:80"</span></div><div class="line">    <span class="attribute">networks</span>:</div><div class="line">      - webnet</div><div class="line"><span class="attribute">networks</span>:</div><div class="line">  <span class="attribute">webnet</span>:</div></pre></td></tr></table></figure><p>这个<code>docker-compose.yml</code>文件告诉Docker要做以下事情：</p><ul><li>按照Part2中的方式从仓库中下拉我们的镜像。</li><li>运行镜像的5个实例作为一个名为<code>web</code>的service，限制每个实例，最多占用10%CPU(所有的核)、50MB的RAM。</li><li>如果一个容器失败了立刻重启。</li><li>将主机上的端口80映射到<code>web</code>的端口80。</li><li>指示<code>web</code>容器通过名为<code>webnet</code>负载均衡网络共享80端口。（在内部，容器本身在临时端口上发布到<code>web</code>的80端口）。</li><li>使用默认设置（这是一个负载均衡覆盖网络）定义<code>webnet</code>网络。</li></ul><h2 id="运行你的全新的负载均衡应用"><a href="#运行你的全新的负载均衡应用" class="headerlink" title="运行你的全新的负载均衡应用"></a>运行你的全新的负载均衡应用</h2><p>在我们可以使用<code>docker stack deploy</code>命令之前，我们首先运行：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">swarm </span>init</div></pre></td></tr></table></figure><blockquote><p>注意：我们在Part4部分深入了解该命令的含义。如果你不运行<code>docker swarm init</code>命令的话，你会得到这样一条错误信息：”this node is not a swarm manager.”。</p></blockquote><p>现在，让我们来运行它吧。你需要给你的应用起一个名字。这里我们起名为<code>getstartedlab</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div></pre></td></tr></table></figure><p>我们的单个service堆栈在一台主机上运行了5个部署映像的容器实例。让我们来进一步了解。</p><p>在我们的应用程序中获取一项service的service ID：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service <span class="keyword">ls</span></div></pre></td></tr></table></figure><p>查找<code>web</code>service的输出信息，找到那个以你的应用程序名称作为前缀信息。如果您将其命名为与此示例中显示的相同，那么这里的名称为<code>getstartedlab_web</code>。还列出了service ID以及副本数量，镜像名称和对外暴露的端口。</p><p>在service中运行的单个容器称为<strong>task(任务)</strong>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">docker</span> service ps getstartedlab_web</div></pre></td></tr></table></figure><p>如果您只列出系统中的所有容器，任务也会显示出来，它不会被service所过滤：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">container</span> <span class="keyword">ls</span> -q</div></pre></td></tr></table></figure><p>你可以运行几次<code>curl -4 http://localhost</code>，或者通过浏览器打开这个链接尝试刷新几次。</p><p><img src="/img/18_04_26/001.png" alt=""></p><p>无论哪种方式，容器ID都会发生变化，从而显示负载均衡;在每个请求中，以循环方式选择5个任务中的一个来响应。容器ID与前一个命令(<code>docker container ls -q</code>)的输出相匹配。</p><blockquote><p><strong>在Windows10下运行？</strong></p><p>Windows10的PowerShell可以使用<code>curl</code>命令，但如果不行的话，你可以尝试获取一个Linux终端模拟器，例如<a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git BASH</a>或者下载很相似的<a href="http://gnuwin32.sourceforge.net/packages/wget.htm" target="_blank" rel="external">wget for Windows</a>。</p><p><strong>响应时间慢？</strong></p><p>根据您的环境的网络配置，容器可能需要长达30秒才能响应HTTP请求。这并不代表Docker或群集性能，而是我们稍后在本教程中讨论的未满足的Redis依赖项。就目前而言，访客柜台并不是出于同样的原因;我们还没有添加service来保存数据。</p></blockquote><h2 id="扩展应用程序"><a href="#扩展应用程序" class="headerlink" title="扩展应用程序"></a>扩展应用程序</h2><p>你可以通过修改<code>docker-compose.yml</code>中<code>replicas</code>的值来扩展应用，保存<code>docker-compose.yml</code>的改变之后，重新运行<code>docker stack deploy</code>命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div></pre></td></tr></table></figure><p>Docker执行一个就地更新，不需要先撤下堆栈或杀死任何容器。</p><p>现在，重新运行<code>docker container ls -q</code>以查看重新配置的已部署实例。如果您扩大副本，则会启动更多任务，因此还会启动更多容器。</p><h3 id="撤下应用和swarm"><a href="#撤下应用和swarm" class="headerlink" title="撤下应用和swarm"></a>撤下应用和swarm</h3><ul><li>通过指令<code>docker stack rm</code>来撤下应用：</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> getstartedlab</div></pre></td></tr></table></figure><ul><li>撤下swarm</li></ul><figure class="highlight nsis"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker swarm <span class="literal">leave</span> --<span class="literal">force</span></div></pre></td></tr></table></figure><p>用Docker新建并扩展您的应用程序非常简单。您已经朝着学习如何在生产中运行容器迈出了一大步。接下来，您将学习如何将这个应用程序作为Docker机器群集上的真正群体运行。</p><blockquote><p>注意：像这里的Compose文件是用于通过Docker来定义应用程序，并且可以通过<a href="https://docs.docker.com/docker-cloud/" target="_blank" rel="external">Docker Cloud</a>上传到云端，或者任何带有<a href="https://www.docker.com/enterprise-edition" target="_blank" rel="external">Docker 企业版</a>的云服务上。</p></blockquote><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>总而言之，在输入<code>docker run</code>运行时非常简单，生产中的容器真正实现将其作为服务运行。服务在Compose文件中编写容器的行为，此文件可用于缩放，限制和重新部署我们的应用程序。对服务的更改可以在运行时适用，使用启动服务的相同命令：<code>docker stack deploy</code>。</p><p>现阶段需要学习的一些命令：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">ls</span>                                            # <span class="keyword">List</span> stacks or apps</div><div class="line">docker <span class="keyword">stack</span> deploy -c &lt;composefile&gt; &lt;appname&gt;  # <span class="keyword">Run</span> the specified Compose <span class="keyword">file</span></div><div class="line">docker service <span class="keyword">ls</span>                 # <span class="keyword">List</span> running services associated with <span class="keyword">an</span> <span class="keyword">app</span></div><div class="line">docker service ps &lt;service&gt;                  # <span class="keyword">List</span> tasks associated with <span class="keyword">an</span> <span class="keyword">app</span></div><div class="line">docker <span class="keyword">inspect</span> &lt;task or container&gt;                   # <span class="keyword">Inspect</span> task or container</div><div class="line">docker container <span class="keyword">ls</span> -q                                      # <span class="keyword">List</span> container IDs</div><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> &lt;appname&gt;                             # Tear down <span class="keyword">an</span> application</div><div class="line">docker swarm leave --force      # Take down a single node swarm from the manager</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part3-%E6%9C%8D%E5%8A%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part2-容器</title>
      <link>http://studyai.site/2018/04/25/Docker%E5%85%A5%E9%97%A8Part2-%E5%AE%B9%E5%99%A8/</link>
      <guid>http://studyai.site/2018/04/25/Docker%E5%85%A5%E9%97%A8Part2-%E5%AE%B9%E5%99%A8/</guid>
      <pubDate>Wed, 25 Apr 2018 08:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot; t
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li><a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">安装Docker1.13或更高版本</a>。</li><li>阅读Part1部分。</li><li>让您的环境快速测试运行，以确保您全部设置完毕：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">run</span> hello-world</div></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现在是开始以Docker方式构建应用程序的时候了。我们从这种应用程序的层次结构的容器的底部开始，进行详细介绍。在这个层次上面是一个服务，它定义了容器在生产中的行为方式，如Part3部分所述。最后，在顶层的堆栈部分定义了Part5部分中涵盖的所有服务的交互。</p><ul><li>Stack （堆栈）</li><li>Services （服务）</li><li><strong>Container</strong>（容器，你在这里）</li></ul><h2 id="您的新开发环境"><a href="#您的新开发环境" class="headerlink" title="您的新开发环境"></a>您的新开发环境</h2><p>之前，如果您要开始编写Python应用程序，您第一个要做的事情就是在您的机器上安装Python运行环境。但是，这会造成您的计算机上的环境需要完美适合您的应用程序按预期运行，并且还需要与您的生产环境相匹配。</p><p>使用Docker，您可以将一个可移植的Python运行环境作为一个镜像获取，无需安装。然后，您的构建可以将基础Python镜像与应用程序代码一起包括在内，确保您的应用程序，依赖项和运行环境都在一起。</p><p>这些可移植的镜像是由称为<code>Dockerfile</code>的东西定义的。</p><h2 id="通过Dockerfile定义一个容器"><a href="#通过Dockerfile定义一个容器" class="headerlink" title="通过Dockerfile定义一个容器"></a>通过<code>Dockerfile</code>定义一个容器</h2><p><code>Dockerfile</code>定义了容器内的环境发生的事情。像访问网络接口以及磁盘驱动器等资源是在此环境内虚拟化的，这与系统的其余部分是隔离开的，因此您需要将端口映射到外部世界，并明确指定要将哪些文件“复制”到该环境中。但是，在完成这些之后，您可以预期，在此<code>Dockerfile</code>中定义的应用程序构建在运行时的行为完全相同。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><code>Dockerfile</code></h3><p>创建一个空目录。改变目录(<code>cd</code>)到这个新的目录下，创建一个叫做<code>Dockerfile</code>的文件，将下面的内容复制粘贴到这个文件中，并保存。注意记下<code>Dockerfile</code>中的注释部分。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use an official Python runtime as a parent image</span></div><div class="line"><span class="comment"># 使用一个官方的Python运行时环境作为父镜像</span></div><div class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</div><div class="line"></div><div class="line"><span class="comment"># Set the working directory to /app</span></div><div class="line"><span class="comment"># 设置工作目录到/app目录下</span></div><div class="line"><span class="keyword">WORKDIR</span> <span class="bash">/app</span></div><div class="line"></div><div class="line"><span class="comment"># Copy the current directory contents into the container at /app</span></div><div class="line"><span class="comment"># 复制当前目录内容到容器的/app目录下</span></div><div class="line"><span class="keyword">ADD</span> <span class="bash">. /app</span></div><div class="line"></div><div class="line"><span class="comment"># Install any needed packages specified in requirements.txt</span></div><div class="line"><span class="comment"># 安装所有requirements.txt中指定的需要的包</span></div><div class="line"><span class="keyword">RUN</span> <span class="bash">pip install --trusted-host pypi.python.org -r requirements.txt</span></div><div class="line"></div><div class="line"><span class="comment"># Make port 80 available to the world outside this container</span></div><div class="line"><span class="comment"># 使得该容器的80端口对外可用</span></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></div><div class="line"></div><div class="line"><span class="comment"># Define environment variable</span></div><div class="line"><span class="comment"># 定义环境变量</span></div><div class="line"><span class="keyword">ENV</span> NAME World</div><div class="line"></div><div class="line"><span class="comment"># Run app.py when the container launches</span></div><div class="line"><span class="comment"># 当容器加载时，运行app.py</span></div><div class="line"><span class="keyword">CMD</span> <span class="bash">[<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></div></pre></td></tr></table></figure><p>这个<code>Dockerfile</code>提到了我们尚未创建的两个文件，名叫<code>app.py</code>和<code>requirements.txt</code>。接下来让我们来创建出来。</p><h2 id="应用程序本身"><a href="#应用程序本身" class="headerlink" title="应用程序本身"></a>应用程序本身</h2><p>创建两个文件<code>requirements.txt</code>和<code>app.py</code>，并把他们放在和<code>Dockerfile</code>相同的目录下。这就完成了我们的应用程序，正如你看到的一样，非常简单。当上面的<code>Dockerfile</code>被内置到镜像中时，由于<code>Dockerfile</code>的<code>ADD</code>命令，<code>app.py</code>和<code>requirements.txt</code>存在，并且<code>app.py</code>的输出可以通过HTTP访问，这要归功于<code>EXPOSE</code>命令。</p><h3 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a><code>requirements.txt</code></h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Flask</span></div><div class="line">Redis</div></pre></td></tr></table></figure><h3 id="app-py"><a href="#app-py" class="headerlink" title="app.py"></a><code>app.py</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis, RedisError</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line"><span class="comment"># Connect to Redis</span></div><div class="line">redis = Redis(host=<span class="string">"redis"</span>, db=<span class="number">0</span>, socket_connect_timeout=<span class="number">2</span>, socket_timeout=<span class="number">2</span>)</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        visits = redis.incr(<span class="string">"counter"</span>)</div><div class="line">    <span class="keyword">except</span> RedisError:</div><div class="line">        visits = <span class="string">"&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;"</span></div><div class="line"></div><div class="line">    html = <span class="string">"&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;"</span> \</div><div class="line">           <span class="string">"&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;"</span> \</div><div class="line">           <span class="string">"&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;"</span></div><div class="line">    <span class="keyword">return</span> html.format(name=os.getenv(<span class="string">"NAME"</span>, <span class="string">"world"</span>), hostname=socket.gethostname(), visits=visits)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">80</span>)</div></pre></td></tr></table></figure><p>现在我们看到<code>pip install -r requirements.txt</code>命令安装了Python的Flask和Redis库，并且应用打印出了环境变量<code>NAME</code>，同时输出了方法<code>socket.gethostname()</code>输出的内容。最后，因为Redis没有运行（因为我们只安装了Python库，而不是Redis本身），所以这里应该会失败，并产生错误消息。</p><blockquote><p>注意：在容器内部访问主机的名称将检索容器ID，这与正在运行的可执行文件的进程ID相似。</p></blockquote><p>就是这样！你的系统上不需要Python或者任何<code>requirements.txt</code>文件，也不需要在你的系统上安装或运行此镜像。这看起来你并没有真正用Python和Flask建立一个运行环境，但事实上已经建立好了。</p><h2 id="构建一个应用"><a href="#构建一个应用" class="headerlink" title="构建一个应用"></a>构建一个应用</h2><p>我们准备构建应用程序。确保您仍然处于新目录的顶层。以下是<code>ls</code>命令应该显示的内容：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">ls</span></div><div class="line">Dockerfile<span class="keyword">app</span>.pyrequirements.txt</div></pre></td></tr></table></figure><p>现在运行build命令。这会创建一个Docker镜像，我们将使用<code>-t</code>标记它，这样可以给它指定一个友好的名称。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t friendlyhello .</div></pre></td></tr></table></figure><p>你构建的镜像在哪里？它在你的机器的本地Docker镜像注册表中：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line"></div><div class="line">REPOSITORY            <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID</div><div class="line">friendlyhello         latest</div></pre></td></tr></table></figure><blockquote><p>Linux用户的故障排除</p><p><em>DNS设置</em></p><p>代理服务器在启动并运行后可以阻止与您的网络应用程序的连接。如果您位于代理服务器的后面，请使用<code>ENV</code>命令为您的代理服务器指定主机和端口，将以下行添加到<code>Dockerfile</code>中：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Set proxy server, replace host:port with values for your servers</span></div><div class="line"><span class="keyword">ENV</span> http_proxy host:port</div><div class="line"><span class="keyword">ENV</span> https_proxy host:port</div></pre></td></tr></table></figure><p><em>代理服务设置</em></p><p>DNS错误配置可能会导致<code>pip</code>出现问题。您需要设置您自己的DNS服务器地址以使<code>pip</code>正常工作。您可能需要更改Docker守护程序的DNS设置。您可以按照以下方式来编辑（或者创建）带有<code>dns</code>信息的配置文件<code>/etc/docker/daemon.json</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"dns"</span>: [<span class="string">"your_dns_address"</span>, <span class="string">"8.8.8.8"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面的例子中，列表的第一个元素是你的DNS服务器的地址。第二项是Google的DNS，当第一项不可用时可以使用它。</p><p>在继续之前，保存`daemon.json并重新启动docker服务。</p><p><code>sudo service docker restart</code></p><p>修复后，重试运行<code>build</code>命令。</p></blockquote><h2 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h2><p>运行应用程序，使用<code>-p</code>将机器的端口4000映射到容器的已发布端口<code>80</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -<span class="selector-tag">p</span> <span class="number">4000</span>:<span class="number">80</span> friendlyhello</div></pre></td></tr></table></figure><p>你可以在<code>http://0.0.0.0:80</code>看到一条消息，Python正在为你的应用程序提供服务。但是，该消息来自容器内部，它不知道您将该容器的端口<code>80</code>映射到<code>4000</code>，从而制作正确的URL<code>http://localhost:4000</code>。</p><p>在网络浏览器中转到该URL以查看网页上显示的显示内容。</p><p><img src="/img/18_04_25/004.png" alt=""></p><blockquote><p>注意：如果你正在在Windows7上使用Docker Toolbox，使用Docker Machine IP来替代<code>localhost</code>。例如：<a href="http://192.168.99.100:4000/。要查找IP地址，请使用该命令`docker-machine" target="_blank" rel="external">http://192.168.99.100:4000/。要查找IP地址，请使用该命令`docker-machine</a> ip`。</p></blockquote><p>您也可以在shell中使用<code>curl</code>命令来查看相同的内容。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl http:<span class="comment">//localhost:4000</span></div><div class="line"></div><div class="line"><span class="params">&lt;h3&gt;</span>Hello World!<span class="params">&lt;/h3&gt;</span><span class="params">&lt;b&gt;</span>Hostname:<span class="params">&lt;/b&gt;</span> <span class="number">8f</span>c990912a14<span class="params">&lt;br/&gt;</span><span class="params">&lt;b&gt;</span>Visits:<span class="params">&lt;/b&gt;</span> <span class="params">&lt;i&gt;</span>cannot connect to Redis, counter disabled<span class="params">&lt;/i&gt;</span></div></pre></td></tr></table></figure><p>这个<code>4000:80</code>的端口重映射是为了演示<code>Dockerfile</code>中的<code>EXPOSE</code>与使用<code>docker run -p</code>发布的内容之间的区别。在后面的步骤中，我们只需将主机上的端口80映射到容器中的端口80并使用<code>http://localhost</code>。</p><p>在终端中点击<code>CTRL + C</code>退出。</p><blockquote><p><strong>在Windows下，显式的停止容器</strong></p><p>在Windows系统下，<code>CTRL+C</code>不会停止容器。到目前为止，首先键入<code>CTRL+C</code>以获取提示（或打开另一个shell），然后输入<code>docker container ls</code>来列出运行中的容器，其次是<code>docker container stop &lt;Container NAME or ID&gt;</code>来停止容器。否则，你会在下一步重新运行容器时得到一个来自守护进程的错误消息。</p></blockquote><p>现在让我们以分离模式在后台运行应用程序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -<span class="selector-tag">p</span> <span class="number">4000</span>:<span class="number">80</span> friendlyhello</div></pre></td></tr></table></figure><p>您可以获取应用的长容器ID，然后将其显示到终端。你的容器在后台运行。你也可以通过<code>docker container ls</code>来看到简短的容器ID（并且在运行命令时可以互换使用）。</p><p>注意到<code>CONTAINER ID</code>与<code>http://localhost:4000</code>上的内容匹配。</p><p>现在我们使用<code>docker container stop</code>来结束指定<code>CONTAINER ID</code><br>的进程，像这样：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container <span class="built_in">stop</span> <span class="number">1</span>fa4ab2cf395</div></pre></td></tr></table></figure><h2 id="分享你的image"><a href="#分享你的image" class="headerlink" title="分享你的image"></a>分享你的image</h2><p>为了演示我们刚才创建的可移植性，我们上传我们构建的镜像并在其他地方运行它。毕竟，当您想要将容器部署到生产环境时，您需要知道如何推送注册表。</p><p>注册表是存储库的集合，而存储库是镜像的集合 - 有点像GitHub存储库，但不同的是这里代码已经创建。注册表上的帐户可以创建许多存储库。 <code>docker</code> CLI默认使用Docker的公共注册表。</p><blockquote><p>注意：我们在这里使用Docker的公共注册表仅仅是因为它是免费和预先配置的，但是有许多公共选项可供选择，您甚至可以使用<a href="https://docs.docker.com/datacenter/dtr/2.2/guides/" target="_blank" rel="external">Docker Trusted Registry</a>设置您自己的私有注册表。</p></blockquote><h3 id="登录你的Docker-ID"><a href="#登录你的Docker-ID" class="headerlink" title="登录你的Docker ID"></a>登录你的Docker ID</h3><p>如果你没有Docker账号，需要在<a href="cloud.docker.com">cloud.docker.com</a>上注册一个。记下你的用户名。</p><p>登录到本地计算机上的Docker公共注册表。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>docker login</div></pre></td></tr></table></figure><h3 id="给镜像打标签"><a href="#给镜像打标签" class="headerlink" title="给镜像打标签"></a>给镜像打标签</h3><p>将本地镜像与注册表中的存储库相关联的符号是<code>username/repository:tag</code>。该tag是可选的，但建议使用，因为它是注册管理机构用于为Docker镜像提供版本的机制。为该上下文提供存储库并标记有意义的名称，例如<code>get-started:part2</code>。这将镜像置于启动存储库中，并将其标记为<code>part2</code>。</p><p>现在，给镜像整体的打上标签。带入你的用户名、仓库名、和标签名运行<code>docker tag image</code>以便将镜像上传到你想要的地址。命令的语法如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">tag</span> <span class="title">image</span> username/repository:<span class="keyword">tag</span></div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">tag</span> <span class="title">friendlyhello</span> john/get-<span class="literal">started</span>:part2</div></pre></td></tr></table></figure><p>运行<code>docker image ls</code>来查看你的新的带有标签信息的镜像：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ <span class="string">docker </span><span class="string">image </span><span class="string">ls</span></div><div class="line"></div><div class="line"><span class="string">REPOSITORY </span>              <span class="string">TAG </span>                <span class="string">IMAGE </span><span class="string">ID </span>           <span class="string">CREATED </span>            <span class="string">SIZE</span></div><div class="line"><span class="string">friendlyhello </span>           <span class="string">latest </span>             <span class="string">d9e555c53008 </span>       3 <span class="string">minutes </span><span class="string">ago </span>      <span class="string">195MB</span></div><div class="line"><span class="string">john/</span><span class="built_in">get-started</span>         <span class="string">part2 </span>              <span class="string">d9e555c53008 </span>       3 <span class="string">minutes </span><span class="string">ago </span>      <span class="string">195MB</span></div><div class="line"><span class="string">python </span>                  2.<span class="string">7-slim </span>           <span class="string">1c7128a655f6 </span>       5 <span class="string">days </span><span class="string">ago </span>         <span class="string">183MB</span></div><div class="line">...</div></pre></td></tr></table></figure><h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><p>上传带有标签信息的镜像到仓库中：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">docker</span> <span class="keyword">push </span>username/repository:tag</div></pre></td></tr></table></figure><p>完成后，此上传的结果将公开发布。如果你登录到<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>，你会在那里看到带有pull命令的新的镜像文件。</p><h3 id="从远程仓库中下拉并且运行镜像"><a href="#从远程仓库中下拉并且运行镜像" class="headerlink" title="从远程仓库中下拉并且运行镜像"></a>从远程仓库中下拉并且运行镜像</h3><p>截止到目前，你可以使用<code>docker run</code>命令来在任何机器上运行你的应用：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -p <span class="attribute">4000</span>:<span class="number">80</span> username/<span class="attribute">repository</span>:tag</div></pre></td></tr></table></figure><p>如果镜像在本地机器上不可用，Docker会从远程仓库中下拉到本地。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ <span class="string">docker </span><span class="string">run </span>-p <span class="string">4000:80 </span><span class="string">john/</span><span class="built_in">get-started:part2</span></div><div class="line"><span class="string">Unable </span><span class="string">to </span><span class="string">find </span><span class="string">image </span><span class="string">'john/get-started:part2'</span> <span class="string">locally</span></div><div class="line"><span class="string">part2:</span> <span class="string">Pulling </span><span class="string">from </span><span class="string">john/</span><span class="built_in">get-started</span></div><div class="line"><span class="string">10a267c67f42:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">f68a39a6a5e4:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">9beaffc0cf19:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">3c1fe835fb6b:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">4c9f1fa8fcb8:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">ee7d8f576a14:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">fbccdcced46e:</span> <span class="string">Already </span><span class="string">exists</span></div><div class="line"><span class="string">Digest:</span> <span class="string">sha256:0601c866aab2adcc6498200efd0f754037e909e5fd42069adeff72d1e2439068</span></div><div class="line"><span class="string">Status:</span> <span class="string">Downloaded </span><span class="string">newer </span><span class="string">image </span><span class="string">for </span><span class="string">john/</span><span class="built_in">get-started:part2</span></div><div class="line"> * <span class="string">Running </span><span class="string">on </span><span class="string">http:</span>//0.0.0.<span class="string">0:80/</span> (<span class="string">Press </span><span class="string">CTRL+</span>C <span class="string">to </span><span class="string">quit)</span></div></pre></td></tr></table></figure><p>不管<code>docker run</code>在哪里运行，它都会将你的镜像以及Python和<code>requirements.txt</code>中所有的依赖关系一起提取出来，并运行您的代码。它们都在一个整洁的小包中一起旅行，并且Docker不需要您在主机上安装任何东西来运行它。</p><h2 id="Part2结论"><a href="#Part2结论" class="headerlink" title="Part2结论"></a>Part2结论</h2><p>这里列出了这个页面的基本Docker命令，以及一些相关的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">docker build -t friendlyhello .  <span class="comment"># Create image using this directory's Dockerfile</span></div><div class="line">docker run -p 4000:80 friendlyhello  <span class="comment"># Run "friendlyname" mapping port 4000 to 80</span></div><div class="line">docker run <span class="_">-d</span> -p 4000:80 friendlyhello         <span class="comment"># Same thing, but in detached mode</span></div><div class="line">docker container ls                                <span class="comment"># List all running containers</span></div><div class="line">docker container ls <span class="_">-a</span>             <span class="comment"># List all containers, even those not running</span></div><div class="line">docker container stop &lt;<span class="built_in">hash</span>&gt;           <span class="comment"># Gracefully stop the specified container</span></div><div class="line">docker container <span class="built_in">kill</span> &lt;<span class="built_in">hash</span>&gt;         <span class="comment"># Force shutdown of the specified container</span></div><div class="line">docker container rm &lt;<span class="built_in">hash</span>&gt;        <span class="comment"># Remove specified container from this machine</span></div><div class="line">docker container rm $(docker container ls <span class="_">-a</span> -q)         <span class="comment"># Remove all containers</span></div><div class="line">docker image ls <span class="_">-a</span>                             <span class="comment"># List all images on this machine</span></div><div class="line">docker image rm &lt;image id&gt;            <span class="comment"># Remove specified image from this machine</span></div><div class="line">docker image rm $(docker image ls <span class="_">-a</span> -q)   <span class="comment"># Remove all images from this machine</span></div><div class="line">docker login             <span class="comment"># Log in this CLI session using your Docker credentials</span></div><div class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># Tag &lt;image&gt; for upload to registry</span></div><div class="line">docker push username/repository:tag            <span class="comment"># Upload tagged image to registry</span></div><div class="line">docker run username/repository:tag                   <span class="comment"># Run image from a registry</span></div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://studyai.site/2018/04/25/Docker%E5%85%A5%E9%97%A8Part2-%E5%AE%B9%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part1-定位和设置</title>
      <link>http://studyai.site/2018/04/25/Docker%E5%85%A5%E9%97%A8Part1-%E5%AE%9A%E4%BD%8D%E5%92%8C%E8%AE%BE%E7%BD%AE/</link>
      <guid>http://studyai.site/2018/04/25/Docker%E5%85%A5%E9%97%A8Part1-%E5%AE%9A%E4%BD%8D%E5%92%8C%E8%AE%BE%E7%BD%AE/</guid>
      <pubDate>Wed, 25 Apr 2018 04:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://docs.docker.com/get-started/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;docker官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎！我们很
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>翻译自<a href="https://docs.docker.com/get-started/" target="_blank" rel="external">docker官方文档</a>。</p></blockquote><p>欢迎！我们很高兴您来学习Docker。 Docker入门教程将教你如何：</p><ul><li>1.设置您的Docker环境（本节内容）</li><li>2.构建一个镜像，并将其作为一个容器运行</li><li>3.通过运行多个容器来缩放你的应用</li><li>4.通过集群来分发你的应用</li><li>5.通过添加后端数据库来堆叠服务</li><li>6.发布你的应用到生产环境</li></ul><h2 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a>Docker的概念</h2><p>Docker是开发人员和系统管理员使用容器<strong>开发</strong>、<strong>部署</strong>和<strong>运行</strong>应用程序的平台。使用Linux容器来部署应用程序称为<em>集装箱化</em>(Containerization)。容器的概念并不新，但它们用于部署应用程序会很轻松。</p><p>集装箱化越来越受欢迎，因为集装箱是：</p><ul><li>灵活：即使是最复杂的应用也可以被集装箱化。</li><li>轻量级：容器利用并共享主机内核。</li><li>通用：您可以即时部署更新和升级。</li><li>轻便：你可以在本地构建，发布到云端，并且在任何地方运行。</li><li>可扩展：您可以增加和自动分发容器副本。</li><li>可堆叠：您可以及时的纵向堆叠服务。</li></ul><p><img src="/img/18_04_25/001.png" alt=""></p><h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>一个容器通过运行一个镜像来启动。一个<strong>镜像</strong>是一个可执行的程序包，其中包含运行该程序所需的所有内容，包括代码，运行时，库，环境变量和配置文件。</p><p><strong>容器</strong>是镜像的运行时实例 - 即执行时将镜像加载到内存中，这个内存中的部分就是容器（即具有状态或用户进程的镜像）。Linux环境下，你可以通过命令<code>docker ps</code>来查看你当前正在运行的容器。</p><h3 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h3><p>一个<strong>容器</strong>在Linux的<em>本地</em>运行，并与其他容器共享主机的内核。它运行在一个独立的进程，不占用任何其他可执行文件的内存，从而达到轻量化。</p><p>对比之下，<strong>虚拟机（VM）</strong>运行一个完整的“guest”操作系统，通过虚拟机管理程序虚拟访问主机资源。一般来说，虚拟机提供的环境比大多数应用程序需要的资源更多。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"><img src="/img/18_04_25/002.png" alt=""></td><td style="text-align:center"><img src="/img/18_04_25/003.png" alt=""></td></tr></tbody></table><h2 id="准备你的Docker环境"><a href="#准备你的Docker环境" class="headerlink" title="准备你的Docker环境"></a>准备你的Docker环境</h2><p>在支持的平台上安装Docker社区版本(CE)或者企业版(EE)。</p><blockquote><p>对于完整的Kubernetes集成</p><ul><li><p>Docker for Mac上的Kubernetes在17.12 Edge（mac45）或17.12 Stable（mac46）及更高版本中可用。</p></li><li><p>Docker for Windows上的Kubernetes仅在18.02 Edge（win50）和更高边缘通道中可用。</p></li></ul></blockquote><p><a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">安装Docker</a></p><h3 id="测试Docker版本号"><a href="#测试Docker版本号" class="headerlink" title="测试Docker版本号"></a>测试Docker版本号</h3><ul><li>1.运行<code>docker --version</code>并确保您拥有支持的Docker版本：</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker --<span class="keyword">version</span></div><div class="line"></div><div class="line">Docker <span class="keyword">version</span> <span class="number">17.12</span>.<span class="number">0</span>-<span class="keyword">ce</span>, build c97c6d6</div></pre></td></tr></table></figure><ul><li>2.运行<code>docker info</code>或者(<code>docker version</code>没有<code>--</code>)来查看关于您的Docker安装的更多细节：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">docker info</div><div class="line"></div><div class="line"><span class="attribute">Containers</span>: <span class="number">0</span></div><div class="line"> <span class="attribute">Running</span>: <span class="number">0</span></div><div class="line"> <span class="attribute">Paused</span>: <span class="number">0</span></div><div class="line"> <span class="attribute">Stopped</span>: <span class="number">0</span></div><div class="line"><span class="attribute">Images</span>: <span class="number">0</span></div><div class="line">Server <span class="attribute">Version</span>: <span class="number">17.12</span>.<span class="number">0</span>-ce</div><div class="line">Storage <span class="attribute">Driver</span>: overlay2</div><div class="line">...</div></pre></td></tr></table></figure><blockquote><p>为了避免权限错误（以及<code>sudo</code>的使用），将您的用户添加到<code>docker</code>组。<a href="https://docs.docker.com/engine/installation/linux/linux-postinstall/" target="_blank" rel="external">更多</a>。</p></blockquote><h3 id="测试Docker的安装"><a href="#测试Docker的安装" class="headerlink" title="测试Docker的安装"></a>测试Docker的安装</h3><ul><li>1.通过运行简单的Docker镜像<a href="https://hub.docker.com/_/hello-world/" target="_blank" rel="external">hello-world</a>来测试您的安装是否工作正常：</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">docker run hello-world</div><div class="line"></div><div class="line">Unable <span class="keyword">to</span> <span class="keyword">find</span> image <span class="string">'hello-world:latest'</span> locally</div><div class="line">lates<span class="variable">t:</span> Pulling from library/hello-world</div><div class="line">ca4f61b1923c: Pull <span class="built_in">complete</span></div><div class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7</div><div class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> hello-world:latest</div><div class="line"></div><div class="line">Hello from Docker!</div><div class="line">This message shows that your installation appears <span class="keyword">to</span> <span class="keyword">be</span> working correctly.</div><div class="line">...</div></pre></td></tr></table></figure><ul><li>2.列出下载到你机器上的<code>hello-world</code>镜像：</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">image</span> <span class="keyword">ls</span></div></pre></td></tr></table></figure><ul><li>3.列出显示其消息后退出的<code>hello-world</code>容器（由镜像生成）。如果它仍在运行，则不需要<code>--all</code>选项：</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker container ls --all</div><div class="line"></div><div class="line">CONTAINER ID     IMAGE           COMMAND      CREATED            STATUS</div><div class="line"><span class="number">54</span>f4984ed6a8     hello-world     <span class="string">"/hello"</span>     <span class="number">20</span> seconds ago     Exited (<span class="number">0</span>) <span class="number">19</span> seconds ago</div></pre></td></tr></table></figure><h2 id="本节回顾"><a href="#本节回顾" class="headerlink" title="本节回顾"></a>本节回顾</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">## <span class="keyword">List</span> Docker <span class="keyword">CLI</span> commands</div><div class="line">docker</div><div class="line">docker container --<span class="keyword">help</span></div><div class="line"></div><div class="line">## <span class="keyword">Display</span> Docker <span class="keyword">version</span> and info</div><div class="line">docker --<span class="keyword">version</span></div><div class="line">docker <span class="keyword">version</span></div><div class="line">docker info</div><div class="line"></div><div class="line">## Execute Docker image</div><div class="line">docker <span class="keyword">run</span> hello-world</div><div class="line"></div><div class="line">## <span class="keyword">List</span> Docker images</div><div class="line">docker image <span class="keyword">ls</span></div><div class="line"></div><div class="line">## <span class="keyword">List</span> Docker containers (running, all, all <span class="keyword">in</span> quiet mode)</div><div class="line">docker container <span class="keyword">ls</span></div><div class="line">docker container <span class="keyword">ls</span> --all</div><div class="line">docker container <span class="keyword">ls</span> -aq</div></pre></td></tr></table></figure><h2 id="Part1结论"><a href="#Part1结论" class="headerlink" title="Part1结论"></a>Part1结论</h2><p>容器化使<a href="https://www.docker.com/use-cases/cicd" target="_blank" rel="external">CI/CD</a>无缝衔接。例如：</p><ul><li>应用程序没有系统依赖关系</li><li>更新可以推送到分布式应用程序的任何部分</li><li>资源密度可以被优化。</li></ul><p>使用Docker，扩展应用程序的过程就是启动新的可执行文件，而不是运行繁重的VM主机。</p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/04/25/Docker%E5%85%A5%E9%97%A8Part1-%E5%AE%9A%E4%BD%8D%E5%92%8C%E8%AE%BE%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【翻译】kaggle竞赛 房价预测</title>
      <link>http://studyai.site/2018/03/09/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91kaggle%E7%AB%9E%E8%B5%9B%20%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/</link>
      <guid>http://studyai.site/2018/03/09/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91kaggle%E7%AB%9E%E8%B5%9B%20%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/</guid>
      <pubDate>Fri, 09 Mar 2018 14:08:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://www.kaggle.com/pmarcelino/comprehensive-data-exploration-with-python&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://www.kaggle.com/pmarcelino/comprehensive-data-exploration-with-python" target="_blank" rel="external">原文链接</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果你有一些R或者Python的经验，并且掌握一些基本的机器学习知识。对于完成机器学习在线课程的数据科学学生来说，这是一个很适合练手的比赛。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>如果让一个想要买房的人来描述他们梦想中的住宅，他们可能不会从地下室天花板的高度或与东西方地铁的距离开始描述。但是这个游乐场比赛的数据集证明，购房者考虑的主要因素中，对价格谈判的影响远远超过卧室或白色栅栏的数量的影响。</p><p>有79个解释变量描述（几乎）爱荷华州埃姆斯的住宅房屋的每个方面，这个竞赛的目标是需要你来预测每个房屋的最终价格。</p><h3 id="实践技能"><a href="#实践技能" class="headerlink" title="实践技能"></a>实践技能</h3><ul><li>创意特征工程</li><li>先进的回归算法技术，如随机森林和梯度提升</li></ul><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="http://www.amstat.org/publications/jse/v19n3/decock.pdf" target="_blank" rel="external">Ames Housing数据集</a>由Dean De Cock编制，用于数据科学教育。对于那些寻找比Boston Housing数据集更现代化的扩展版本数据集的数据科学家来说，这的确是一个很赞的选择。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="文件描述"><a href="#文件描述" class="headerlink" title="文件描述"></a>文件描述</h3><ul><li>train.csv - 训练集</li><li>test.csv - 测试集</li><li>data_description.txt - 记录了每个特征的完整描述信息，最初由Dean De Cock编写，后来做了略微的改动</li><li>sample_submission.csv - 来自销售年份和月份的线性回归的基准提交，批量平方英尺和卧室数量（a benchmark submission from a linear regression on year and month of sale, lot square footage, and number of bedrooms）</li></ul><h3 id="字段信息"><a href="#字段信息" class="headerlink" title="字段信息"></a>字段信息</h3><p>以下是您可以在数据描述文件中找到的简要版本。</p><table><thead><tr><th style="text-align:center">字段名</th><th style="text-align:left">英文解释</th><th style="text-align:left">中文解释</th></tr></thead><tbody><tr><td style="text-align:center">SalePrice</td><td style="text-align:left">the property’s sale price in dollars. This is the target variable that you’re trying to predict.</td><td style="text-align:left">房屋的销售价格以美元计价。这是你试图预测的目标变量。</td></tr><tr><td style="text-align:center">MSSubClass</td><td style="text-align:left">The building class</td><td style="text-align:left">建筑类</td></tr><tr><td style="text-align:center">MSZoning</td><td style="text-align:left">The general zoning classification</td><td style="text-align:left">一般分区分类</td></tr><tr><td style="text-align:center">LotFrontage</td><td style="text-align:left">Linear feet of street connected to property</td><td style="text-align:left">连接到财产的街道的线性脚</td></tr><tr><td style="text-align:center">LotArea</td><td style="text-align:left">Lot size in square feet</td><td style="text-align:left">地块面积（平方英尺）</td></tr><tr><td style="text-align:center">Street</td><td style="text-align:left">Type of road access</td><td style="text-align:left">道路通行类型</td></tr><tr><td style="text-align:center">Alley</td><td style="text-align:left">Type of alley access</td><td style="text-align:left">胡同通道的类型</td></tr><tr><td style="text-align:center">LotShape</td><td style="text-align:left">General shape of property</td><td style="text-align:left">财产的一般形状</td></tr><tr><td style="text-align:center">LandContour</td><td style="text-align:left">Flatness of the property</td><td style="text-align:left">物业的平整度</td></tr><tr><td style="text-align:center">Utilities</td><td style="text-align:left">Type of utilities available</td><td style="text-align:left">可用的实用程序类型</td></tr><tr><td style="text-align:center">LotConfig</td><td style="text-align:left">Lot configuration</td><td style="text-align:left">批量配置</td></tr><tr><td style="text-align:center">LandSlope</td><td style="text-align:left">Slope of property</td><td style="text-align:left">财产的倾斜</td></tr><tr><td style="text-align:center">Neighborhood</td><td style="text-align:left">Physical locations within Ames city limits</td><td style="text-align:left">Ames城市限制内的物理位置</td></tr><tr><td style="text-align:center">Condition1</td><td style="text-align:left">Proximity to main road or railroad</td><td style="text-align:left">靠近主干道或铁路</td></tr><tr><td style="text-align:center">Condition2</td><td style="text-align:left">Proximity to main road or railroad (if a second is present)</td><td style="text-align:left">靠近主要道路或铁路（如果存在第二个）</td></tr><tr><td style="text-align:center">BldgType</td><td style="text-align:left">Type of dwelling</td><td style="text-align:left">住宅类型</td></tr><tr><td style="text-align:center">HouseStyle</td><td style="text-align:left">Style of dwelling</td><td style="text-align:left">住宅风格</td></tr><tr><td style="text-align:center">OverallQual</td><td style="text-align:left">Overall material and finish quality</td><td style="text-align:left">总体材料和加工质量</td></tr><tr><td style="text-align:center">OverallCond</td><td style="text-align:left">Overall condition rating</td><td style="text-align:left">总体状况的评价</td></tr><tr><td style="text-align:center">YearBuilt</td><td style="text-align:left">Original construction date</td><td style="text-align:left">原始施工日期</td></tr><tr><td style="text-align:center">YearRemodAdd</td><td style="text-align:left">Remodel date</td><td style="text-align:left">重构日期</td></tr><tr><td style="text-align:center">RoofStyle</td><td style="text-align:left">Type of roof</td><td style="text-align:left">屋顶类型</td></tr><tr><td style="text-align:center">RoofMatl</td><td style="text-align:left">Roof material</td><td style="text-align:left">屋顶材料</td></tr><tr><td style="text-align:center">Exterior1st</td><td style="text-align:left">Exterior covering on house</td><td style="text-align:left">房屋外墙</td></tr><tr><td style="text-align:center">Exterior2nd</td><td style="text-align:left">Exterior covering on house (if more than one material)</td><td style="text-align:left">房屋外墙（如果多于一种）</td></tr><tr><td style="text-align:center">MasVnrType</td><td style="text-align:left">Masonry veneer type</td><td style="text-align:left">Masonry贴面类型</td></tr><tr><td style="text-align:center">MasVnrArea</td><td style="text-align:left">Masonry veneer area in square feet</td><td style="text-align:left">砖石面积平方英尺</td></tr><tr><td style="text-align:center">ExterQual</td><td style="text-align:left">Exterior material quality</td><td style="text-align:left">外部材料质量</td></tr><tr><td style="text-align:center">ExterCond</td><td style="text-align:left">Present condition of the material on the exterior</td><td style="text-align:left">外部材料的现状</td></tr><tr><td style="text-align:center">Foundation</td><td style="text-align:left">Type of foundation</td><td style="text-align:left">基础类型</td></tr><tr><td style="text-align:center">BsmtQual</td><td style="text-align:left">Height of the basement</td><td style="text-align:left">地下室的高度</td></tr><tr><td style="text-align:center">BsmtCond</td><td style="text-align:left">General condition of the basement</td><td style="text-align:left">地下室的一般状况</td></tr><tr><td style="text-align:center">BsmtExposure</td><td style="text-align:left">Walkout or garden level basement walls</td><td style="text-align:left">罢工或花园级地下室的墙壁</td></tr><tr><td style="text-align:center">BsmtFinType1</td><td style="text-align:left">Quality of basement finished area</td><td style="text-align:left">地下室成品面积质量</td></tr><tr><td style="text-align:center">BsmtFinSF1</td><td style="text-align:left">Type 1 finished square feet</td><td style="text-align:left">1型方形脚</td></tr><tr><td style="text-align:center">BsmtFinType2</td><td style="text-align:left">Quality of second finished area (if present)</td><td style="text-align:left">第二个完成区域的质量（如果存在）</td></tr><tr><td style="text-align:center">BsmtFinSF2</td><td style="text-align:left">Type 2 finished square feet</td><td style="text-align:left">2型完成的平方英尺</td></tr><tr><td style="text-align:center">BsmtUnfSF</td><td style="text-align:left">Unfinished square feet of basement area</td><td style="text-align:left">未完成的地下室面积</td></tr><tr><td style="text-align:center">TotalBsmtSF</td><td style="text-align:left">Total square feet of basement area</td><td style="text-align:left">地下室面积的平方英尺</td></tr><tr><td style="text-align:center">Heating</td><td style="text-align:left">Type of heating</td><td style="text-align:left">加热类型</td></tr><tr><td style="text-align:center">HeatingQC</td><td style="text-align:left">Heating quality and condition</td><td style="text-align:left">供热质量和条件</td></tr><tr><td style="text-align:center">CentralAir</td><td style="text-align:left">Central air conditioning</td><td style="text-align:left">中央空调</td></tr><tr><td style="text-align:center">Electrical</td><td style="text-align:left">Electrical system</td><td style="text-align:left">电气系统</td></tr><tr><td style="text-align:center">1stFlrSF</td><td style="text-align:left">First Floor square feet</td><td style="text-align:left">一楼平方英尺</td></tr><tr><td style="text-align:center">2ndFlrSF</td><td style="text-align:left">Second floor square feet</td><td style="text-align:left">二楼平方英尺</td></tr><tr><td style="text-align:center">LowQualFinSF</td><td style="text-align:left">Low quality finished square feet (all floors)</td><td style="text-align:left">低质量成品平方英尺（所有楼层）</td></tr><tr><td style="text-align:center">GrLivArea</td><td style="text-align:left">Above grade (ground) living area square feet</td><td style="text-align:left">以上（地面）生活区平方英尺</td></tr><tr><td style="text-align:center">BsmtFullBath</td><td style="text-align:left">Basement full bathrooms</td><td style="text-align:left">地下室完整的浴室</td></tr><tr><td style="text-align:center">BsmtHalfBath</td><td style="text-align:left">Basement half bathrooms</td><td style="text-align:left">地下室半浴室</td></tr><tr><td style="text-align:center">FullBath</td><td style="text-align:left">Full bathrooms above grade</td><td style="text-align:left">全年以上的浴室</td></tr><tr><td style="text-align:center">HalfBath</td><td style="text-align:left">Half baths above grade</td><td style="text-align:left">半浴半高</td></tr><tr><td style="text-align:center">Bedroom</td><td style="text-align:left">Number of bedrooms above basement level</td><td style="text-align:left">地下室数量</td></tr><tr><td style="text-align:center">Kitchen</td><td style="text-align:left">Number of kitchens</td><td style="text-align:left">厨房数量</td></tr><tr><td style="text-align:center">KitchenQual</td><td style="text-align:left">Kitchen quality</td><td style="text-align:left">厨房质量</td></tr><tr><td style="text-align:center">TotRmsAbvGrd</td><td style="text-align:left">Total rooms above grade (does not include bathrooms)</td><td style="text-align:left">房间总数（不含浴室）</td></tr><tr><td style="text-align:center">Functional</td><td style="text-align:left">Home functionality rating</td><td style="text-align:left">家庭功能评级</td></tr><tr><td style="text-align:center">Fireplaces</td><td style="text-align:left">Number of fireplaces</td><td style="text-align:left">壁炉数量</td></tr><tr><td style="text-align:center">FireplaceQu</td><td style="text-align:left">Fireplace quality</td><td style="text-align:left">壁炉质量</td></tr><tr><td style="text-align:center">GarageType</td><td style="text-align:left">Garage location</td><td style="text-align:left">车库位置</td></tr><tr><td style="text-align:center">GarageYrBlt</td><td style="text-align:left">Year garage was built</td><td style="text-align:left">年建车库</td></tr><tr><td style="text-align:center">GarageFinish</td><td style="text-align:left">Interior finish of the garage</td><td style="text-align:left">车库内部装修</td></tr><tr><td style="text-align:center">GarageCars</td><td style="text-align:left">Size of garage in car capacity</td><td style="text-align:left">车库的车库容量</td></tr><tr><td style="text-align:center">GarageArea</td><td style="text-align:left">Size of garage in square feet</td><td style="text-align:left">平方英尺车库大小</td></tr><tr><td style="text-align:center">GarageQual</td><td style="text-align:left">Garage quality</td><td style="text-align:left">车库质量</td></tr><tr><td style="text-align:center">GarageCond</td><td style="text-align:left">Garage condition</td><td style="text-align:left">车库条件</td></tr><tr><td style="text-align:center">PavedDrive</td><td style="text-align:left">Paved driveway</td><td style="text-align:left">铺设的车道</td></tr><tr><td style="text-align:center">WoodDeckSF</td><td style="text-align:left">Wood deck area in square feet</td><td style="text-align:left">木甲板面积平方英尺</td></tr><tr><td style="text-align:center">OpenPorchSF</td><td style="text-align:left">Open porch area in square feet</td><td style="text-align:left">平方英尺开放门廊</td></tr><tr><td style="text-align:center">EnclosedPorch</td><td style="text-align:left">Enclosed porch area in square feet</td><td style="text-align:left">封闭的门廊面积平方英尺</td></tr><tr><td style="text-align:center">3SsnPorch</td><td style="text-align:left">Three season porch area in square feet</td><td style="text-align:left">三季门廊面积平方英尺</td></tr><tr><td style="text-align:center">ScreenPorch</td><td style="text-align:left">Screen porch area in square feet</td><td style="text-align:left">屏幕门廊面积平方英尺</td></tr><tr><td style="text-align:center">PoolArea</td><td style="text-align:left">Pool area in square feet</td><td style="text-align:left">游泳池面积平方英尺</td></tr><tr><td style="text-align:center">PoolQC</td><td style="text-align:left">Pool quality</td><td style="text-align:left">游泳池质量</td></tr><tr><td style="text-align:center">Fence</td><td style="text-align:left">Fence quality</td><td style="text-align:left">栅栏质量</td></tr><tr><td style="text-align:center">MiscFeature</td><td style="text-align:left">Miscellaneous feature not covered in other categories</td><td style="text-align:left">其他类别未涉及的其他功能</td></tr><tr><td style="text-align:center">MiscVal</td><td style="text-align:left">$Value of miscellaneous feature</td><td style="text-align:left">$杂项功能的值</td></tr><tr><td style="text-align:center">MoSold</td><td style="text-align:left">Month Sold</td><td style="text-align:left">月销售</td></tr><tr><td style="text-align:center">YrSold</td><td style="text-align:left">Year Sold</td><td style="text-align:left">年销售</td></tr><tr><td style="text-align:center">SaleType</td><td style="text-align:left">Type of sale</td><td style="text-align:left">销售类型</td></tr><tr><td style="text-align:center">SaleCondition</td><td style="text-align:left">Condition of sale</td><td style="text-align:left">销售条件</td></tr></tbody></table><h2 id="用Python进行全面的数据探索"><a href="#用Python进行全面的数据探索" class="headerlink" title="用Python进行全面的数据探索"></a>用Python进行全面的数据探索</h2><blockquote><p>Pedro Marcelino 创建</p></blockquote><p><a href="https://www.kaggle.com/pmarcelino/comprehensive-data-exploration-with-python" target="_blank" rel="external">link</a></p><p><strong>‘The most difficult thing in life is to know yourself’</strong></p><p>这句话引用自古希腊米利都的Thales。Thales是希腊/印第安哲学家，数学家和天文学家，被公认为西方文明中第一位享有娱乐和参与科学思想的人（来源：<a href="https://en.wikipedia.org/wiki/Thales" target="_blank" rel="external">https://en.wikipedia.org/wiki/Thales</a>）。</p><p>我不会说了解数据是数据科学中最困难的事情，但这的确是一件非常耗时的事情。很多人可能会忽略这一步骤，就直接下水了。</p><p>所以我试着在下水之前先学会游泳。基于Hair等人（2013）整理的’Examining your data’一章中，我尽我所能对数据进行全面而非详尽的分析。我没有在这个内核中上报严谨的研究过程，但我希望它对社区有所帮助，所以我分享了我如何将这些数据分析原理应用于这个问题的思路。</p><p>尽管我给这些章写了一些奇怪的名字，但我们在这个内核中所做的是：</p><ul><li>1.<strong>理解问题</strong>：我们将研究每个变量，并对这个问题的意义和重要性进行哲学分析。</li><li>2.<strong>单变量研究</strong>：我们只关注因变量（’SalePrice’）并尝试更多地了解它。</li><li>3.<strong>多变量研究</strong>：我们将尝试了解因变量和自变量之间的关系。</li><li>4.<strong>基本的清理工作</strong>：我们将清理数据集并处理缺失的数据，异常值和分类变量。</li><li>5.<strong>测试假设</strong>：我们将检查我们的数据是否符合大多数多元技术所需的假设。</li></ul><p>现在，让我们好好玩吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 邀请人们来参加Kaggle聚会</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</div><div class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</div><div class="line"><span class="keyword">import</span> warnings</div><div class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</div><div class="line">%matplotlib inline</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 导入数据</span></div><div class="line">df_train = pd.read_csv(<span class="string">'../input/train.csv'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 检查描述信息</span></div><div class="line">df_train.columns</div></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Index</span>([<span class="string">'Id'</span>, <span class="string">'MSSubClass'</span>, <span class="string">'MSZoning'</span>, <span class="string">'LotFrontage'</span>, <span class="string">'LotArea'</span>, <span class="string">'Street'</span>,</div><div class="line">       <span class="string">'Alley'</span>, <span class="string">'LotShape'</span>, <span class="string">'LandContour'</span>, <span class="string">'Utilities'</span>, <span class="string">'LotConfig'</span>,</div><div class="line">       <span class="string">'LandSlope'</span>, <span class="string">'Neighborhood'</span>, <span class="string">'Condition1'</span>, <span class="string">'Condition2'</span>, <span class="string">'BldgType'</span>,</div><div class="line">       <span class="string">'HouseStyle'</span>, <span class="string">'OverallQual'</span>, <span class="string">'OverallCond'</span>, <span class="string">'YearBuilt'</span>, <span class="string">'YearRemodAdd'</span>,</div><div class="line">       <span class="string">'RoofStyle'</span>, <span class="string">'RoofMatl'</span>, <span class="string">'Exterior1st'</span>, <span class="string">'Exterior2nd'</span>, <span class="string">'MasVnrType'</span>,</div><div class="line">       <span class="string">'MasVnrArea'</span>, <span class="string">'ExterQual'</span>, <span class="string">'ExterCond'</span>, <span class="string">'Foundation'</span>, <span class="string">'BsmtQual'</span>,</div><div class="line">       <span class="string">'BsmtCond'</span>, <span class="string">'BsmtExposure'</span>, <span class="string">'BsmtFinType1'</span>, <span class="string">'BsmtFinSF1'</span>,</div><div class="line">       <span class="string">'BsmtFinType2'</span>, <span class="string">'BsmtFinSF2'</span>, <span class="string">'BsmtUnfSF'</span>, <span class="string">'TotalBsmtSF'</span>, <span class="string">'Heating'</span>,</div><div class="line">       <span class="string">'HeatingQC'</span>, <span class="string">'CentralAir'</span>, <span class="string">'Electrical'</span>, <span class="string">'1stFlrSF'</span>, <span class="string">'2ndFlrSF'</span>,</div><div class="line">       <span class="string">'LowQualFinSF'</span>, <span class="string">'GrLivArea'</span>, <span class="string">'BsmtFullBath'</span>, <span class="string">'BsmtHalfBath'</span>, <span class="string">'FullBath'</span>,</div><div class="line">       <span class="string">'HalfBath'</span>, <span class="string">'BedroomAbvGr'</span>, <span class="string">'KitchenAbvGr'</span>, <span class="string">'KitchenQual'</span>,</div><div class="line">       <span class="string">'TotRmsAbvGrd'</span>, <span class="string">'Functional'</span>, <span class="string">'Fireplaces'</span>, <span class="string">'FireplaceQu'</span>, <span class="string">'GarageType'</span>,</div><div class="line">       <span class="string">'GarageYrBlt'</span>, <span class="string">'GarageFinish'</span>, <span class="string">'GarageCars'</span>, <span class="string">'GarageArea'</span>, <span class="string">'GarageQual'</span>,</div><div class="line">       <span class="string">'GarageCond'</span>, <span class="string">'PavedDrive'</span>, <span class="string">'WoodDeckSF'</span>, <span class="string">'OpenPorchSF'</span>,</div><div class="line">       <span class="string">'EnclosedPorch'</span>, <span class="string">'3SsnPorch'</span>, <span class="string">'ScreenPorch'</span>, <span class="string">'PoolArea'</span>, <span class="string">'PoolQC'</span>,</div><div class="line">       <span class="string">'Fence'</span>, <span class="string">'MiscFeature'</span>, <span class="string">'MiscVal'</span>, <span class="string">'MoSold'</span>, <span class="string">'YrSold'</span>, <span class="string">'SaleType'</span>,</div><div class="line">       <span class="string">'SaleCondition'</span>, <span class="string">'SalePrice'</span>],</div><div class="line">      dtype=<span class="string">'object'</span>)</div></pre></td></tr></table></figure><h3 id="1-那么，我们能得到什么呢？"><a href="#1-那么，我们能得到什么呢？" class="headerlink" title="1.那么，我们能得到什么呢？"></a>1.那么，我们能得到什么呢？</h3><p>为了理解我们的数据，我们可以看看每个变量，并试图理解它们的含义以及与这个问题的相关性。我知道这个工作很耗时，但它会给我们数据集增添一些味道。</p><p>为了在我们的分析中掌握一些规则，我们可以创建一个Excel电子表格，其中包含以下列：</p><ul><li><strong>变量名</strong> - 变量名称。</li><li><strong>类型</strong> - 识别变量的类型。该字段有两种可能的值：’数值型’或’类别型’。“数值型”是指值为数字的变量，而“类别型”是指值为类别的变量。</li><li><strong>细分</strong> - 识别变量的细分。我们可以定义三个可能的部分：building，space或location。当我们说“building”时，我们是指与建筑物的物理特性相关的变量（例如’OverallQual’&lt;总体材料和加工质量&gt;）。当我们说“space”时，我们是指报告房屋空间属性的变量（例如’TotalBsmtSF’&lt;地下室面积的平方英尺&gt;）。最后，当我们说’location’时，我们说的是指能提供有关房屋所在地的信息（例如’Neighborhood’<ames城市限制内的物理位置>）的变量。</ames城市限制内的物理位置></li><li><strong>期望</strong> - 我们对’SalePrice’中的可变影响力的期望。我们可以使用“高”，“中”和“低”作为可能值的分类比例。</li><li><strong>结论</strong> - 在我们快速查看数据后，可以得出关于变量重要性的结论。我们可以保持与“期望”相同的分类尺度。</li><li><strong>评论</strong> - 我们手动赋予的通用评论信息。</li></ul><p>虽然“类型”和“细分”仅供以后使用参考，但“期望”一栏非常重要，因为它有助于我们发展我们的“第六感”。为了填补这个专栏，我们应该阅读所有变量的描述，并逐个问自己：</p><ul><li>当我们买房子时，我们是否考虑这个变量？（例如，当我们想到梦想中的房子时，我们是否在意它的’砌体贴面类型’？）</li><li>如果是这样，这个变量有多重要？（例如，外部材料这个属性的影响到底是“非常大”还是“非常小”，或者是“一般”呢）？</li><li>这些信息是否已在任何其他变量中描述过？（例如，如果’LandContour’&lt;物业的平整度&gt;给出了房产的平坦性，我们是否真的需要知道’LandSlope’&lt;物业的倾斜度&gt;？）。</li></ul><p>经过这个艰巨的练习之后，我们可以过滤电子表格并仔细查看具有“高”’期望’的变量。然后，我们可以绘制出这些变量和’SalePrice’之间的一些散点图，填入’结论’栏，这只是我们预期的修正。</p><p>我经历了这个过程并得出结论，下面的变量可以在这个问题中发挥重要作用：</p><ul><li>OverallQual&lt;总体材料和加工质量&gt;（这是一个我不喜欢的变量，因为我不知道它是如何计算的;你可以把使用所有其他可用变量来预测’OverallQual’来作为一个有趣的练习）。</li><li>YearBuilt&lt;原始施工日期&gt;</li><li>TotalBsmtSF&lt;地下室面积的平方英尺&gt;</li><li>GrLivArea&lt;以上（地面）生活区平方英尺&gt;</li></ul><p>我选择了两个’building’变量（’OverallQual’和’YearBuilt’）和两个’space’变量（’TotalBsmtSF’和’GrLivArea’）。这可能有点意外，因为它违背了房地产的核心，即在房地产中重要的影响因素是“位置”、“位置”和“位置”。对于类别变量，这种快速数据检查过程可能有点苛刻。例如，我预计’Neigborhood’变量更具相关性，但在数据检查之后，我最终排除了它。也许这与使用散点图而不是箱图有关，它更适合分类变量可视化。我们对数据进行可视化的方式通常会影响到我们的结论。</p><p>但是，这个练习的要点是想一想我们的数据和期望值，所以我认为我们达到了目标。现在是’少一点谈话，多一点行动’的时候了。让我们开始吧！</p><h3 id="2-首先要做的是分析’SalePrice’"><a href="#2-首先要做的是分析’SalePrice’" class="headerlink" title="2.首先要做的是分析’SalePrice’"></a>2.首先要做的是分析’SalePrice’</h3><p>‘SalePrice’是我们所追求的理由。就像我们要参加派对时一样。我们总是有一个理由去那里。比如，和女性交往也许就是我们去参加派对的原因。 （免责声明：根据您的喜好将其适应男性，跳舞或酒精）。</p><p>让我们来构建一个使用女性来比喻‘SalePrice’的小故事 – ‘我们如何认识’SalePrice’’的故事。</p><p><em>这一切都始于我们的Kaggle派对。当我们在舞池里寻找一段时间舞伴之后，我们看到一个女孩在酒吧附近使用舞蹈鞋。这说明了她在那里跳舞。我们花了很多时间进行预测建模并参与分析竞赛，因此与女孩谈话并不是我们的主要能力之一。即便如此，我们试了一下：</em></p><p><em>嗨，我是Kaggly！你呢？ ‘SalePrice’？多么美丽的名字！你知道’SalePrice’，你能给我提供一些关于你的数据吗？我刚刚开发了一个模型来计算两个人之间关系成功的可能性。我想在我们身上试一试！’</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 描述性统计数据汇总</span></div><div class="line">df_train[<span class="string">'SalePrice'</span>].describe()</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">count</span>      1460<span class="selector-class">.000000</span></div><div class="line"><span class="selector-tag">mean</span>     180921<span class="selector-class">.195890</span></div><div class="line"><span class="selector-tag">std</span>       79442<span class="selector-class">.502883</span></div><div class="line"><span class="selector-tag">min</span>       34900<span class="selector-class">.000000</span></div><div class="line">25%      129975<span class="selector-class">.000000</span></div><div class="line">50%      163000<span class="selector-class">.000000</span></div><div class="line">75%      214000<span class="selector-class">.000000</span></div><div class="line"><span class="selector-tag">max</span>      755000<span class="selector-class">.000000</span></div><div class="line"><span class="selector-tag">Name</span>: <span class="selector-tag">SalePrice</span>, <span class="selector-tag">dtype</span>: <span class="selector-tag">float64</span></div></pre></td></tr></table></figure><p><em>很好……看起来你的最低价格大于零。很棒！你没有那些会毁掉我的模特的个人特质！你可以寄给我一些你的照片吗？……就像你在沙滩上……或者在健身房里自拍的那种一样？“</em></p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 直方图</div><div class="line"><span class="selector-tag">sns</span><span class="selector-class">.distplot</span>(df_train[<span class="string">'SalePrice'</span>]);</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/001.png" alt=""></p><p><em>啊!我看到你在出门的时候使用了seaborn化妆……太优雅了！我也看到你：</em></p><ul><li><strong><em>偏离正态分布。</em></strong></li><li><strong><em>有明显的正偏态。</em></strong></li><li><strong><em>显示尖锐度。</em></strong></li></ul><p><em>这很有趣！’SalePrice’，你能给我你的身体指标吗？’</em></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 偏度和峰度</span></div><div class="line"><span class="keyword">print</span>(<span class="string">"Skewness: %f"</span> % df_train[<span class="string">'SalePrice'</span>].skew())</div><div class="line"><span class="keyword">print</span>(<span class="string">"Kurtosis: %f"</span> % df_train[<span class="string">'SalePrice'</span>].kurt())</div></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Skewness:</span> <span class="number">1.882876</span></div><div class="line"><span class="symbol">Kurtosis:</span> <span class="number">6.536282</span></div></pre></td></tr></table></figure><p><em>‘Amazing！如果我的爱情计算器是正确的，我们的成功概率是97.834657％。我想我们应该再见面！如果下星期五有空，请留下我的电话号码并给我打电话。再见！</em></p><h4 id="‘SalePrice’，她的好友和她的兴趣"><a href="#‘SalePrice’，她的好友和她的兴趣" class="headerlink" title="‘SalePrice’，她的好友和她的兴趣"></a>‘SalePrice’，她的好友和她的兴趣</h4><p><em>选择你将要战斗的地形是重要的军事智慧。离开了“SalePrice”，我们就去了她的Facebook。请注意，这不是在跟踪她。我们只是对她做深入的研究。</em></p><p><em>据她介绍，我们有一些共同的朋友。除了Chuck Norris之外，我们都知道’GrLivArea’和’TotalBsmtSF’。此外，我们也有共同的兴趣，如’OverallQual’和’YearBuilt’。这看起来我们有希望！</em></p><p><em>为了充分利用我们的研究成果，我们将首先仔细研究我们的共同朋友的概况，然后我们将重点关注我们的共同利益。</em></p><p><strong>与数值变量的关系</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 绘制 GrLivArea/SalePrice 的散点图</span></div><div class="line">var = <span class="string">'GrLivArea'</span></div><div class="line">data = pd.concat([df_train[<span class="string">'SalePrice'</span>], df_train[var]], axis=<span class="number">1</span>)</div><div class="line">data.plot.scatter(x=var, y=<span class="string">'SalePrice'</span>, ylim=(<span class="number">0</span>,<span class="number">800000</span>));</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/002.png" alt=""></p><p><em>嗯……看起来’SalePrice’和’GrLivArea’是真正的老朋友，具有线性关系。</em></p><p><em>那么’TotalBsmtSF’呢？</em></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 绘制 TotalBsmtSF/SalePrice 的散点图</span></div><div class="line"><span class="title">var</span> = '<span class="type">TotalBsmtSF'</span></div><div class="line"><span class="class"><span class="keyword">data</span> = pd.concat([<span class="title">df_train</span>['<span class="type">SalePrice</span>'], <span class="title">df_train</span>[<span class="title">var</span>]], <span class="title">axis</span>=1)</span></div><div class="line"><span class="class"><span class="keyword">data</span>.plot.scatter(<span class="title">x</span>=<span class="title">var</span>, <span class="title">y</span>='<span class="type">SalePrice</span>', <span class="title">ylim</span>=(0,800000));</span></div></pre></td></tr></table></figure><p><img src="/img/18_03_11/003.png" alt=""></p><p><em>‘TotalBsmtSF’也是’SalePrice’的好朋友，但这似乎是一种更加情感化的关系！在一开始的时候，一切似乎都很顺利，突然间，他们的关系呈现出强烈的线性（指数？）反应，一切都在变化。此外，很明显，有时’TotalBsmtSF’本身就会关闭，并且对’SalePrice’给予零分。</em></p><p><strong>与类别特征的关系</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 绘制 OverallQual/SalePrice 的箱图</span></div><div class="line"><span class="attr">var</span> = 'OverallQual'</div><div class="line"><span class="attr">data</span> = pd.concat([df_train['SalePrice'], df_train[var]], <span class="attr">axis=1)</span></div><div class="line">f, <span class="attr">ax</span> = plt.subplots(<span class="attr">figsize=(8,</span> <span class="number">6</span>))</div><div class="line"><span class="attr">fig</span> = sns.boxplot(<span class="attr">x=var,</span> <span class="attr">y="SalePrice",</span> <span class="attr">data=data)</span></div><div class="line">fig.axis(<span class="attr">ymin=0,</span> <span class="attr">ymax=800000);</span></div></pre></td></tr></table></figure><p><img src="/img/18_03_11/004.png" alt=""></p><p><em>像所有漂亮女孩一样，’SalePrice’很享受’OverallQual’。提醒自己：考虑麦当劳是否适合作为第一次约会的场所。</em></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">var</span> = 'YearBuilt'</div><div class="line"><span class="attr">data</span> = pd.concat([df_train['SalePrice'], df_train[var]], <span class="attr">axis=1)</span></div><div class="line">f, <span class="attr">ax</span> = plt.subplots(<span class="attr">figsize=(16,</span> <span class="number">8</span>))</div><div class="line"><span class="attr">fig</span> = sns.boxplot(<span class="attr">x=var,</span> <span class="attr">y="SalePrice",</span> <span class="attr">data=data)</span></div><div class="line">fig.axis(<span class="attr">ymin=0,</span> <span class="attr">ymax=800000);</span></div><div class="line">plt.xticks(<span class="attr">rotation=90);</span></div></pre></td></tr></table></figure><p><img src="/img/18_03_11/005.png" alt=""></p><p><em>虽然这不是一个强烈的趋势，但我认为相比旧的东西，’SalePrice’更喜欢在新的东西上花钱</em></p><p><strong>注意：</strong>我们不知道’SalePrice’是否处于不变价格。不变的价格试图消除通货膨胀的影响。如果’SalePrice’价格不是固定的，那么它应该是这样的，因为多年来价格是可比的。</p><p><strong>综上所述</strong>，我们可以得出以下结论：</p><ul><li>‘GrLivArea’和’TotalBsmtSF’似乎与’SalePrice’线性相关。这两种关系都是积极的，这意味着随着一个变量增加，另一个变量也增加。在’TotalBsmtSF’的情况下，我们可以看到线性关系的斜率特别高。</li><li>‘OverallQual’和’YearBuilt’似乎也与’SalePrice’有关。在’OverallQual’的情况下，这种关系似乎更强一些，箱子图显示了销售价格随整体质量的变化情况。</li></ul><p>我们只分析了四个变量，但还有很多其他的我们应该分析。这里的诀窍似乎是选择正确的特征（特征选择），而不是它们之间复杂关系的定义（特征工程）。</p><h3 id="3-保持客观，理性工作"><a href="#3-保持客观，理性工作" class="headerlink" title="3.保持客观，理性工作"></a>3.保持客观，理性工作</h3><p>到现在为止，我们只是遵循我们的直觉，分析了我们认为重要的变量。尽管我们努力为我们的分析提供客观性，但我们必须说，我们的出发点是主观的。</p><p>作为一名工程师，我对这种方法感到不舒服。我所有的教育都是为了培养一个训练有素的头脑，能够抵挡主观性的思维。因为如果在结构工程中扮演主观性的角色，你会发现主观的想法是站不住脚的。</p><p>所以，让我们克服惯性，做一个更客观的分析。</p><p><strong>‘等离子汤’</strong></p><p>“一开始除了等离子汤以外没有其他任何东西。在我们研究宇宙学的时候，我们知道这些短暂的时刻，在很大程度上是推测得出的。然而，科学已经根据今天宇宙已知的情况设计了可能发生的事情的一些草图。’（来源：<a href="http://umich.edu/~gs265/bigbang.htm" target="_blank" rel="external">http://umich.edu/~gs265/bigbang.htm</a>）</p><p>为了探索宇宙，我们将从一些实用的食谱开始，以理解我们的“等离子汤”：</p><ul><li>相关矩阵（热图样式）。</li><li>‘SalePrice’相关矩阵（放大热图样式）。</li><li>最相关的变量之间的散点图（move like Jagger样式）</li></ul><p><strong>相关矩阵（热图样式）</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#相关矩阵</span></div><div class="line"><span class="attr">corrmat</span> = df_train.corr()</div><div class="line">f, <span class="attr">ax</span> = plt.subplots(<span class="attr">figsize=(12,</span> <span class="number">9</span>))</div><div class="line">sns.heatmap(corrmat, <span class="attr">vmax=.8,</span> <span class="attr">square=True);</span></div></pre></td></tr></table></figure><p><img src="/img/18_03_11/006.png" alt=""></p><p>在我看来，这张热图是快速了解我们的“等离子汤”及其关系的最佳方式。 （谢谢你@seaborn！）</p><p>乍一看，有两个红色的正方形引起了我的注意。第一个引用’TotalBsmtSF’和’1stFlrSF’变量，第二个引用’GarageX’变量。两种情况都表明这些变量之间的相关性有多大。实际上，这种相关性非常强，可以表明多重共线性的情况。如果我们考察了这些变量，我们可以得出相同的结论。热图非常适合检测这种情况，并且在像我们这样的特征选择占主导地位的问题中，它们是必不可少的工具。</p><p>另一件引起我注意的事情是’SalePrice’相关性。我们可以看到我们众所周知的’GrLivArea’，’TotalBsmtSF’和’OverallQual’这样明显的变量在向我们说“Hi！”，但我们也可以看到许多其他应该考虑的变量。这就是我们接下来要做的。</p><p><strong>‘SalePrice’相关矩阵（放大热图样式）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># SalePrice相关矩阵</span></div><div class="line">k = <span class="number">10</span> <span class="comment">#热图的变量数</span></div><div class="line">cols = corrmat.nlargest(k, <span class="string">'SalePrice'</span>)[<span class="string">'SalePrice'</span>].index</div><div class="line">cm = np.corrcoef(df_train[cols].values.T)</div><div class="line">sns.set(font_scale=<span class="number">1.25</span>)</div><div class="line">hm = sns.heatmap(cm, cbar=<span class="keyword">True</span>, annot=<span class="keyword">True</span>, square=<span class="keyword">True</span>, fmt=<span class="string">'.2f'</span>, annot_kws=&#123;<span class="string">'size'</span>: <span class="number">10</span>&#125;, yticklabels=cols.values, xticklabels=cols.values)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/007.png" alt=""></p><p>根据我们的水晶球显示，这些是与“SalePrice”最相关的变量。因此我得出以下结论：</p><ul><li>OverallQual’，’GrLivArea’和’TotalBsmtSF’与’SalePrice’密切相关。需要检查！</li><li>‘GarageCars’和’GarageArea’也是一些与强度相关的变量。但是，正如我们在最后一点所讨论的那样，车库所能容纳的车辆数量是车库面积的结果。’GarageCars’和’GarageArea’就像孪生兄弟。你永远无法区分它们。因此，我们只需要分析其中的一个变量（我们可以保留’GarageCars’，因为它与’SalePrice’的关联性更高）。</li><li>‘TotalBsmtSF’和’1stFloor’也似乎是双胞胎兄弟。我们可以只保留’TotalBsmtSF’（重新阅读’那么，我们能得到什么呢？’部分）。</li><li>‘FullBath’?? 真的需要吗?</li><li>‘TotRmsAbvGrd’和’GrLivArea’，再次是双胞胎兄弟。这是来自切尔诺贝利的数据集吗？</li><li>啊……’YearBuilt’……看起来’YearBuilt’与’SalePrice’略有关联。老实说，对于’YearBuilt’变量来说，我是有一些额外的顾虑的，因为这让我觉得我们应该做一些时间序列分析来分析这一变量。我会把这个问题作为你的homework。</li></ul><p>我们继续看散点图。</p><p>‘SalePrice’和相关变量之间的散点图（move like Jagger style）</p><p>前方高能！我第一次看到这些散点图的时候，我完全震惊了。</p><p>在如此短的空间里有如此多的信息.​​…..这真是太神奇了。再一次谢谢@seaborn！你让我’move like Jagger’！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 绘制散点图</span></div><div class="line">sns.set()</div><div class="line">cols = [<span class="string">'SalePrice'</span>, <span class="string">'OverallQual'</span>, <span class="string">'GrLivArea'</span>, <span class="string">'GarageCars'</span>, <span class="string">'TotalBsmtSF'</span>, <span class="string">'FullBath'</span>, <span class="string">'YearBuilt'</span>]</div><div class="line">sns.pairplot(df_train[cols], size = <span class="number">2.5</span>)</div><div class="line">plt.show();</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/008.png" alt=""></p><p>虽然我们已经知道一些主要的变量，但这个巨大的散点图给了我们关于变量关系的一个合理的解释。</p><p>我们可能会对’TotalBsmtSF’和’GrLiveArea’组成的散点图感兴趣。在这个图中，我们可以看到许多点画出了一条线，几乎就像一个边界。这种结果是完全有道理的，并且大多数的点保持在该线以下。地下室的面积可以等于地面上的居住面积，但预计地下室面积不会超过地上居住面积（除非你想购买的是地堡）。</p><p>关于’SalePrice’和’YearBuilt’的情况也可以让我们进一步思考。在“点云”的底部，我们看到一个看起来几乎是一个指数函数的曲线。我们也可以在’点云’的上限中看到同样的趋势。另外，请注意过去几年中的一系列点数是如何保持在这个极限之上的（我只是想说价格增速正在变快）。</p><p>好吧，现在我们已经完成了足够多的罗夏测试。让我们来探讨下一步的内容：缺失数据！</p><h3 id="4-缺失的数据"><a href="#4-缺失的数据" class="headerlink" title="4.缺失的数据"></a>4.缺失的数据</h3><p>在考虑缺失数据时的几个重要问题：</p><ul><li>缺失的数据有多普遍？</li><li>丢失数据是随机现象的还是有一定的规律？</li></ul><p>这些问题的答案很重要，因为缺少数据可能意味着样本量减少。这可能会使我们的分析工作无法进行。此外，从实质的角度来看，我们需要确保缺失的数据流程没有偏见，并确保没有将一些不易洞察的事实所隐藏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 缺失数据</span></div><div class="line">total = df_train.isnull().sum().sort_values(ascending=<span class="keyword">False</span>)</div><div class="line">percent = (df_train.isnull().sum()/df_train.isnull().count()).sort_values(ascending=<span class="keyword">False</span>)</div><div class="line">missing_data = pd.concat([total, percent], axis=<span class="number">1</span>, keys=[<span class="string">'Total'</span>, <span class="string">'Percent'</span>])</div><div class="line">missing_data.head(<span class="number">20</span>)</div></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Total</th><th style="text-align:left">Percent</th></tr></thead><tbody><tr><td style="text-align:left">PoolQC</td><td style="text-align:left">1453</td><td style="text-align:left">0.995205</td></tr><tr><td style="text-align:left">MiscFeature</td><td style="text-align:left">1406</td><td style="text-align:left">0.963014</td></tr><tr><td style="text-align:left">Alley</td><td style="text-align:left">1369</td><td style="text-align:left">0.937671</td></tr><tr><td style="text-align:left">Fence</td><td style="text-align:left">1179</td><td style="text-align:left">0.807534</td></tr><tr><td style="text-align:left">FireplaceQu</td><td style="text-align:left">690</td><td style="text-align:left">0.472603</td></tr><tr><td style="text-align:left">LotFrontage</td><td style="text-align:left">259</td><td style="text-align:left">0.177397</td></tr><tr><td style="text-align:left">GarageCond</td><td style="text-align:left">81</td><td style="text-align:left">0.055479</td></tr><tr><td style="text-align:left">GarageType</td><td style="text-align:left">81</td><td style="text-align:left">0.055479</td></tr><tr><td style="text-align:left">GarageYrBlt</td><td style="text-align:left">81</td><td style="text-align:left">0.055479</td></tr><tr><td style="text-align:left">GarageFinish</td><td style="text-align:left">81</td><td style="text-align:left">0.055479</td></tr><tr><td style="text-align:left">GarageQual</td><td style="text-align:left">81</td><td style="text-align:left">0.055479</td></tr><tr><td style="text-align:left">BsmtExposure</td><td style="text-align:left">38</td><td style="text-align:left">0.026027</td></tr><tr><td style="text-align:left">BsmtFinType2</td><td style="text-align:left">38</td><td style="text-align:left">0.026027</td></tr><tr><td style="text-align:left">BsmtFinType1</td><td style="text-align:left">37</td><td style="text-align:left">0.025342</td></tr><tr><td style="text-align:left">BsmtCond</td><td style="text-align:left">37</td><td style="text-align:left">0.025342</td></tr><tr><td style="text-align:left">BsmtQual</td><td style="text-align:left">37</td><td style="text-align:left">0.025342</td></tr><tr><td style="text-align:left">MasVnrArea</td><td style="text-align:left">8</td><td style="text-align:left">0.005479</td></tr><tr><td style="text-align:left">MasVnrType</td><td style="text-align:left">8</td><td style="text-align:left">0.005479</td></tr><tr><td style="text-align:left">Electrical</td><td style="text-align:left">1</td><td style="text-align:left">0.000685</td></tr><tr><td style="text-align:left">Utilities</td><td style="text-align:left">0</td><td style="text-align:left">0.000000</td></tr></tbody></table><p>让我们分析一下这个表里的信息，来理解如何处理丢失的数据。</p><p>我们会考虑当超过15％的数据丢失时，删除相应的变量并假设它从来都不存在。这意味着在这些情况下，我们不会尝试填补缺失数据。按照这个逻辑，我们应该删除一组变量（例如’PoolQC’，’MiscFeature’，’Alley’等）。这么做的重点是：我们会错过这些数据吗？我不这么认为。这些变量中没有一个看起来很重要，因为其中大多数不是我们在购买房屋时考虑的方面（或许这就是这些数据会缺失的原因？）。此外，仔细观察变量，像’PoolQC’，’MiscFeature’和’FireplaceQu’这样的变量是异常值的强有力候选者，所以我们很乐意删除它们。</p><p>在其余的案例中，我们可以看到“GarageX”系列的变量具有相同数量的缺失数据。我敢打赌，缺少的数据来自同一组观察结果（我不会检查它，缺失值只有5％的占比）。由于表示关于车库信息的最重要信息的字段是“GarageCars”，并且考虑到我们只是谈论了5％的缺失数据，所以我将删除提及的“GarageX”变量。同样的逻辑适用于’BsmtX’变量。</p><p>关于’MasVnrArea’和’MasVnrType’，我们可以认为这些变量不是必需的。此外，它们与已经考虑过的“YearBuilt”和“OverallQual”有很强的相关性。因此，如果我们删除’MasVnrArea’和’MasVnrType’这两个变量，我们不会丢失信息。</p><p>最后，我们在’Electrical’中有一个缺失的观察。由于这只是一个观察，我们将删除此记录并保留该变量。</p><p>总之，为了处理缺失的数据，我们将删除所有缺少数据的变量，但变量’Electrical’除外。在’Electrical’中，我们只需删除缺少数据的观察结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 缺失数据处理</span></div><div class="line">df_train = df_train.drop((missing_data[missing_data[<span class="string">'Total'</span>] &gt; <span class="number">1</span>]).index,<span class="number">1</span>)</div><div class="line">df_train = df_train.drop(df_train.loc[df_train[<span class="string">'Electrical'</span>].isnull()].index)</div><div class="line">df_train.isnull().sum().max() <span class="comment">#just checking that there's no missing data missing...</span></div></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure><h3 id="离群值！"><a href="#离群值！" class="headerlink" title="离群值！"></a>离群值！</h3><p>离群值也是我们应该意识到的。为什么？因为异常值可以显着影响我们的模型，并且可以成为宝贵的信息来源，为某些特定行为提供解释。</p><p>离群值是一个复杂的问题，值得给与更多关注。在这里，我们将通过“SalePrice”的标准偏差和一组散点图进行快速分析。</p><p><strong>单变量分析</strong></p><p>这里主要关心的是建立一个阈值，将观测定义为异常值。为此，我们将标准化数据。在此情况下，数据标准化意味着将数据值转换为平均值为0，标准偏差为1。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="section"># 标准化数据</span></div><div class="line">saleprice<span class="emphasis">_scaled = StandardScaler().fit_</span>transform(df_train[<span class="string">'SalePrice'</span>][<span class="symbol">:,np.newaxis</span>]);</div><div class="line">low<span class="emphasis">_range = saleprice_</span>scaled[<span class="string">saleprice_scaled[:,0</span>].argsort()][:10]</div><div class="line">high<span class="emphasis">_range= saleprice_</span>scaled[<span class="string">saleprice_scaled[:,0</span>].argsort()][-10:]</div><div class="line">print('outer range (low) of the distribution:')</div><div class="line">print(low_range)</div><div class="line">print('\nouter range (high) of the distribution:')</div><div class="line">print(high_range)</div></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">outer range (low) <span class="keyword">of</span> the distribution:</div><div class="line"><span class="comment">[<span class="comment">[-1.83820775]</span></span></div><div class="line"> <span class="comment">[-1.83303414]</span></div><div class="line"> <span class="comment">[-1.80044422]</span></div><div class="line"> <span class="comment">[-1.78282123]</span></div><div class="line"> <span class="comment">[-1.77400974]</span></div><div class="line"> <span class="comment">[-1.62295562]</span></div><div class="line"> <span class="comment">[-1.6166617 ]</span></div><div class="line"> <span class="comment">[-1.58519209]</span></div><div class="line"> <span class="comment">[-1.58519209]</span></div><div class="line"> <span class="comment">[-1.57269236]</span>]</div><div class="line"></div><div class="line">outer range (high) <span class="keyword">of</span> the distribution:</div><div class="line"><span class="comment">[<span class="comment">[3.82758058]</span></span></div><div class="line"> <span class="comment">[4.0395221 ]</span></div><div class="line"> <span class="comment">[4.49473628]</span></div><div class="line"> <span class="comment">[4.70872962]</span></div><div class="line"> <span class="comment">[4.728631  ]</span></div><div class="line"> <span class="comment">[5.06034585]</span></div><div class="line"> <span class="comment">[5.42191907]</span></div><div class="line"> <span class="comment">[5.58987866]</span></div><div class="line"> <span class="comment">[7.10041987]</span></div><div class="line"> <span class="comment">[7.22629831]</span>]</div></pre></td></tr></table></figure><p>对’SalePrice’的新衣服，感觉如何？：</p><ul><li>低范围值与0相似且不太远。</li><li>高范围值远离0，大概是7.多的值。</li></ul><p>目前，我们不会将这些值视为异常值，但我们应该小心这两个值。</p><p><strong>双变量分析</strong></p><p>我们已经了解了以下散点图。但是，当我们从新的角度来看事物时，总会有一些东西需要发现。正如Alan Kay所说，“视角的改变相当于提高80点智商”。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 双变量分析SalePrice/GrLivArea</span></div><div class="line"><span class="title">var</span> = '<span class="type">GrLivArea'</span></div><div class="line"><span class="class"><span class="keyword">data</span> = pd.concat([<span class="title">df_train</span>['<span class="type">SalePrice</span>'], <span class="title">df_train</span>[<span class="title">var</span>]], <span class="title">axis</span>=1)</span></div><div class="line"><span class="class"><span class="keyword">data</span>.plot.scatter(<span class="title">x</span>=<span class="title">var</span>, <span class="title">y</span>='<span class="type">SalePrice</span>', <span class="title">ylim</span>=(0,800000));</span></div></pre></td></tr></table></figure><p><img src="/img/18_03_11/009.png" alt=""></p><p>它所揭示的是：</p><ul><li>这两个变量中，更大的’GrLivArea’的数据看起来很奇怪，这些较大的’GrLivArea’离群了。我们可以推测为什么会发生这种情况。也许这些样本是农业领域的，这样想可以解释低价的原因。我不确定这一点，但我确信这两点并不代表典型案例。因此，我们将它们定义为异常值并删除它们。</li><li>顶部的两个观察结果是那些7.多的那两个，我们应该小心处理这些观察结果。他们看起来像两个特殊情况，但他们似乎正在追随上涨的趋势。出于这个原因，我们会保留它们。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">＃ 删除点</div><div class="line">df_train.sort_values(by = <span class="string">'GrLivArea'</span>, ascending = <span class="keyword">False</span>)[:<span class="number">2</span>]</div><div class="line">df_train = df_train.drop(df_train[df_train[<span class="string">'Id'</span>] == <span class="number">1299</span>].index)</div><div class="line">df_train = df_train.drop(df_train[df_train[<span class="string">'Id'</span>] == <span class="number">524</span>].index)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 双变量分析SalePrice/GrLivArea</span></div><div class="line">var = <span class="string">'TotalBsmtSF'</span></div><div class="line">data = pd.concat([df_train[<span class="string">'SalePrice'</span>], df_train[var]], axis=<span class="number">1</span>)</div><div class="line">data.plot.scatter(x=var, y=<span class="string">'SalePrice'</span>, ylim=(<span class="number">0</span>,<span class="number">800000</span>));</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/010.png" alt=""></p><p>我们可以想象消除一些观察结果（例如TotalBsmtSF&gt; 3000的结果），但我认为这么做不值得。我们可以接受这些值，所以我们不会做任何事情。</p><h3 id="5-硬核部分"><a href="#5-硬核部分" class="headerlink" title="5.硬核部分"></a>5.硬核部分</h3><p>在Ayn Rand的小说“阿特拉斯耸耸肩”中，有一个经常重复的问题：John Galt是谁？本书很大一部分是关于寻求发现这个问题的答案。</p><p>我现在体会到了Rand的感受，’SalePrice’是谁呢？</p><p>这个问题的答案在于测试多变量分析统计基础的假设。我们已经做了一些数据清理，并发现了很多关于’SalePrice’的信息。现在是深入了解’SalePrice’如何符合统计假设的时候了，这些假设使我们能够应用多元技术。</p><p>根据Hair et al. (2013)，我们应该测试四个假设：</p><ul><li><strong>正态性</strong> - 当我们谈论正态性时，我们的意思是数据应该看起来像正态分布。这很重要，因为几个统计测试依赖于此（例如t-statistics）。在本练习中，我们将检查’SalePrice’的单变量正态性（这是一种有限的方法）。请记住，单变量正态性并不能确保多元正态性（这是我们想要的），但这么做是有帮助的。需要考虑的另一个细节是，在大样本（&gt; 200个观测值）的情况下，正态性不是一个重要的问题。但是，如果我们解决正态性问题，就可以避免很多其他问题（例如异质性），这就是我们进行这种分析的主要原因。</li><li><strong>方差齐性</strong> - 希望我写的是对的。 方差齐性指的是“假设变量（一个或多个）在预测​​变量范围内表现出相同的方差水平”（Hair et al。，2013）。考虑方差齐性是合理的，因为我们希望误差项在自变量的所有值中都是相同的。</li><li><strong>线性</strong> - 评估线性的最常见方法是检查散点图并搜索线性模式。如果模式不是线性的，那么可以尝试探索数据转换。但是，在这里我们去转换数据，因为我们看到的大多数散点图似乎都具有线性关系。</li><li><strong>缺少相关错误</strong> - 如定义所示，相关的错误发生在一个错误与另一个错误相关时。例如，如果一个正误差系统地产生负误差，则意味着这些变量之间存在关系。这通常以时间序列发生，其中一些模式与时间相关。我们在这里不会涉及这一点。但是，如果您检测到某些内容，请尝试添加一个可以解释您获得的效果的变量。这是相关错误的最常见解决方案。</li></ul><p>你认为猫王会对这个漫长的解释说些什么？ ‘请少一点谈话，多一点行动’？可能……顺便说一下，你知道Elvis最后一次承受的重大的打击是什么吗？</p><p>(…)</p><p>是浴室的地板。</p><p><strong>寻找正态性</strong></p><p>这里的要点是以非常精益的方式测试’SalePrice’。我们将这样做：</p><ul><li><strong>直方图</strong> - 峰度和偏度。</li><li><strong>正态概率图</strong> - 数据分布应该紧跟代表正态分布的对角线。</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 直方图和正态概率图</span></div><div class="line">sns.distplot(df_train['SalePrice'], <span class="attr">fit=norm);</span></div><div class="line"><span class="attr">fig</span> = plt.figure()</div><div class="line"><span class="attr">res</span> = stats.probplot(df_train['SalePrice'], <span class="attr">plot=plt)</span></div></pre></td></tr></table></figure><p><img src="/img/18_03_11/011.png" alt=""></p><p><img src="/img/18_03_11/012.png" alt=""></p><p>好吧，’SalePrice’不服从正态分布。它显示’顶峰’呈现出正偏斜状态，并且不遵循对角线。</p><p>但一切都没有丢失。简单的数据转换可以解决问题。这是您可以在统计书籍中学到的很棒的东西之一：如果是正偏态，使用log函数转换通常效果不错。当我发现这一点时，我感觉自己就像一个霍格沃茨的学生发现了一个新的咒语一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">＃ 应用log函数转换</div><div class="line">df_train[<span class="string">'SalePrice'</span>] = np.log(df_train[<span class="string">'SalePrice'</span>])</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 转换的直方图和正态概率分布图</span></div><div class="line">sns.distplot(df_train[<span class="string">'SalePrice'</span>], fit=norm);</div><div class="line">fig = plt.figure()</div><div class="line">res = stats.probplot(df_train[<span class="string">'SalePrice'</span>], plot=plt)</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/013.png" alt=""></p><p><img src="/img/18_03_11/014.png" alt=""></p><p>完成！让我们来看看’GrLivArea’的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">＃ 直方图和正态概率分布图</div><div class="line">sns.distplot(df_train[<span class="string">'GrLivArea'</span>], fit=norm);</div><div class="line">fig = plt.figure()</div><div class="line">res = stats.probplot(df_train[<span class="string">'GrLivArea'</span>], plot=plt)</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/015.png" alt=""></p><p><img src="/img/18_03_11/016.png" alt=""></p><p>看起来有点歪…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 数据转换</span></div><div class="line">df_train[<span class="string">'GrLivArea'</span>] = np.log(df_train[<span class="string">'GrLivArea'</span>])</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 转换的直方图和正态概率分布图</span></div><div class="line">sns.distplot(df_train[<span class="string">'GrLivArea'</span>], fit=norm);</div><div class="line">fig = plt.figure()</div><div class="line">res = stats.probplot(df_train[<span class="string">'GrLivArea'</span>], plot=plt)</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/017.png" alt=""></p><p><img src="/img/18_03_11/018.png" alt=""></p><p>下一个…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 直方图和正态概率分布图</span></div><div class="line">sns.distplot(df_train[<span class="string">'TotalBsmtSF'</span>], fit=norm);</div><div class="line">fig = plt.figure()</div><div class="line">res = stats.probplot(df_train[<span class="string">'TotalBsmtSF'</span>], plot=plt)</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/019.png" alt=""></p><p><img src="/img/18_03_11/020.png" alt=""></p><p>好的，现在我们要处理几个大麻烦了：</p><ul><li>总体来说，数据分布呈现偏斜状态。</li><li>有大量的零值观察（比如没有地下室的房屋）。</li><li>0是不能求log的，这是一个很大的问题。</li></ul><p>为了在这里应用log转换，我们将创建一个变量来获得有或没有地下室（二进制变量）的效果。然后，我们将对所有非零观测值进行对数转换，忽略零值。这样我们就可以转换数据，而不会失去有或没有地下室的影响。</p><p>我不确定这种方法是否正确。但这对我来说似乎是正确的。这就是我所说的“高风险工程”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 为新变量创建列（一个足够了，因为它是一个二进制分类特征）</span></div><div class="line"><span class="comment"># 如果 area&gt;0 值为1，否则 值为0</span></div><div class="line">df_train[<span class="string">'HasBsmt'</span>] = pd.Series(len(df_train[<span class="string">'TotalBsmtSF'</span>]), index=df_train.index)</div><div class="line">df_train[<span class="string">'HasBsmt'</span>] = <span class="number">0</span> </div><div class="line">df_train.loc[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>,<span class="string">'HasBsmt'</span>] = <span class="number">1</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 数据转换</span></div><div class="line">df_train.loc[df_train[<span class="string">'HasBsmt'</span>]==<span class="number">1</span>,<span class="string">'TotalBsmtSF'</span>] = np.log(df_train[<span class="string">'TotalBsmtSF'</span>])</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 直方图和正态概率分布图</span></div><div class="line">sns.distplot(df_train[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>][<span class="string">'TotalBsmtSF'</span>], fit=norm);</div><div class="line">fig = plt.figure()</div><div class="line">res = stats.probplot(df_train[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>][<span class="string">'TotalBsmtSF'</span>], plot=plt)</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/021.png" alt=""></p><p><img src="/img/18_03_11/022.png" alt=""></p><p><strong>在第一次尝试中寻找“方差齐性”</strong></p><p>测试两个度量变量的同方差性的最佳方法是图形化。对不同特征使用相同的分布方式，生成锥形（样本在一侧分布的少，另一侧分布的多）或钻石（大量点分布在中心区域）等形状的分布情况。</p><p>绘制SalePrice’和’GrLivArea’的分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">＃散点图</div><div class="line">plt.scatter(df_train[<span class="string">'GrLivArea'</span>], df_train[<span class="string">'SalePrice'</span>]);</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/023.png" alt=""></p><p>此散点图的旧版本（在对数转换之前）具有圆锥形状（返回并检查’SalePrice’和相关变量之间的散点图（move like Jagger style））。如您所见，当前的散点图不再具有圆锥形状。这是正态化的力量！只要确保一些变量的正态性，我们解决了同方差问题。</p><p>我们继续检查’SalePrice’和’TotalBsmtSF’。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">＃散点图</div><div class="line">plt.scatter(df_train[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>][<span class="string">'TotalBsmtSF'</span>], df_train[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>][<span class="string">'SalePrice'</span>]);</div></pre></td></tr></table></figure><p><img src="/img/18_03_11/024.png" alt=""></p><p>总的来说，’SalePrice’在’TotalBsmtSF’范围内表现出相等的变化水平。Cool!</p><h3 id="Last-but-not-the-least-虚拟变量"><a href="#Last-but-not-the-least-虚拟变量" class="headerlink" title="Last but not the least, 虚拟变量"></a>Last but not the least, 虚拟变量</h3><p>简单模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">＃ 虚拟变量转换</div><div class="line">df_train = pd.get_dummies(df_train)</div></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>到了练习的最后部分。</p><p>在整个这个kernel中，我们实践了许多由Hair等人提出的策略。 （2013年）。我们对变量进行了哲学研究，我们单独分析了“SalePrice”，并且与最相关的变量进行了分析，我们处理了缺失的数据和异常值，我们测试了一些基本的统计假设，甚至将分类变量转换为虚拟变量。 Python帮助我们轻松完成了很多工作。</p><p>但是我们的任务还没有结束。别忘了，我们的故事还停留在对’SalePrice’的Facebook的研究那一步呢。现在是时候打电话给’SalePrice’并邀请她共进晚餐。试着预测她的行为。你认为她是一个喜欢正规化线性回归方法的女孩吗？或者你认为她喜欢合奏方法？或者也许别的东西？</p><p>答案由你找出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://pmarcelino.com/" target="_blank" rel="external">作者blog</a></p><p><a href="https://www.amazon.com/Multivariate-Data-Analysis-Joseph-Hair/dp/0138132631" target="_blank" rel="external">Hair等人，2013，多变量数据分析，第7版</a></p><h2 id="致谢-1"><a href="#致谢-1" class="headerlink" title="致谢"></a>致谢</h2><p>感谢JoãoRico的审阅。</p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/03/09/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91kaggle%E7%AB%9E%E8%B5%9B%20%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
