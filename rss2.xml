<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>studyAI</title>
    <link>http://studyai.site/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 27 Oct 2018 16:24:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>【傅里叶变换及其应用】01-周期性，三角函数表示复杂函数</title>
      <link>http://studyai.site/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/</link>
      <guid>http://studyai.site/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Sat, 27 Oct 2018 09:03:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://open.163.com/movie/2008/2/C/G/M7Q4BLENR_M7QBP61CG.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;课程视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本质上，傅里叶级数可以看做是&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://open.163.com/movie/2008/2/C/G/M7Q4BLENR_M7QBP61CG.html" target="_blank" rel="external">课程视频地址</a></p><p>本质上，傅里叶级数可以看做是<strong>用数学的手段研究周期性现象</strong>的一门学科。</p><p>我们在初中高中学过cos和sin这些三角函数，我们是否可以使用这些三角函数来建模非常广泛的周期性现象呢？这正是这节课需要解决的问题。</p><h3 id="如何使用简单的sin-t-，cos-t-来建模复杂的周期性现象？"><a href="#如何使用简单的sin-t-，cos-t-来建模复杂的周期性现象？" class="headerlink" title="如何使用简单的sin(t)，cos(t)来建模复杂的周期性现象？"></a>如何使用简单的sin(t)，cos(t)来建模复杂的周期性现象？</h3><p>首先，我们这里说的<strong>复杂的周期性现象</strong>会普遍到什么程度呢？我们希望把这些方法应用在普遍的条件下，但是并不是所有的现象都是周期性的（其实甚至在一些周期性的现象中，这个假定也未必行得通）。所以，<strong>并不是所有的现象都试用这个方法</strong>。</p><p>其实现实生活中的现象，最终都会结束，我们只观察某一个特定时间段的现象。而数学函数，比如正余弦函数，都是无始无终的。那么如何用它们来描述那些会结束的现象呢？</p><p>在面对实际的现象时，比如下面这种现象：</p><p><img src="/img/18_10_27/001.png" width="500" hegiht="313" align="center"></p><p>只存在于一个有限的时间段内，画出一个这样的信号。这并不是一个周期现象，但如果我们重复绘制这个图像，就可以强制使其成为周期性的函数了。</p><p><img src="/img/18_10_27/002.png" alt=""></p><p>或许我们只是对其中的一部分感兴趣，但对于数学分析，如果使其具有周期性，就对所有的都适用了。这个过程叫做<strong>信号的周期化（periodization of a signal）</strong>。它可以用于研究非周期性信号。</p><h4 id="信号周期化"><a href="#信号周期化" class="headerlink" title="信号周期化"></a>信号周期化</h4><p>我们通常把周期函数的周期设定为1，这样更加方便。因此函数$f(t)$需要满足：</p><ul><li>对任何$t$均有$f(t+1)=f(t)$，</li></ul><p>因此我们的信号模型可以表示为：</p><p>$$sin(2πt) \tag{1-1} $$    </p><p>以及</p><p>$$cos(2πt) \tag{1-2}$$</p><p><strong><em>如果我们知道一个周期为1的周期性函数在任意一个单位为1的时间间隔内的形式，那么我们就可以知道整个函数了。</em></strong></p><h4 id="生成复杂的周期函数"><a href="#生成复杂的周期函数" class="headerlink" title="生成复杂的周期函数"></a>生成复杂的周期函数</h4><p>那么我们如何用简单的sin和cos函数来表示各种复杂的周期现象呢？</p><p>事实上，我们可以通过对$sin(2πt)$和$cos(2πt)$进行变换和相加的方式来得到相当普遍的周期为1的周期函数。</p><h5 id="对正余弦函数进行变换"><a href="#对正余弦函数进行变换" class="headerlink" title="对正余弦函数进行变换"></a>对正余弦函数进行变换</h5><p>下图是$sin(2πt)$的函数图像，其周期为1，频率为1：</p><p><img src="/img/18_10_27/003.png" width="500" hegiht="313" align="center"></p><p>经过变换之后，$sin(4πt)$的函数图像如下，其周期为$1/2$，频率为2：</p><p><img src="/img/18_10_27/004.png" width="500" hegiht="313" align="center"></p><blockquote><p>其实你也可以说他的周期是1。因为一秒之内它经历了两个完整的周期，你可以把这两个完整的周期看做一个周期，图形在整个坐标轴上一直在重复这个原始信号。</p></blockquote><p>再次变换之后，$sin(6πt)$的函数图像如下，其周期为$1/3$，频率为3：</p><p><img src="/img/18_10_27/005.png" width="500" hegiht="313" align="center"></p><blockquote><p>同样，也可以把它看做周期是1。</p></blockquote><h5 id="对正余弦函数进行合并"><a href="#对正余弦函数进行合并" class="headerlink" title="对正余弦函数进行合并"></a>对正余弦函数进行合并</h5><p>现在把上面的三个函数合并：</p><p>$$<br>y=sin(2πt) + sin(4πt) + sin(6πt)<br>$$</p><p>其效果如下：</p><p><img src="/img/18_10_27/006.png" width="300" hegiht="313" align="center"></p><p>组合之后的函数周期为1，它由3个不同频率的周期函数组成，频率分布为1，2，3。但把它们组合起来之后，却只有一个周期：周期为1。</p><p>我们不仅可以改变频率，也可以单独改变幅度，并且可以改变其中每一个的相位。</p><h4 id="表示一个复杂的周期函数的几种方式"><a href="#表示一个复杂的周期函数的几种方式" class="headerlink" title="表示一个复杂的周期函数的几种方式"></a>表示一个复杂的周期函数的几种方式</h4><h5 id="最基本的形式"><a href="#最基本的形式" class="headerlink" title="最基本的形式"></a>最基本的形式</h5><p>一个复杂的周期为1的信号，可以通过变换一系列的正余弦函数的<strong>频率</strong>、<strong>幅度</strong>和<strong>相位</strong>，然后将它们<strong>加起来</strong>，来得到。</p><p>$$<br>y=\sum_{k=1}^N A_ksin(2πkt+φ_k) \tag{1-3}<br>$$</p><p>这是表示一个复杂周期的<strong>最一般</strong>的形式。</p><h5 id="利用和角公式来表示"><a href="#利用和角公式来表示" class="headerlink" title="利用和角公式来表示"></a>利用和角公式来表示</h5><p>正余弦和角公式：</p><p>$$<br>sin(2πkt+φ_k)=sin(2πkt) + cosφ_k + cos(2πkt) + sinφ_k<br>\tag{1-4}<br>$$ </p><p>因此我们可以将上面的公式$(1-3)$展开成以下形式：</p><p>$$<br>\begin{align*}<br>y&amp;=\sum_{k=1}^N A_k(sin(2πkt) + cosφ_k + cos(2πkt) + sinφ_k)\\<br>&amp;=\sum_k^N  (a_kcos(2πkt)+b_ksin(2πkt))<br>\tag{1-5}<br>\end{align*}<br>$$</p><p>这里的$a_k$和$b_k$是由A计算出的。</p><h5 id="加一个常数项的形式（直流分量形式）"><a href="#加一个常数项的形式（直流分量形式）" class="headerlink" title="加一个常数项的形式（直流分量形式）"></a>加一个常数项的形式（直流分量形式）</h5><p>$$<br>y = \frac{a_0}{2} + \sum_{k=1}^N  (a_kcos(2πkt)+b_ksin(2πkt))<br>\tag{1-6}<br>$$</p><p>这里的$\frac{a_0}{2}$是一个常数项，电器工程师常称之为<strong>直流分量(dc component)</strong>。因为电器工程师在研究交流电或直流电的过程中，发现有一部分是不随着周期发生改变的，这一部分称之为<strong>直流分量</strong>。</p><h5 id="复指数的表示形式"><a href="#复指数的表示形式" class="headerlink" title="复指数的表示形式"></a>复指数的表示形式</h5><p>上面几种都是比较常用的一些用于表示一个复杂信号的表示形式。但是迄今为止，最方便使用的还是用<strong>复指数</strong>的形式来表示：</p><p>$$<br>e^{2πkt}=cos(2πkt) + i*sin(2πkt)<br>\tag{1-7}<br>$$</p><p>在这里$i$的值为：</p><p>$$<br>i=\sqrt{-1}<br>\tag{1-8}<br>$$</p><p>根据著名的<strong>欧拉公式</strong>，我们可以用复指数的形式来表示正余弦函数，其中$cos$是实部，$sin$是虚部：</p><p>$$<br>cos(2πkt)=\frac{e^{2πikt}+e^{-2πikt}}{2}<br>\\<br>sin(2πkt)=\frac{e^{2πikt}-e^{-2πikt}}{2i}<br>\tag{1-9}<br>$$</p><p>你也可以将上面公式$(1-5)$的三角函数表示的和式的形式写成这种形式：</p><p>$$<br>\sum_{k=-n}^n C_ke^{2πikt}<br>\tag{1-10}<br>$$</p><p>在这里$C_k$是复数。</p><blockquote><p><strong>共轭</strong></p><p>对于复数$a + bi$来说，其共轭为$a - bi$。<br>复数$C_k$的共轭表示为$\bar{C_k}$</p><p>另外，如果一个复数等于其自身的共轭意味着什么呢？$C_0=\bar{C_0}$</p><p>这意味着这个数本身是实数。</p></blockquote><p>如果你试着把余弦表示的方式全部转成了复指数的形式，你会发现$C_k$不仅仅是复数，它同时还满足<strong>对称性</strong>。并且由于它的对称性，所以$\sum_{k=-n}^n C_k $的总和为实数。</p><p>即：$ C_{-k} $等于$C_k$的共轭：</p><p>$$<br>C_-k=\bar{C_k}<br>\tag{1-11}<br>$$</p><p>这是一条重要的性质。</p><p>反过来，如果和式的系数满足对称性，那么总和就应该是实数。这是因为可以把所有项分成正项和负项两组，并且由于$(1-11)$的对称关系，复数和复数的共轭的和结果是实数，可以得出这个结论。</p><h4 id="我们生成的复杂的周期函数，其普遍性有多强？"><a href="#我们生成的复杂的周期函数，其普遍性有多强？" class="headerlink" title="我们生成的复杂的周期函数，其普遍性有多强？"></a>我们生成的复杂的周期函数，其普遍性有多强？</h4><p>$f(t)$是周期为1的周期函数，我们可以把$f(t)$写成$(1-10)$那种形式吗？</p><p>$$<br>f(t)=\sum_{k=-n}^n C_ke^{2πikt}<br>\tag{1-12}<br>$$</p><p>换句话说，一个周期为1的复杂的周期函数，我们能用正余弦函数通过叠加变化以及组合来生成出来吗？</p><h5 id="假设我们能做到"><a href="#假设我们能做到" class="headerlink" title="假设我们能做到"></a>假设我们能做到</h5><p>假设我们可以做到用$(1-12)$来表示所有复杂的周期为1的周期函数，那么对于未知系数$C_k$我们如何求得呢？</p><p>以下是求$C_k$的过程：</p><p>$$<br>\begin{align*}<br>f(t)&amp;=\sum_{k=-n}^n C_ke^{2πikt}\\<br>&amp;=…+C_km^{2πikt}+…<br>\end{align*}<br>$$</p><p><img src="/img/18_10_27/007.png" alt=""></p><p>两边同时乘以$e^{-2\pi imt}$：</p><p><img src="/img/18_10_27/008.png" alt=""></p><p><img src="/img/18_10_27/009.png" alt=""></p><p>然后对两边同时求积分，积分区间是0到1，因为我们的频率是1：</p><p><img src="/img/18_10_27/010.png" alt=""></p><p>由于：</p><p><img src="/img/18_10_27/011.png" alt=""></p><p>所以：</p><p><img src="/img/18_10_27/012.png" alt=""></p><p><img src="/img/18_10_27/013.png" alt=""></p><p>其中：</p><p><img src="/img/18_10_27/014.png" alt=""></p><p><img src="/img/18_10_27/015.png" alt=""></p><p><img src="/img/18_10_27/016.png" alt=""></p><p><img src="/img/18_10_27/017.png" alt=""></p><p>这里的:</p><p><img src="/img/18_10_27/018.png" alt=""></p><p>是一个整数，就像$sin(2π)$乘以一个整数，这个整数是1，所以这里的结果是0。</p><p><img src="/img/18_10_27/019.png" alt=""></p><p>所以我们的$C_m$可以得到下面的结果：</p><p><img src="/img/18_10_27/020.png" alt=""></p><p>期初我们设定$f(t)$是已知的，所以我们就可以求得$C_m$了。</p><hr><p><strong>结论:</strong>给定周期为1的周期函数$f(t)$，如果能把$f(t)$写成和式的形式：$f(t)=\sum_{k=-n}^nC_ke^{2\pi ikt}$，那么溪水会按照这个公式给出，其中$C_k=\int_0^{1}e^{-2\pi ikt}f(t)dt$。</p><p>下节课我们将介绍，我们得到的这些参数，将带来什么意义。</p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NumPy入门教程</title>
      <link>http://studyai.site/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</link>
      <guid>http://studyai.site/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Fri, 11 May 2018 03:43:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;快速入门教程&quot;&gt;&lt;a href=&quot;#快速入门教程&quot; class=&quot;headerlink&quot; title=&quot;快速入门教程&quot;&gt;&lt;/a&gt;快速入门教程&lt;/h2&gt;&lt;h3 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="快速入门教程"><a href="#快速入门教程" class="headerlink" title="快速入门教程"></a>快速入门教程</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开始本教程之前，你需要有一定的Python基础。如果你想要回顾一下Python相关的知识点，你可以看一下<a href="http://docs.python.org/tut/" target="_blank" rel="external">这份教程</a>。</p><p>如果你希望运行本教程中的示例，那么需要在您机器上安装一些软件。有关说明，请参阅<a href="http://scipy.org/install.html" target="_blank" rel="external">http://scipy.org/install.html</a>。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>NumPy的主要对象是齐次多维数组。它是一个元素的表（元素通常是数字），所有的元素拥有相同的类型，可以被一个正整数元组来索引。在NumPy中维度称之为<strong><em>axis（轴）</em></strong>。</p><p>例如，在3D空间中的一个坐标点<code>[1, 2, 1]</code>拥有一个axis。这个axis拥有3个元素，所以我们说它的长度是3。在下面的例子中，有2个axis。第一个axis的长度是2，第二个axis的长度是3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[ <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</div><div class="line">[ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>]]</div></pre></td></tr></table></figure><pre><code>[[1.0, 0.0, 0.0], [0.0, 1.0, 2.0]]</code></pre><p>NumPy的数组class称之为<code>ndarray</code>。它还有另外一个别名：<code>array</code>。注意<code>numpy.array</code>与标准Python库中的<code>array.array</code>不一样，标准库中的<code>array</code>只可以操作以为数组，并且只能提供少量的方法。<code>ndarray</code>更重要的一些属性如下：</p><p><strong>ndarray.ndim</strong></p><pre><code>数组的axis(维度)数量</code></pre><p><strong>ndarray.shape</strong></p><pre><code>数组的维度。这是一个整数类型的元组，指示了数组在每个维度下的尺寸信息。对于一个n行m列的矩阵来说，它的`shape`是`(n,m)`。因此`shape`元组的长度，也是axis的数量，即`ndim`。</code></pre><p><strong>ndarray.size</strong></p><pre><code>数组的元素总数。值等于`shape`中的元素的乘积。</code></pre><p><strong>ndarray.dtype</strong></p><pre><code>一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外，也可以使用NumPy自己提供的一些类型。例如`numpy.int32`,`numpy.int16`和`numpy.float64`。</code></pre><p><strong>ndarray.itemsize</strong></p><pre><code>数组中每个元素占用的bytes大小。例如，一个数组的元素类型为`float64`，它的`itemsize`就是8(=64/8)，另一个数组的元素类型为`complex32`的`itemsize`值为4(=32/8)。这个值相当于`ndarray.dtype.itemsize`。</code></pre><p><strong>ndarray.data</strong></p><pre><code>该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引来访问数组中的元素。</code></pre><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 5)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.ndim</div></pre></td></tr></table></figure><pre><code>2</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.dtype.name</div></pre></td></tr></table></figure><pre><code>&apos;int64&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.itemsize</div></pre></td></tr></table></figure><pre><code>8</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.size</div></pre></td></tr></table></figure><pre><code>15</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type(a)</div></pre></td></tr></table></figure><pre><code>numpy.ndarray</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([6, 7, 8])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type(b)</div></pre></td></tr></table></figure><pre><code>numpy.ndarray</code></pre><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><p>有几种可以创建数组的方式。</p><p>例如，你可以通过使用<code>array</code>方法，从一个标准的Python列表或元组来创建一个numpy数组。数组的类型由序列中元素的类型自动推导得出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([2, 3, 4])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.dtype</div></pre></td></tr></table></figure><pre><code>dtype(&apos;int64&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.array([<span class="number">1.2</span>, <span class="number">3.5</span>, <span class="number">5.1</span>])</div><div class="line">b.dtype</div></pre></td></tr></table></figure><pre><code>dtype(&apos;float64&apos;)</code></pre><p>在调用<code>array</code>方法来创建数组时，有一种常见的错误，就是在方法中传入了多个数字，而不是通过传入一个包含一组数字的list作为参数。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   # WRONG</div><div class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) # RIGHT</div></pre></td></tr></table></figure><p><code>array</code>函数将序列的序列转换为二维数组，将序列的序列的序列转换成3维数组，等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.array([(<span class="number">1.5</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)])</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 1.5,  2. ,  3. ],       [ 4. ,  5. ,  6. ]])</code></pre><p>数组的类型也可以在创建的时候，显式的指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=complex)</div><div class="line">c</div></pre></td></tr></table></figure><pre><code>array([[ 1.+0.j,  2.+0.j],       [ 3.+0.j,  4.+0.j]])</code></pre><p>通常，数组的元素在初始状态下是未知的，但尺寸已知。因此，NumPy提供了一些方法来创建以初始化占位符填充的数组。这最大限度地减少了增加数组的开销，这是一项昂贵的操作。</p><p>方法<code>zeros</code>创建一个全部由0填充的数组，方法<code>ones</code>创建一个全部由1填充的数组，方法<code>empty</code>创建了一个全部由随机的数字填充的数组，随机数的值取决于内存当前的状态。默认情况下，创建出来的数组类型为<code>folat64</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.zeros((<span class="number">3</span>,<span class="number">4</span>))</div></pre></td></tr></table></figure><pre><code>array([[ 0.,  0.,  0.,  0.],       [ 0.,  0.,  0.,  0.],       [ 0.,  0.,  0.,  0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), dtype=np.int16) <span class="comment"># dtype可以被指定</span></div></pre></td></tr></table></figure><pre><code>array([[[1, 1, 1, 1],        [1, 1, 1, 1],        [1, 1, 1, 1]],       [[1, 1, 1, 1],        [1, 1, 1, 1],        [1, 1, 1, 1]]], dtype=int16)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 未初始化，输出可能不同</span></div></pre></td></tr></table></figure><pre><code>array([[ 0.,  0.,  0.],       [ 0.,  0.,  0.]])</code></pre><p>为了创建数字序列，NumPy提供了一个类似于<code>range</code>的返回数组而不是列表的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.arange(<span class="number">10</span>, <span class="number">30</span>, <span class="number">5</span>)</div></pre></td></tr></table></figure><pre><code>array([10, 15, 20, 25])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.arange(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0.3</span>) <span class="comment"># 可以接受float类型的参数</span></div></pre></td></tr></table></figure><pre><code>array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])</code></pre><p>当<code>arange</code>与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数<code>linspace</code>来接收我们想要的元素数量作为参数，而不是步长：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> pi</div><div class="line">np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>)  <span class="comment"># 创建9个数字，均匀分布在0到2之间</span></div></pre></td></tr></table></figure><pre><code>array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = np.linspace( <span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">100</span>)</div><div class="line">f = np.sin(x)</div></pre></td></tr></table></figure><h4 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h4><p>当你打印一个数组时，NumPy以一种类似嵌套列表的形式来展示，同时具有以下布局：</p><ul><li>最后一个axis从左向右打印</li><li>倒数第二个axis从上到下打印</li><li>其余的也是从上到下打印的，每个切片与下一个由空行分开。</li></ul><p>然后将一维数组打印为行，将二维数组作为矩阵，将三维数组作为矩阵列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># 一维数组</span></div><div class="line">print(a)</div></pre></td></tr></table></figure><pre><code>[0 1 2 3 4 5]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>)  <span class="comment"># 二维数组</span></div><div class="line">print(b)</div></pre></td></tr></table></figure><pre><code>[[ 0  1  2] [ 3  4  5] [ 6  7  8] [ 9 10 11]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 三维数组</span></div><div class="line">print(c)</div></pre></td></tr></table></figure><pre><code>[[[ 0  1  2  3]  [ 4  5  6  7]  [ 8  9 10 11]] [[12 13 14 15]  [16 17 18 19]  [20 21 22 23]]]</code></pre><p>如果数组太大而无法打印，NumPy将自动跳过数组的中心部分并仅打印角点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(np.arange(<span class="number">10000</span>))</div></pre></td></tr></table></figure><pre><code>[   0    1    2 ..., 9997 9998 9999]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>,<span class="number">100</span>))</div></pre></td></tr></table></figure><pre><code>[[   0    1    2 ...,   97   98   99] [ 100  101  102 ...,  197  198  199] [ 200  201  202 ...,  297  298  299] ...,  [9700 9701 9702 ..., 9797 9798 9799] [9800 9801 9802 ..., 9897 9898 9899] [9900 9901 9902 ..., 9997 9998 9999]]</code></pre><p>要禁用此行为并强制NumPy打印整个数组，可以使用<code>set_printoptions</code>更改打印选项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.set_printoptions(threshold=np.nan)</div></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>数组上的算术运算符应用于元素。一个新的数组被创建并填充结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = np.array([<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.arange(<span class="number">4</span>)</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = a-b</div><div class="line">c</div></pre></td></tr></table></figure><pre><code>array([20, 29, 38, 47])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b**<span class="number">2</span></div></pre></td></tr></table></figure><pre><code>array([0, 1, 4, 9])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>*np.sin(a)</div></pre></td></tr></table></figure><pre><code>array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a&lt;<span class="number">35</span></div></pre></td></tr></table></figure><pre><code>array([ True,  True, False, False], dtype=bool)</code></pre><p>不像其他的矩阵语言那样，<code>*</code>操作符在NumPy中是元素间的乘法。矩阵乘法可以使用<code>dot</code>方法来实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</div><div class="line">B = np.array([[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>]])</div><div class="line">A*B    <span class="comment"># 元素间的乘积</span></div></pre></td></tr></table></figure><pre><code>array([[2, 0],       [0, 4]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A.dot(B)   <span class="comment"># 矩阵乘法</span></div></pre></td></tr></table></figure><pre><code>array([[5, 4],       [3, 4]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.dot(A, B) <span class="comment"># 矩阵乘法的另一种实现</span></div></pre></td></tr></table></figure><pre><code>array([[5, 4],       [3, 4]])</code></pre><p>一些例如<code>+=</code>和<code>-=</code>的操作符，实现的方式是通过修改现有的矩阵而不是创建新的矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>), dtype=int)</div><div class="line">b = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</div><div class="line">a *= <span class="number">3</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[3, 3, 3],       [3, 3, 3]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b += a</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 3.05432455,  3.59941571,  3.65058751],       [ 3.85091779,  3.45890823,  3.55943444]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a += b <span class="comment"># b 不会自动的转型成为 integer 类型</span></div></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-87-3054fce39e6f&gt; in &lt;module&gt;()----&gt; 1 a += bTypeError: Cannot cast ufunc add output from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) with casting rule &apos;same_kind&apos;</code></pre><p>在使用不同类型的数组时，结果数组的类型对应于更一般或精确的数组（称为向上转型）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.ones(<span class="number">3</span>, dtype=np.int32)</div><div class="line">b = np.linspace(<span class="number">0</span>, pi, <span class="number">3</span>)</div><div class="line">b.dtype.name</div></pre></td></tr></table></figure><pre><code>&apos;float64&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = a+b</div><div class="line">c</div></pre></td></tr></table></figure><pre><code>array([ 1.        ,  2.57079633,  4.14159265])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.dtype.name</div></pre></td></tr></table></figure><pre><code>&apos;float64&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = np.exp(c*<span class="number">1j</span>)</div><div class="line">d</div></pre></td></tr></table></figure><pre><code>array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,       -0.54030231-0.84147098j])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d.dtype.name</div></pre></td></tr></table></figure><pre><code>&apos;complex128&apos;</code></pre><p>许多一元运算，例如计算数组中所有元素的总和，都是作为<code>ndarray</code>类的方法来实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 0.48681264,  0.52685408,  0.53980305],       [ 0.27958753,  0.55125855,  0.70834892]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.sum()</div></pre></td></tr></table></figure><pre><code>3.0926647737313067</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.min()</div></pre></td></tr></table></figure><pre><code>0.27958753466020847</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.max()</div></pre></td></tr></table></figure><pre><code>0.70834891569018965</code></pre><p>默认情况下，这些操作适用于数组，就好像它是数字列表一样，无论其形状如何。但是，通过指定<code>axis</code>参数，可以沿着数组的指定轴(axis)应用操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b.sum(axis=<span class="number">0</span>)    <span class="comment"># 每一列的和</span></div></pre></td></tr></table></figure><pre><code>array([12, 15, 18, 21])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b.min(axis=<span class="number">1</span>)    <span class="comment"># 每一行的最小值</span></div></pre></td></tr></table></figure><pre><code>array([0, 4, 8])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b.cumsum(axis=<span class="number">1</span>)   <span class="comment"># 每行的累加值</span></div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  3,  6],       [ 4,  9, 15, 22],       [ 8, 17, 27, 38]])</code></pre><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><p>NumPy提供了一些常见的数学运算方法，例如sin，cos和exp。在NumPy中，这些方法被称作”通用方法”(<code>ufunc</code>)。在NumPy中，这些方法操作在数组中的每个元素上，产生一个数组作为输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">B = np.arange(<span class="number">3</span>)</div><div class="line">B</div></pre></td></tr></table></figure><pre><code>array([0, 1, 2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.exp(B)</div></pre></td></tr></table></figure><pre><code>array([ 1.        ,  2.71828183,  7.3890561 ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.sqrt(B)</div></pre></td></tr></table></figure><pre><code>array([ 0.        ,  1.        ,  1.41421356])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C = np.array([<span class="number">2.</span>, <span class="number">-1.</span>, <span class="number">4.</span>])</div><div class="line">np.add(B, C)</div></pre></td></tr></table></figure><pre><code>array([ 2.,  0.,  6.])</code></pre><h4 id="索引，切片和迭代"><a href="#索引，切片和迭代" class="headerlink" title="索引，切片和迭代"></a>索引，切片和迭代</h4><p><strong>一维</strong>数组可以像Python中的list或其他序列一样进行索引、切片和迭代操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">10</span>)**<span class="number">3</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[<span class="number">2</span>]</div></pre></td></tr></table></figure><pre><code>8</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[<span class="number">2</span>:<span class="number">5</span>]</div></pre></td></tr></table></figure><pre><code>array([ 8, 27, 64])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[:<span class="number">6</span>:<span class="number">2</span>] = <span class="number">-1000</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[::<span class="number">-1</span>]</div></pre></td></tr></table></figure><pre><code>array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</div><div class="line">    print(i**(<span class="number">1</span>/<span class="number">3.</span>))</div></pre></td></tr></table></figure><pre><code>nan1.0nan3.0nan5.06.07.08.09.0/usr/local/Homebrew/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in power</code></pre><p><strong>多维</strong>数组每个轴（axis）都有一个索引。这些索引以逗号分隔的元组给出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">10</span>*x + y</div><div class="line"></div><div class="line">b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype=int)</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2,  3],       [10, 11, 12, 13],       [20, 21, 22, 23],       [30, 31, 32, 33],       [40, 41, 42, 43]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[<span class="number">2</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure><pre><code>23</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[<span class="number">0</span>:<span class="number">5</span>, <span class="number">1</span>] <span class="comment"># 输出第2列的每一行的元素</span></div></pre></td></tr></table></figure><pre><code>array([ 1, 11, 21, 31, 41])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[:, <span class="number">1</span>] <span class="comment"># 与上一步操作等价</span></div></pre></td></tr></table></figure><pre><code>array([ 1, 11, 21, 31, 41])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[<span class="number">1</span>:<span class="number">3</span>, :] <span class="comment"># 输出第2和第3行的每个列元素</span></div></pre></td></tr></table></figure><pre><code>array([[10, 11, 12, 13],       [20, 21, 22, 23]])</code></pre><p>当提供的索引数量少于axis的数量时，缺失的索引被视为完整的切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[<span class="number">-1</span>] <span class="comment"># 输出最后一行。相当于 b[-1,:]</span></div></pre></td></tr></table></figure><pre><code>array([40, 41, 42, 43])</code></pre><p>表达式<code>b[i]</code>的这种表示形式，意味着在<code>i</code>后面还有多个<code>:</code>，<code>:</code>的数量取决于剩余的axis数量。NumPy也允许你使用<code>...</code>来表示这一形式：<code>b[i,...]</code>。</p><p><strong>点</strong>(<code>...</code>)表示产生完整索引元组所需要的冒号。例如，如果<code>x</code>是一个5轴数组，那么：</p><ul><li><code>x[1,2,...]</code>等价于<code>x[1,2,:,:,:]</code>，</li><li><code>x[...,3]</code>等价于<code>x[:,:,:,:,3]</code>，</li><li><code>x[4,...,5,:]</code>等价于<code>x[4,:,:,5,:]</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一个3D数组（由两个2D数组粘贴而成）</span></div><div class="line">c = np.array([[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</div><div class="line">              [<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]],</div><div class="line">              [[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],</div><div class="line">              [<span class="number">110</span>,<span class="number">112</span>,<span class="number">113</span>]]</div><div class="line">             ])</div><div class="line">c.shape</div></pre></td></tr></table></figure><pre><code>(2, 2, 3)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c[<span class="number">1</span>,...]  <span class="comment"># 相当于 c[1,:,:] 或 c[1]</span></div></pre></td></tr></table></figure><pre><code>array([[100, 101, 102],       [110, 112, 113]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c[...,<span class="number">2</span>]  <span class="comment"># 相当于 c[:,:,2]</span></div></pre></td></tr></table></figure><pre><code>array([[  2,  13],       [102, 113]])</code></pre><p><strong>迭代</strong>多维数组是相对于第一个axis完成的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> b:</div><div class="line">    print(row)</div></pre></td></tr></table></figure><pre><code>[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43]</code></pre><p>但是，如果想要对数组中的每个元素执行操作，可以使用<code>flat</code>属性，该属性是数组中所有元素的迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</div><div class="line">    print(element)</div></pre></td></tr></table></figure><pre><code>012310111213202122233031323340414243</code></pre><h3 id="Shape操作"><a href="#Shape操作" class="headerlink" title="Shape操作"></a>Shape操作</h3><h4 id="改变一个array的shape"><a href="#改变一个array的shape" class="headerlink" title="改变一个array的shape"></a>改变一个array的shape</h4><p>一个数组的形状由这个数组每个轴上的元素数量给出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.,  6.,  4.],       [ 7.,  5.,  7.,  7.],       [ 3.,  1.,  8.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 4)</code></pre><p>数组的形状可以通过各种命令进行更改。请注意，以下三个命令都返回一个修改后的数组，但都没有改变原数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.ravel()  <span class="comment"># 返回展开的数组</span></div></pre></td></tr></table></figure><pre><code>array([ 8.,  3.,  6.,  4.,  7.,  5.,  7.,  7.,  3.,  1.,  8.,  8.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.reshape(<span class="number">6</span>,<span class="number">2</span>)  <span class="comment"># 返回一个改变了shape的数组</span></div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.],       [ 6.,  4.],       [ 7.,  5.],       [ 7.,  7.],       [ 3.,  1.],       [ 8.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.T  <span class="comment"># 返回数组的转置</span></div></pre></td></tr></table></figure><pre><code>array([[ 8.,  7.,  3.],       [ 3.,  5.,  1.],       [ 6.,  7.,  8.],       [ 4.,  7.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.T.shape</div></pre></td></tr></table></figure><pre><code>(4, 3)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 4)</code></pre><p>由ravel()产生的数组元素的顺序通常是”C-style”的，即最右边的索引“变化最快”，因此[0,0]之后的元素是[0,1]。如果一个数组变形为其他形状，数组再次被视为”C-style”。NumPy通常创建按次顺序存储的数组，因此<code>ravel()</code>通常不需要复制数组，但如果数组是通过对另一个数组进行切片操作，或者使用不寻常的方式创建的，则可能需要复制它。函数<code>ravel()</code>和<code>reshape()</code>也可以通过使用可选参数来使用FORTRAN-style的数组，其中最左侧的索引更改速度最快。</p><p><code>reshape</code>方法返回的结果是一个变形后的数组，而<code>ndarray.resize</code>方法会更改数组本身的形状：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.,  6.,  4.],       [ 7.,  5.,  7.,  7.],       [ 3.,  1.,  8.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a.resize((<span class="number">2</span>,<span class="number">6</span>))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.,  6.,  4.,  7.,  5.],       [ 7.,  7.,  3.,  1.,  8.,  8.]])</code></pre><p>如果在reshape操作中将尺寸参数传入-1，则会自动计算这一位置的尺寸：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.reshape(<span class="number">3</span>,<span class="number">-1</span>)</div></pre></td></tr></table></figure><pre><code>array([[ 8.,  3.,  6.,  4.],       [ 7.,  5.,  7.,  7.],       [ 3.,  1.,  8.,  8.]])</code></pre><h4 id="将不同的数组粘贴起来"><a href="#将不同的数组粘贴起来" class="headerlink" title="将不同的数组粘贴起来"></a>将不同的数组粘贴起来</h4><p>多个数组可以按照不同的axis来粘贴起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 9.,  9.],       [ 8.,  6.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">b</div></pre></td></tr></table></figure><pre><code>array([[ 5.,  3.],       [ 0.,  4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.vstack((a,b))</div></pre></td></tr></table></figure><pre><code>array([[ 9.,  9.],       [ 8.,  6.],       [ 5.,  3.],       [ 0.,  4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hstack((a,b))</div></pre></td></tr></table></figure><pre><code>array([[ 9.,  9.,  5.,  3.],       [ 8.,  6.,  0.,  4.]])</code></pre><p>函数<code>column_stack</code>将1D数组作为列堆叠到2D数组中。它相当于仅用于2D数组的<code>hstack</code>操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> newaxis</div><div class="line">np.column_stack((a,b))   <span class="comment"># 仅作用于2D数组</span></div></pre></td></tr></table></figure><pre><code>array([[ 9.,  9.,  5.,  3.],       [ 8.,  6.,  0.,  4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.array([<span class="number">4.</span>, <span class="number">2.</span>])</div><div class="line">b = np.array([<span class="number">3.</span>, <span class="number">8.</span>])</div><div class="line">np.column_stack((a,b))  <span class="comment"># 返回一个2D数组</span></div></pre></td></tr></table></figure><pre><code>array([[ 4.,  3.],       [ 2.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hstack((a,b))  <span class="comment"># 得到不同的结果</span></div></pre></td></tr></table></figure><pre><code>array([ 4.,  2.,  3.,  8.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[:,newaxis]  <span class="comment"># 这将得到一个2D列向量</span></div></pre></td></tr></table></figure><pre><code>array([[ 4.],       [ 2.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.column_stack((a[:,newaxis],b[:,newaxis]))</div></pre></td></tr></table></figure><pre><code>array([[ 4.,  3.],       [ 2.,  8.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hstack((a[:,newaxis],b[:,newaxis]))  <span class="comment"># 结果是一样的</span></div></pre></td></tr></table></figure><pre><code>array([[ 4.,  3.],       [ 2.,  8.]])</code></pre><p>另一方面，函数<code>row_stack</code>相当于对任何数组进行<code>vstack</code>操作。一般情况下，对于具有两个以上维度的数组，<code>hstack</code>操作沿着它的第二个axis进行堆叠，<code>vstack</code>沿着它的第一个axis堆叠，<code>concatenate</code>沿着指定axis的方向进度堆叠。</p><p><strong>注意</strong></p><p>在复杂的情况下，<code>r_</code>和<code>c_</code>可用于通过沿着一个轴堆积数字来创建数组。他们允许使用表示范围的<code>:</code>操作符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>]</div></pre></td></tr></table></figure><pre><code>array([1, 2, 3, 0, 4])</code></pre><p>当使用数组作为参数时，<code>r_</code>和<code>c_</code>与默认行为的<code>vstack</code>和<code>hstack</code>类似，可以通过可选参数指定所要连接的轴的序号。</p><h4 id="将一个数组拆分成几个较小的数组"><a href="#将一个数组拆分成几个较小的数组" class="headerlink" title="将一个数组拆分成几个较小的数组"></a>将一个数组拆分成几个较小的数组</h4><p>使用<code>hsplit</code>，可以沿着水平轴来切割数组，或者通过指定返回的数组的形状来切割数组，或者通过指定需要分割的列来分割数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">12</span>)))</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 4.,  3.,  3.,  1.,  2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],       [ 5.,  1.,  1.,  2.,  9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hsplit(a,<span class="number">3</span>)  <span class="comment"># 将a切分成3份</span></div></pre></td></tr></table></figure><pre><code>[array([[ 4.,  3.,  3.,  1.],        [ 5.,  1.,  1.,  2.]]), array([[ 2.,  5.,  2.,  5.],        [ 9.,  6.,  5.,  5.]]), array([[ 5.,  8.,  2.,  2.],        [ 0.,  8.,  8.,  7.]])]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.hsplit(a,(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 沿着第3和第4列来切分数组</span></div></pre></td></tr></table></figure><pre><code>[array([[ 4.,  3.,  3.],        [ 5.,  1.,  1.]]), array([[ 1.],        [ 2.]]), array([[ 2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],        [ 9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])]</code></pre><p><code>vspilt</code>沿着垂直轴进行分割，<code>array_split</code>允许指定沿着那个轴来进行分割。</p><h3 id="副本和视图"><a href="#副本和视图" class="headerlink" title="副本和视图"></a>副本和视图</h3><p>当操作一个数组时，它们的数据有时会被复制到一个新的数组中，有时则不会。这通常会让新手感到困惑。下面是3个例子：</p><h4 id="完全没有复制"><a href="#完全没有复制" class="headerlink" title="完全没有复制"></a>完全没有复制</h4><p>简单的赋值不会复制数组对象或数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>)</div><div class="line">b = a    <span class="comment"># 没有新的对象被创建</span></div><div class="line">b <span class="keyword">is</span> a   <span class="comment"># a 和 b 是同一个ndarray对象的两个名字</span></div></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b.shape = <span class="number">3</span>,<span class="number">4</span>  <span class="comment"># 改变a的shape</span></div><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 4)</code></pre><p>Python将可变对象作为引用传递，所以函数调用不会执行复制操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    print(id(x))</div><div class="line">    </div><div class="line">id(a)      <span class="comment"># id 是一个对象的唯一标识</span></div></pre></td></tr></table></figure><pre><code>4449897488</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(a)</div></pre></td></tr></table></figure><pre><code>4449897488</code></pre><h4 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h4><p>不同的数组对象可以共享相同的数据。<code>view</code>函数创建一个新的数组对象，但它和原数组持有相同的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = a.view()</div><div class="line">c <span class="keyword">is</span> a</div></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.base <span class="keyword">is</span> a  <span class="comment"># c 是 一个a数据所创建出来的视图</span></div></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.flags.owndata</div></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c.shape = <span class="number">2</span>,<span class="number">6</span>  <span class="comment"># a的shape并不发生改变</span></div><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(3, 4)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span>  <span class="comment"># a的数据发生改变</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[   0,    1,    2,    3],       [1234,    5,    6,    7],       [   8,    9,   10,   11]])</code></pre><p>对一个数组进行切片操作，返回它的一个视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = a[ : , <span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 也可以被写作 s = a[:,1:3]</span></div><div class="line">s[:] = <span class="number">10</span>  <span class="comment"># s[:] 是一个s的视图。注意这里 s = 10 和 s[:] = 10 的区别</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[   0,   10,   10,    3],       [1234,   10,   10,    7],       [   8,   10,   10,   11]])</code></pre><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><code>copy</code>方法可以构造数组以及数据的完整副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = a.copy()    <span class="comment"># 一个由新数据构成的新的数组对象被创建了</span></div><div class="line">d <span class="keyword">is</span> a</div></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d.base <span class="keyword">is</span> a     <span class="comment"># d 与 a 不共享任何东西</span></div></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">9999</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[   0,   10,   10,    3],       [1234,   10,   10,    7],       [   8,   10,   10,   11]])</code></pre><h4 id="方法预览"><a href="#方法预览" class="headerlink" title="方法预览"></a>方法预览</h4><p>这里有一个NumPy中各种类型的比较有用的方法列表。</p><ul><li><p><strong>数组创建</strong></p><p><code>arange</code>,<code>array</code>,<code>copy</code>,<code>empty</code>,<code>empty_like</code>,<code>eye</code>,<code>fromfile</code>,<code>fromfunction</code>,<code>identity</code>,<code>linspace</code>,<code>logspace</code>,<code>mgrid</code>,<code>ogrid</code>,<code>ones</code>,<code>ones_like</code>,<code>zeros</code>,<code>zeros_like</code></p></li><li><p><strong>转换</strong></p><p>  <code>ndarray.astype</code>,<code>atleast_1d</code>,<code>atleast_2d</code>,<code>atleast_3d</code>,<code>mat</code></p></li><li><p><strong>手法</strong></p><p>  <code>array_split</code>, <code>column_stack</code>, <code>concatenate</code>, <code>diagonal</code>, <code>dsplit, dstack</code>, <code>hsplit</code>, <code>hstack</code>, <code>ndarray.item</code>, <code>newaxis</code>, <code>ravel</code>, <code>repeat</code>, <code>reshape</code>, <code>resize</code>, <code>squeeze</code>, <code>swapaxes</code>, <code>take</code>, <code>transpose</code>, <code>vsplit</code>, <code>vstack</code></p></li><li><p><strong>问题</strong></p><p>  <code>all</code>, <code>any</code>, <code>nonzero</code>, <code>where</code></p></li><li><p><strong>排序</strong></p><p>  <code>argmax</code>, <code>argmin</code>, <code>argsort</code>, <code>max</code>, <code>min</code>, <code>ptp</code>, <code>searchsorted</code>, <code>sort</code></p></li><li><p><strong>操作</strong></p><p>  <code>choose</code>, <code>compress</code>, <code>cumprod</code>, <code>cumsum</code>, <code>inner</code>, <code>ndarray.fill</code>, <code>imag</code>, <code>prod</code>, <code>put</code>, <code>putmask</code>, <code>real</code>, <code>sum</code></p></li><li><p><strong>基本统计</strong></p><p>  <code>cov</code>,<code>mean</code>,<code>std</code>,<code>var</code></p></li><li><p><strong>基本线性代数</strong></p><p>  <code>cross</code>,<code>dot</code>,<code>outer</code>,<code>linalg.svd</code>,<code>vdot</code></p></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><p>广播允许通用方法以有意义的方式处理形状不完全相同的输入。</p><p>广播第一法则是，如果所有的输入数组维度不都相同，一个“1”将被重复地添加在维度较小的数组上直至所有的数组拥有一样的维度。</p><p>广播第二法则确定长度为1的数组沿着特殊的方向表现地好像它有沿着那个方向最大形状的大小。对数组来说，沿着那个维度的数组元素的值理应相同。</p><p>应用广播法则之后，所有数组的大小必须匹配。更多细节可以从这个<a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="external">文档</a>找到。</p><h3 id="花哨的索引和索引技巧"><a href="#花哨的索引和索引技巧" class="headerlink" title="花哨的索引和索引技巧"></a>花哨的索引和索引技巧</h3><p>NumPy提供比常规Python序列更多的索引功能。正如我们前面看到的，除了通过整数和切片进行索引之外，还可以使用整数和布尔数组数组对索引进行索引。</p><h4 id="通过数组索引"><a href="#通过数组索引" class="headerlink" title="通过数组索引"></a>通过数组索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>)**<span class="number">2</span>          <span class="comment"># 前12个方格</span></div><div class="line">i = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>])     <span class="comment"># 一个索引数组</span></div><div class="line">a[i]                          <span class="comment"># 一个在位置i的元素</span></div></pre></td></tr></table></figure><pre><code>array([ 1,  1,  9, 64, 25])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">j = np.array([[ <span class="number">3</span>, <span class="number">4</span>], [ <span class="number">9</span>, <span class="number">7</span>]])  <span class="comment"># 一个二维索引数组</span></div><div class="line">a[j]                              <span class="comment"># 与j的shape相同</span></div></pre></td></tr></table></figure><pre><code>array([[ 9, 16],       [81, 49]])</code></pre><p>当被索引数组<code>a</code>是多维的时，每一个唯一的索引数列指向<code>a</code>的第一维。以下示例通过将图片标签用调色版转换成色彩图像展示了这种行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">palette = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],           <span class="comment"># 黑</span></div><div class="line">                    [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],         <span class="comment"># 红</span></div><div class="line">                    [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],         <span class="comment"># 绿</span></div><div class="line">                    [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],         <span class="comment"># 蓝</span></div><div class="line">                    [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]      <span class="comment"># 白</span></div><div class="line">                   ])</div><div class="line">image = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],           <span class="comment"># 每个值对应调色板中的颜色</span></div><div class="line">                  [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>]</div><div class="line">                 ])</div><div class="line"></div><div class="line">palette[image]</div></pre></td></tr></table></figure><pre><code>array([[[  0,   0,   0],        [255,   0,   0],        [  0, 255,   0],        [  0,   0,   0]],       [[  0,   0,   0],        [  0,   0, 255],        [255, 255, 255],        [  0,   0,   0]]])</code></pre><p>我们也可以给出不不止一维的索引，每一维的索引数组必须有相同的形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i = np.array([[<span class="number">0</span>,<span class="number">1</span>],    <span class="comment"># indices for the first dim of a</span></div><div class="line">             [<span class="number">1</span>,<span class="number">2</span>]])</div><div class="line"></div><div class="line">j = np.array([[<span class="number">2</span>,<span class="number">1</span>],    <span class="comment"># indices for the second dim</span></div><div class="line">             [<span class="number">3</span>,<span class="number">3</span>]])</div><div class="line"></div><div class="line">a[i,j]                  <span class="comment"># i 和 j必须拥有相同的shape</span></div></pre></td></tr></table></figure><pre><code>array([[ 2,  5],       [ 7, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[i,<span class="number">2</span>]</div></pre></td></tr></table></figure><pre><code>array([[ 2,  6],       [ 6, 10]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[:,j]</div></pre></td></tr></table></figure><pre><code>array([[[ 2,  1],        [ 3,  3]],       [[ 6,  5],        [ 7,  7]],       [[10,  9],        [11, 11]]])</code></pre><p>当然，我们可以将<code>i</code>和<code>j</code>放入一个序列中（比如说一个列表），然后用列表进行索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">l = [i,j]</div><div class="line">a[l]        <span class="comment"># 相当于一个[i,j]</span></div></pre></td></tr></table></figure><pre><code>array([[ 2,  5],       [ 7, 11]])</code></pre><p>但是，我们不能将<code>i</code>和<code>j</code>放进一个数组，因为这个数组将被解读为a的第一个维度的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = np.array([i,j])</div><div class="line">a[s]     <span class="comment"># 结果不是我们想要的</span></div></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------IndexError                                Traceback (most recent call last)&lt;ipython-input-204-79ccae1d198c&gt; in &lt;module&gt;()      1 s = np.array([i,j])----&gt; 2 a[s]     # 结果不是我们想要的IndexError: index 3 is out of bounds for axis 0 with size 3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[tuple(s)]     <span class="comment"># 与 a[i,j]相同</span></div></pre></td></tr></table></figure><pre><code>array([[ 2,  5],       [ 7, 11]])</code></pre><p>另一个常用的数组索引用法是搜索时间序列最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">time = np.linspace(<span class="number">20</span>, <span class="number">145</span>, <span class="number">5</span>)    <span class="comment"># 时间尺度</span></div><div class="line">data = np.sin(np.arange(<span class="number">20</span>)).reshape(<span class="number">5</span>,<span class="number">4</span>)  <span class="comment"># 4个时间依赖序列</span></div><div class="line">time</div></pre></td></tr></table></figure><pre><code>array([  20.  ,   51.25,   82.5 ,  113.75,  145.  ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data</div></pre></td></tr></table></figure><pre><code>array([[ 0.        ,  0.84147098,  0.90929743,  0.14112001],       [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],       [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],       [-0.53657292,  0.42016704,  0.99060736,  0.65028784],       [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ind = data.argmax(axis=<span class="number">0</span>)    <span class="comment"># 每个序列的最大值的索引</span></div><div class="line">ind</div></pre></td></tr></table></figure><pre><code>array([2, 0, 3, 1])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">time_max = time[ind]         <span class="comment"># 时间序列对应的最大值</span></div><div class="line">data_max = data[ind, range(data.shape[<span class="number">1</span>])]  <span class="comment"># =&gt; data[ind[0],0], data[ind[1],1]...</span></div><div class="line"></div><div class="line">time_max</div></pre></td></tr></table></figure><pre><code>array([  82.5 ,   20.  ,  113.75,   51.25])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data_max</div></pre></td></tr></table></figure><pre><code>array([ 0.98935825,  0.84147098,  0.99060736,  0.6569866 ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.all(data_max == data.max(axis=<span class="number">0</span>))</div></pre></td></tr></table></figure><pre><code>True</code></pre><p>你也可以使用数组索引作为目标来赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">5</span>)</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3, 4])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]] = <span class="number">0</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([0, 0, 2, 0, 0])</code></pre><p>然而，当一个索引列表包含重复时，赋值被多次完成，保留最后一次的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">5</span>)</div><div class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([2, 1, 3, 3, 4])</code></pre><p>这足够合理，但是小心如果你想用Python的<code>+=</code>结构，可能结果并非你所期望：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">5</span>)</div><div class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]] += <span class="number">1</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([1, 1, 3, 3, 4])</code></pre><p>即使0在索引列表中出现两次，索引为0的元素仅仅增加一次。这是因为Python要求<code>a+=1</code>和<code>a=a+1</code>等同。</p><h4 id="通过布尔数组索引"><a href="#通过布尔数组索引" class="headerlink" title="通过布尔数组索引"></a>通过布尔数组索引</h4><p>当我们使用整数数组索引数组时，我们提供一个索引列表去选择。通过布尔数组索引的方法是不同的我们显式地选择数组中我们想要和不想要的元素。</p><p>我们能想到的使用布尔数组的索引最自然方式就是使用和原数组一样形状的布尔数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">b = a &gt; <span class="number">4</span></div><div class="line">b                   <span class="comment"># b 是一个和a形状相同的boolean数组</span></div></pre></td></tr></table></figure><pre><code>array([[False, False, False, False],       [False,  True,  True,  True],       [ True,  True,  True,  True]], dtype=bool)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[b]                <span class="comment"># 经过筛选后的1维数组</span></div></pre></td></tr></table></figure><pre><code>array([ 5,  6,  7,  8,  9, 10, 11])</code></pre><p>这个属性在赋值时非常有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a[b] = <span class="number">0</span>            <span class="comment"># 将a中所有比4大的元素赋值为0</span></div><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[0, 1, 2, 3],       [4, 0, 0, 0],       [0, 0, 0, 0]])</code></pre><p>你可以参考曼德博集合示例看看如何使用布尔索引来生成<a href="http://en.wikipedia.org/wiki/Mandelbrot_set" target="_blank" rel="external">曼德博集合</a>的图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mandelbrot</span><span class="params">(h,w,maxit=<span class="number">20</span>)</span>:</span></div><div class="line">    <span class="string">"""返回一个尺寸为（h,w）的曼德博分形图"""</span></div><div class="line">    y,x = np.ogrid[ <span class="number">-1.4</span>:<span class="number">1.4</span>:h*<span class="number">1j</span>, <span class="number">-2</span>:<span class="number">0.8</span>:w*<span class="number">1j</span>]</div><div class="line">    c = x+y * <span class="number">1j</span></div><div class="line">    z = c</div><div class="line">    divtime = maxit + np.zeros(z.shape,dtype=int)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(maxit):</div><div class="line">        z = z**<span class="number">2</span> + c</div><div class="line">        diverge = z*np.conj(z) &gt; <span class="number">2</span>**<span class="number">2</span>    <span class="comment"># who is diverging</span></div><div class="line">        div_now = diverge &amp; (divtime == maxit)  <span class="comment"># who is diverging now</span></div><div class="line">        divtime[div_now] = i                    <span class="comment"># note when</span></div><div class="line">        z[diverge] = <span class="number">2</span>                          <span class="comment"># avoid diverging too much</span></div><div class="line">        </div><div class="line">    <span class="keyword">return</span> divtime</div><div class="line"></div><div class="line">plt.imshow(mandelbrot(<span class="number">400</span>,<span class="number">400</span>))</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/img/18_05_11/output_194_0.png" alt="png"></p><p>第二种通过布尔来索引的方法更近似于整数索引；对数组的每个维度我们给一个一维布尔数组来选择我们想要的切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">b1 = np.array([<span class="keyword">False</span>,<span class="keyword">True</span>,<span class="keyword">True</span>])    <span class="comment"># 第一维的筛选</span></div><div class="line">b2 = np.array([<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="keyword">True</span>,<span class="keyword">False</span>])  <span class="comment"># 第二维的筛选</span></div><div class="line"></div><div class="line">a[b1,:]       <span class="comment"># 选择行</span></div></pre></td></tr></table></figure><pre><code>array([[ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[b1]         <span class="comment"># 和上面相同</span></div></pre></td></tr></table></figure><pre><code>array([[ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[:,b2]       <span class="comment"># 选择列</span></div></pre></td></tr></table></figure><pre><code>array([[ 0,  2],       [ 4,  6],       [ 8, 10]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[b1,b2]      <span class="comment"># 一个奇怪的结果</span></div></pre></td></tr></table></figure><pre><code>array([ 4, 10])</code></pre><p>注意一维数组的长度必须和你想要切片的维度或轴的长度一致，在之前的例子中，<code>b1</code>是一个秩为1长度为三的数组(<code>a</code>的行数)，<code>b2</code>(长度为4)与<code>a</code>的第二秩(列)相一致。</p><h4 id="ix-函数"><a href="#ix-函数" class="headerlink" title="ix_()函数"></a>ix_()函数</h4><p><code>ix_</code>函数可以为了获得多元组的结果而用来结合不同向量。例如，如果你想要用所有向量a、b和c元素组成的三元组来计算a+b*c：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line">b = np.array([<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>])</div><div class="line">c = np.array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>])</div><div class="line">ax,bx,cx = np.ix_(a,b,c)</div><div class="line">ax</div></pre></td></tr></table></figure><pre><code>array([[[2]],       [[3]],       [[4]],       [[5]]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bx</div></pre></td></tr></table></figure><pre><code>array([[[8],        [5],        [4]]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cx</div></pre></td></tr></table></figure><pre><code>array([[[5, 4, 6, 8, 3]]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ax.shape, bx.shape, cx.shape</div></pre></td></tr></table></figure><pre><code>((4, 1, 1), (1, 3, 1), (1, 1, 5))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = ax + bx * cx</div><div class="line">result</div></pre></td></tr></table></figure><pre><code>array([[[42, 34, 50, 66, 26],        [27, 22, 32, 42, 17],        [22, 18, 26, 34, 14]],       [[43, 35, 51, 67, 27],        [28, 23, 33, 43, 18],        [23, 19, 27, 35, 15]],       [[44, 36, 52, 68, 28],        [29, 24, 34, 44, 19],        [24, 20, 28, 36, 16]],       [[45, 37, 53, 69, 29],        [30, 25, 35, 45, 20],        [25, 21, 29, 37, 17]]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</div></pre></td></tr></table></figure><pre><code>17</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[<span class="number">3</span>] + b[<span class="number">2</span>] * c[<span class="number">4</span>]</div></pre></td></tr></table></figure><pre><code>17</code></pre><p>你也可以实行如下简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ufunc_reduce</span><span class="params">(ufct, *vectors)</span>:</span></div><div class="line">    vs = np.ix_(*vectors)</div><div class="line">    r = ufct.identity</div><div class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> vs:</div><div class="line">        r = ufct(r,v)</div><div class="line">    <span class="keyword">return</span> r</div></pre></td></tr></table></figure><p>然后这样使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ufunc_reduce(np.add,a,b,c)</div></pre></td></tr></table></figure><pre><code>array([[[15, 14, 16, 18, 13],        [12, 11, 13, 15, 10],        [11, 10, 12, 14,  9]],       [[16, 15, 17, 19, 14],        [13, 12, 14, 16, 11],        [12, 11, 13, 15, 10]],       [[17, 16, 18, 20, 15],        [14, 13, 15, 17, 12],        [13, 12, 14, 16, 11]],       [[18, 17, 19, 21, 16],        [15, 14, 16, 18, 13],        [14, 13, 15, 17, 12]]])</code></pre><p>这个reduce与ufunc.reduce(比如说add.reduce)相比的优势在于它利用了广播法则，避免了创建一个输出大小乘以向量个数的参数数组。</p><h4 id="用字符串索引"><a href="#用字符串索引" class="headerlink" title="用字符串索引"></a>用字符串索引</h4><p>参加<a href="https://docs.scipy.org/doc/numpy/user/basics.rec.html#structured-arrays" target="_blank" rel="external">结构化数组</a>。</p><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>继续前进，基本线性代数包含在这里。</p><h4 id="简单数组运算"><a href="#简单数组运算" class="headerlink" title="简单数组运算"></a>简单数组运算</h4><p>参考numpy文件夹中的linalg.py获得更多信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">a = np.array([[<span class="number">1.0</span>,<span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</div><div class="line">print(a)</div></pre></td></tr></table></figure><pre><code>[[ 1.  2.] [ 3.  4.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.transpose()</div></pre></td></tr></table></figure><pre><code>array([[ 1.,  3.],       [ 2.,  4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.linalg.inv(a)</div></pre></td></tr></table></figure><pre><code>array([[-2. ,  1. ],       [ 1.5, -0.5]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">u = np.eye(<span class="number">2</span>) <span class="comment"># unit 2x2 matrix; "eye" represents "I"  单位矩阵</span></div><div class="line">u</div></pre></td></tr></table></figure><pre><code>array([[ 1.,  0.],       [ 0.,  1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">j = np.array([[<span class="number">0.0</span>, <span class="number">-1.0</span>], [<span class="number">1.0</span>, <span class="number">0.0</span>]])</div><div class="line">np.dot(j, j)   <span class="comment"># 矩阵乘法</span></div></pre></td></tr></table></figure><pre><code>array([[-1.,  0.],       [ 0., -1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.trace(u)    <span class="comment"># trace</span></div></pre></td></tr></table></figure><pre><code>2.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y = np.array([[<span class="number">5.</span>],[<span class="number">7.</span>]])</div><div class="line">np.linalg.solve(a, y)</div></pre></td></tr></table></figure><pre><code>array([[-3.],       [ 4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.linalg.eig(j)</div></pre></td></tr></table></figure><pre><code>(array([ 0.+1.j,  0.-1.j]), array([[ 0.70710678+0.j        ,  0.70710678-0.j        ],        [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]]))</code></pre><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Parameters</span>:</div><div class="line">    square matrix</div><div class="line"><span class="symbol">Returns</span></div><div class="line">    <span class="symbol">The</span> eigenvalues, each repeated according to its multiplicity.</div><div class="line">    <span class="symbol">The</span> normalized (unit <span class="string">"length"</span>) eigenvectors, such that the</div><div class="line">    column <span class="string">``</span>v[:,i]<span class="string">``</span> is the eigenvector corresponding to the</div><div class="line">    eigenvalue <span class="string">``</span>w[i]<span class="string">``</span> .</div></pre></td></tr></table></figure><h3 id="技巧和提示"><a href="#技巧和提示" class="headerlink" title="技巧和提示"></a>技巧和提示</h3><p>下面我们给出简短和有用的提示。</p><h4 id="“自动”改变形状"><a href="#“自动”改变形状" class="headerlink" title="“自动”改变形状"></a>“自动”改变形状</h4><p>更改数组的维度，你可以省略一个尺寸，它将被自动推导出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">30</span>)</div><div class="line">a.shape = <span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>  <span class="comment"># -1 意味着 “无论需要什么”</span></div><div class="line">a.shape</div></pre></td></tr></table></figure><pre><code>(2, 5, 3)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a</div></pre></td></tr></table></figure><pre><code>array([[[ 0,  1,  2],        [ 3,  4,  5],        [ 6,  7,  8],        [ 9, 10, 11],        [12, 13, 14]],       [[15, 16, 17],        [18, 19, 20],        [21, 22, 23],        [24, 25, 26],        [27, 28, 29]]])</code></pre><h4 id="向量组合-stacking"><a href="#向量组合-stacking" class="headerlink" title="向量组合(stacking)"></a>向量组合(stacking)</h4><p>我们如何用两个相同尺寸的行向量列表构建一个二维数组？在MATLAB中这非常简单：如果<code>x</code>和<code>y</code>是两个相同长度的向量，你仅仅需要做<code>m=[x;y]</code>。在NumPy中这个过程通过函数<code>column_stack</code>、<code>dstack</code>、<code>hstack</code>和<code>vstack</code>来完成，取决于你想要在那个维度上组合。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)      <span class="comment"># x = ([0,2,4,6,8])</span></div><div class="line">y = np.arange(<span class="number">5</span>)           <span class="comment"># y = ([0,1,2,3,4])</span></div><div class="line">m = np.vstack([x,y])       <span class="comment"># m=([[0,2,4,6,8],</span></div><div class="line">                           <span class="comment">#     [0,1,2,3,4]])</span></div><div class="line">m</div></pre></td></tr></table></figure><pre><code>array([[0, 2, 4, 6, 8],       [0, 1, 2, 3, 4]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xy = np.hstack([x,y])      <span class="comment"># xy = ([0,2,4,6,8,0,1,2,3,4])</span></div><div class="line">xy</div></pre></td></tr></table></figure><pre><code>array([0, 2, 4, 6, 8, 0, 1, 2, 3, 4])</code></pre><h4 id="直方图-histogram"><a href="#直方图-histogram" class="headerlink" title="直方图(histogram)"></a>直方图(histogram)</h4><p>NumPy中<code>histogram</code>函数应用到一个数组返回一对变量：直方图数组和箱式向量。注意：<code>matplotlib</code>也有一个用来建立直方图的函数(叫作<code>hist</code>,正如matlab中一样)与NumPy中的不同。主要的差别是<code>pylab.hist</code>自动绘制直方图，而<code>numpy.histogram</code>仅仅产生数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="comment"># 简历一个拥有10000个元素的正态分布的向量，方差为0.5^2，均值为2</span></div><div class="line">mu, sigma = <span class="number">2</span>, <span class="number">0.5</span></div><div class="line">v = np.random.normal(mu,sigma,<span class="number">10000</span>)</div><div class="line"><span class="comment"># 绘制分成50份的正态分布直方图</span></div><div class="line">plt.hist(v, bins=<span class="number">50</span>, normed=<span class="number">1</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/img/18_05_11/output_232_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用numpy计算直方图然后绘制它</span></div><div class="line">(n, bins) = np.histogram(v, bins=<span class="number">50</span>, normed=<span class="keyword">True</span>)  <span class="comment"># NumPy version (no plot)</span></div><div class="line">plt.plot(<span class="number">.5</span>*(bins[<span class="number">1</span>:]+bins[:<span class="number">-1</span>]), n)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/img/18_05_11/output_233_0.png" alt="png"></p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part6-发布你的app</title>
      <link>http://studyai.site/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/</link>
      <guid>http://studyai.site/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/</guid>
      <pubDate>Thu, 03 May 2018 06:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compos</a>。</li><li>按照Part4部分，获取<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">Docker Machine</a>。</li><li>阅读Part1。</li><li>学习Part2中的如何创建容器。</li><li>确保您的镜像作为一个发布容器在运行。运行这条插入了<code>username</code>、<code>repo</code>和<code>tag</code>信息的命令:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li><li>获取到Part5中的最终版本的<code>compose.yml</code>文件。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>您一直在为整个教程编辑相同的Compose文件。那么，我们有一个好消息，这个Compose文件在生产环境中的效果与你的计算机上的效果是相同的。在这里，我们通过一些选项来运行Docker化的程序。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="Docker社区版（云服务提供者）"><a href="#Docker社区版（云服务提供者）" class="headerlink" title="Docker社区版（云服务提供者）"></a>Docker社区版（云服务提供者）</h3><p>如果您可以在生产环境中使用Docker社区版，那么你可以使用Docker Cloud来帮助您管理应用程序，例如Amazon Web Services，DigitalOcean，和Microsoft Azure等常用的服务提供商。</p><p>设置和部署：</p><ul><li>将Docker Cloud与您的首选提供商连接，授予Docker Cloud权限，以便为您自动配置以及为您”Docker化”VM。</li><li>使用Docker Cloud创建您的计算资源并创建您的swarm。</li><li>部署您的应用。</li></ul><blockquote><p>注意：我们没有链接到Docker Cloud文档。请务必在完成每个步骤后回到此页面。</p></blockquote><h4 id="连接Docker-Cloud"><a href="#连接Docker-Cloud" class="headerlink" title="连接Docker Cloud"></a>连接Docker Cloud</h4><p>你可以在<a href="https://docs.docker.com/docker-cloud/infrastructure/" target="_blank" rel="external">标准模式</a>或<a href="https://docs.docker.com/docker-cloud/cloud-swarm/" target="_blank" rel="external">swarm模式</a>下运行Docker Cloud。</p><p>如果你正在标准模式下运行Docker Cloud，请按照以下说明将您的服务提供商链接到Docker Cloud。</p><ul><li><a href="https://docs.docker.com/docker-cloud/cloud-swarm/link-aws-swarm/" target="_blank" rel="external">Amazon Web Services 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-do/" target="_blank" rel="external">DigitalOcean 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-azure/" target="_blank" rel="external">Microsoft Azure 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-packet/" target="_blank" rel="external">Packet 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-softlayer/" target="_blank" rel="external">SoftLayer 设置说明</a>。</li><li><a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/" target="_blank" rel="external">使用Docker Cloud 代理来访问自己的主机</a>。</li></ul><p>如果您在Swarm模式下运行（推荐用于Amazon Web Services或Microsoft Azure），那么请跳至下一节关于如何<a href="#创建你的swarm">创建swarm</a>的部分。</p><h3 id="创建你的swarm"><a href="#创建你的swarm" class="headerlink" title="创建你的swarm"></a>创建你的swarm</h3><p>准备好创建一个swarm了吗？</p><ul><li>如果你在使用Amazon Web Services(AWS)，那么你可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-aws/" target="_blank" rel="external">在AWS上自动地创建一个swarm</a>。</li><li>如果你在使用Microsoft Azure，那么你可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-azure/" target="_blank" rel="external">在Azure上自动地创建一个swarm</a>。</li><li>否则，在Docker Cloud UI界面<a href="https://docs.docker.com/docker-cloud/getting-started/your_first_node/" target="_blank" rel="external">创建你的节点</a>，然后运行<code>docker swarm init</code>并执行在Part4部分所学的<code>docker swarm join</code>命令。最后，通过点击屏幕顶部的开关<a href="https://docs.docker.com/docker-cloud/cloud-swarm/using-swarm-mode/" target="_blank" rel="external">启用swarm模式</a>，并<a href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/" target="_blank" rel="external">注册你刚刚创建的swarm</a>。</li></ul><blockquote><p>注意：如果您<a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/" target="_blank" rel="external">使用Docker云代理来自带主机</a>，则此提供程序不支持swarm模式。您可以使用Docker Cloud<a href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/" target="_blank" rel="external">注册您自己的现有的swarm</a>。</p></blockquote><h3 id="在云服务平台上部署你的应用程序"><a href="#在云服务平台上部署你的应用程序" class="headerlink" title="在云服务平台上部署你的应用程序"></a>在云服务平台上部署你的应用程序</h3><ul><li><p>1.<a href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/" target="_blank" rel="external">通过Docker Cloud连接到你自己的swarm</a>。有几种不同的连接方式：</p><ul><li><p>从Swarm模式的Docker Cloud Web界面中，选择页面顶部的Swarms，单击要连接的swarm，然后将给定的命令复制粘贴到命令行终端中。</p><p><img src="/img/18_05_02/004.png" alt=""></p><p>或者。。。</p></li><li><p>在Docker for Mac或Docker for Windows上，您可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/#use-docker-for-mac-or-windows-edge-to-connect-to-swarms" target="_blank" rel="external">通过桌面应用菜单直接连接到swarm</a>。</p><p><img src="/img/18_05_02/005.png" alt=""></p><p>无论哪种方式，都将打开一个终端，其上下文是本地计算机，但其Docker命令会路由到云服务提供商上运行的swarm。您可以直接访问本地文件系统和远程swarm，从而启用纯粹的<code>docker</code>命令。</p></li></ul></li><li><p>2.运行<code>docker stack deploy -c docker-compose.yml getstartedlab</code>在云托管swarm上部署应用程序。</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div><div class="line"></div><div class="line">Creating network getstartedlab_webnet</div><div class="line">Creating service getstartedlab_web</div><div class="line">Creating service getstartedlab_visualizer</div><div class="line">Creating service getstartedlab_redis</div></pre></td></tr></table></figure><p>  您的应用现在运行在了云服务平台上了。</p></li></ul><p><strong>运行一些swarm命令来验证部署：</strong></p><p>你可以使用swarm命令行，就像你之前做的那样，浏览并管理你的swarm。这里有一些你比较熟悉的例子：</p><ul><li>使用<code>docker node ls</code>列出节点。</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[getstartedlab] ~ $ docker node ls</div><div class="line">ID                            HOSTNAME                                      STATUS              AVAILABILITY        MANAGER STATUS</div><div class="line"><span class="number">9442</span>yi1zie2l34lj01frj3lsn     ip<span class="number">-172</span><span class="number">-31</span><span class="number">-5</span><span class="number">-208.</span>us-west<span class="number">-1.</span>compute.internal    Ready               Active              </div><div class="line">jr02vg153pfx6jr0j66624e8a     ip<span class="number">-172</span><span class="number">-31</span><span class="number">-6</span><span class="number">-237.</span>us-west<span class="number">-1.</span>compute.internal    Ready               Active              </div><div class="line">thpgwmoz3qefdvfzp7d9wzfvi     ip<span class="number">-172</span><span class="number">-31</span><span class="number">-18</span><span class="number">-121.</span>us-west<span class="number">-1.</span>compute.internal   Ready               Active              </div><div class="line">n2bsny0r2b8fey6013kwnom3m *   ip<span class="number">-172</span><span class="number">-31</span><span class="number">-20</span><span class="number">-217.</span>us-west<span class="number">-1.</span>compute.internal   Ready               Active              Leader</div></pre></td></tr></table></figure><ul><li>使用<code>docker service ls</code>列出服务。</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[getstartedlab] ~/sandbox/getstart $ docker service ls</div><div class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</div><div class="line"><span class="function"><span class="title">x3jyx6uukog9</span>        dockercloud-server-proxy   global              1/1                 dockercloud/server-proxy          *:2376-&gt;</span><span class="number">2376</span>/tcp</div><div class="line"><span class="function"><span class="title">ioipby1vcxzm</span>        getstartedlab_redis        replicated          0/1                 redis:latest                      *:6379-&gt;</span><span class="number">6379</span>/tcp</div><div class="line"><span class="function"><span class="title">u5cxv7ppv5o0</span>        getstartedlab_visualizer   replicated          0/1                 dockersamples/visualizer:stable   *:8080-&gt;</span><span class="number">8080</span>/tcp</div><div class="line"><span class="function"><span class="title">vy7n2piyqrtr</span>        getstartedlab_web          replicated          5/5                 sam/getstarted:part6    *:80-&gt;</span><span class="number">80</span>/tcp</div></pre></td></tr></table></figure><ul><li>使用<code>docker service ps &lt;service&gt;</code>查看service的任务列表。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[getstartedlab] ~/sandbox/getstart $ docker service ps vy7n2piyqrtr</div><div class="line">ID                  NAME                  IMAGE                            NODE                                          DESIRED STATE       CURRENT STATE            ERROR               PORTS</div><div class="line">qrcd4a9lvjel        getstartedlab_web.<span class="number">1</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">5</span>-<span class="number">208</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>    Running             Running <span class="number">20</span> seconds ago                       </div><div class="line">sknya8t4m51u        getstartedlab_web.<span class="number">2</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">6</span>-<span class="number">237</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>    Running             Running <span class="number">17</span> seconds ago                       </div><div class="line">ia730lfnrslg        getstartedlab_web.<span class="number">3</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">20</span>-<span class="number">217</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>   Running             Running <span class="number">21</span> seconds ago                       </div><div class="line"><span class="number">1</span>edaa97h9u4k        getstartedlab_web.<span class="number">4</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">18</span>-<span class="number">121</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>   Running             Running <span class="number">21</span> seconds ago                       </div><div class="line">uh64ez6ahuew        getstartedlab_web.<span class="number">5</span>   sam/getstarted:part6   ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">18</span>-<span class="number">121</span><span class="selector-class">.us-west-1</span><span class="selector-class">.compute</span><span class="selector-class">.internal</span>   Running             Running <span class="number">22</span> seconds ago</div></pre></td></tr></table></figure><p><strong>在云供应商机器上开放服务端口</strong></p><p>此时，您的应用作为一个swarm部署在您的云提供商服务器上，正如刚刚运行的<code>docker</code>命令所证明的那样。但是，您仍然需要在云服务器上打开端口，以便：</p><ul><li>允许在工作节点上的<code>redis</code>服务和<code>web</code>服务之间进行通信</li><li>允许入站流量通过worker节点上的<code>web</code>服务，以便可以在浏览器访问Hello World和Visualizer。</li><li>允许运行<code>manager</code>的服务器上的入站SSH流量（这可能已在您的云提供商上设置）</li></ul><p>这些是您需要为每项服务公开的端口：</p><table><thead><tr><th style="text-align:left">Service</th><th style="text-align:left">类型</th><th style="text-align:left">协议</th><th style="text-align:left">端口</th></tr></thead><tbody><tr><td style="text-align:left"><code>web</code></td><td style="text-align:left">HTTP</td><td style="text-align:left">TCP</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left"><code>visualizer</code></td><td style="text-align:left">HTTP</td><td style="text-align:left">TCP</td><td style="text-align:left">8080</td></tr><tr><td style="text-align:left"><code>redis</code></td><td style="text-align:left">TCP</td><td style="text-align:left">TCP</td><td style="text-align:left">6379</td></tr></tbody></table><p>具体的做法取决于云服务平台。</p><p>我们以Amazon Web Services（AWS）为例。</p><blockquote><p><strong>redis如何持久化数据？</strong></p><p>为了使<code>redis</code>服务正常工作，在运行<code>docker stack deploy</code>之前，需要<code>ssh</code>进入manager运行的云服务器，并在<code>/home/docker/</code>中创建<code>data/</code>目录。另一种选择是将<code>docker-stack.yml</code>中的数据路径更改为manager服务器上已存在的一个路径。此示例不包含此步骤，因此示例输出中的<code>redis</code>服务未启动。</p></blockquote><p><strong>示例：AWS</strong></p><ul><li>1.登录<a href="https://aws.amazon.com/" target="_blank" rel="external">AWS控制台</a>，转到EC2仪表板，然后单击进入<strong>Running Instances</strong>查看节点。</li><li><p>2.在左侧的按钮，进入Network &amp; Security &gt; <strong>Security Groups</strong>。</p><p>  请参阅<code>getstartedlab-Manager-&lt;xxx&gt;</code>, <code>getstartedlab-Nodes-&lt;xxx&gt;</code>, 和 <code>getstartedlab-SwarmWide-&lt;xxx&gt;</code>的与swarm相关的安全组。</p></li><li><p>3.为swarm选择“节点”安全组。组名是这样的：<code>getstartedlab-NodeVpcSG-9HV9SMHDZT8C</code>。</p></li><li>4.为<code>web</code>，<code>visualizer</code>和<code>redis</code>服务添加入站规则，为每个服务设置类型，协议和端口（如上表所示），然后单击保存以应用规则。</li></ul><p><img src="/img/18_05_02/006.png" alt=""></p><blockquote><p>提示：当你保存新的规则时，会为IPv4和IPv6地址自动创建HTTP和TCP端口。</p></blockquote><p><img src="/img/18_05_02/007.png" alt=""></p><ul><li>5.进入<strong>Running Instances</strong>列表，获取其中一个worker的公共DNS名称，并将其粘贴到浏览器地址栏中。</li></ul><p><img src="/img/18_05_02/008.png" alt=""></p><p>就像本教程的前几部分一样，Hello World应用程序显示在端口<code>80</code>上，而Visualizer显示在端口<code>8080</code>上。</p><p><img src="/img/18_05_02/009.png" alt=""></p><p><img src="/img/18_05_02/010.png" alt=""></p><h3 id="迭代和清理"><a href="#迭代和清理" class="headerlink" title="迭代和清理"></a>迭代和清理</h3><p>从这里你可以完成你在教程前面部分学到的所有知识。</p><ul><li>通过修改<code>docker-compose.yml</code>文件并使用命令<code>docker stack deploy</code>重新发布来扩展你的应用程序。</li><li>通过编辑代码更改应用程序行为，然后重新构建并推送新镜像。（要做到这一点，请按照之前用于<a href="https://docs.docker.com/get-started/part2/#build-the-app" target="_blank" rel="external">构建应用程序</a>和<a href="https://docs.docker.com/get-started/part2/#publish-the-image" target="_blank" rel="external">发布镜像</a>的相同步骤）。</li><li>您可以使用<code>docker stack rm</code>命令来拆卸堆栈。例如：</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> getstartedlab</div></pre></td></tr></table></figure><p>与在本地Docker机器虚拟机上运行swarm的场景不同，不管您是否关闭本地主机，您的swarm和部署在其上的任何应用程序都将继续在云服务器上运行。</p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part5-堆栈</title>
      <link>http://studyai.site/2018/05/02/Docker%E5%85%A5%E9%97%A8Part5-%E5%A0%86%E6%A0%88/</link>
      <guid>http://studyai.site/2018/05/02/Docker%E5%85%A5%E9%97%A8Part5-%E5%A0%86%E6%A0%88/</guid>
      <pubDate>Wed, 02 May 2018 09:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compos</a>。</li><li>按照Part4部分，获取<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">Docker Machine</a>。</li><li>阅读Part1。</li><li>学习Part2中的如何创建容器。</li><li>确保您已发布了那个<a href="https://docs.docker.com/get-started/part2/#share-your-image" target="_blank" rel="external">推送到仓库的</a><code>friendlyhello</code>镜像。我们在这里使用该共享镜像。</li><li>确保你在part4中设置的机器处于运行状态。运行<code>docker-machine ls</code>来验证这一点。如果机器处于停止状态，运行<code>docker-machine start myvm1</code>来启动manager，然后执行<code>docker-machine start myvm2</code>来启动worker。</li><li>让你在Part4创建的swarm处于运行状态并准备就绪。运行<code>docker-machine ssh myvm1 &quot;docker node ls&quot;</code>来验证这一点。如果swarm起来了，那么两个node的状态都是<code>ready</code>。如果不是这样，重新初始化swarm，并按照part4中的方式将worker加入到swarm中。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在part4中，你学到了如何设置一个swarm，这是一群运行Docker的机器，并为其部署了一个应用程序，其中容器在多台机器上运行。</p><p>在这里的Part5中，您将学习到分布式应用程序层次结构的顶部部分：<strong>堆栈(stack)</strong>。堆栈是一组相互关联的服务，它们可以共享依赖关系，并且可以进行协调和缩放。单个堆栈能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个堆栈）。</p><p>一些好消息是，从Part3部分开始，在创建Compose文件并使用<code>docker stack deploy</code>时，从技术上讲，您其实一直都在使用堆栈。但这是在单个主机上运行的单个服务堆栈，通常不会发生在生产环境中。在这里，你可以把你学到的东西，使多个服务相互关联，并在多台机器上运行它们。</p><p>你做得很好，这就是你的主场！</p><h2 id="添加一项新服务并重新部署"><a href="#添加一项新服务并重新部署" class="headerlink" title="添加一项新服务并重新部署"></a>添加一项新服务并重新部署</h2><p>将服务添加到我们的<code>docker-compose.yml</code>文件很容易。首先，我们添加一个免费的可视化工具，让我们看看我们的swarm是如何安排容器的。</p><ul><li>1.打开<code>docker-compose.yml</code>文件，并用以下内容替换它。确保你的<code>username/repo:tag</code>是正确的：</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">version:</span> <span class="string">"3"</span></div><div class="line"><span class="symbol">services:</span></div><div class="line"><span class="symbol">  web:</span></div><div class="line">    <span class="meta"># replace username/repo:tag with your name and image details</span></div><div class="line"><span class="symbol">    image:</span> username/repo:tag</div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      replicas:</span> <span class="number">5</span></div><div class="line"><span class="symbol">      restart_policy:</span></div><div class="line"><span class="symbol">        condition:</span> on-failure</div><div class="line"><span class="symbol">      resources:</span></div><div class="line"><span class="symbol">        limits:</span></div><div class="line"><span class="symbol">          cpus:</span> <span class="string">"0.1"</span></div><div class="line"><span class="symbol">          memory:</span> <span class="number">50</span>M</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"80:80"</span></div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">  visualizer:</span></div><div class="line"><span class="symbol">    image:</span> dockersamples/visualizer:stable</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"8080:8080"</span></div><div class="line"><span class="symbol">    volumes:</span></div><div class="line">      - <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      placement:</span></div><div class="line"><span class="symbol">        constraints:</span> [node.role == manager]</div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">networks:</span></div><div class="line"><span class="symbol">  webnet:</span></div></pre></td></tr></table></figure><p>这里唯一新增的东西就是<code>visualizer</code>。注意到这里有两个新的东西：一个<code>volumes</code>键，让visualizer可以访问Docker主机的socket文件，这项服务职能在swarm manager上运行。这是因为这个容器是由Docker创建的<a href="https://github.com/ManoMarks/docker-swarm-visualizer" target="_blank" rel="external">一个开源项目</a>构建的，它显示了一个图表中的swarm运行的Docker服务。</p><p>我们稍后会详细讨论放置约束和体积。</p><ul><li><p>2.确保你的shell被配置为与myvm1进行通信（完整的例子在<a href="https://docs.docker.com/get-started/part4/#configure-a-docker-machine-shell-to-the-swarm-manager" target="_blank" rel="external">这里</a>）。</p><ul><li>运行<code>docker-machine ls</code>来列出机器，并确保您已连接到<code>myvm1</code>，如旁边的星号所示。</li><li><p>如果需要，重新运行<code>docker-machine env myvm1</code>，然后运行给定的命令来配置shell。</p><p>在Mac或者Linux上，命令如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> myvm1)</div></pre></td></tr></table></figure></li></ul></li></ul><pre><code>在Windows命令如下：<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env myvm1 | Invoke-Expression</div></pre></td></tr></table></figure></code></pre><ul><li>3.在manager上重新运行<code>docker stack deploy</code>命令，并且需要更新的任何服务都会更新：</li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</div><div class="line">Updating service getstartedlab_web (<span class="attribute">id:</span><span class="string"> angi1bf5e4to03qu9f93trnxm</span>)</div><div class="line">Creating service getstartedlab_visualizer (<span class="attribute">id:</span><span class="string"> l9mnwkeq2jiononb5ihz9u7a4</span>)</div></pre></td></tr></table></figure><ul><li><p>4.看一下visualizer。</p><p>  你可以看到compose文件中的<code>visualizer</code>运行在了8080端口。通过运行<code>docker-machine ls</code>可以获取每个节点的IP地址信息。分别访问任意一个IP地址的8080端口，你可以看到visualizer的运行效果：</p><p>  <img src="/img/18_05_02/001.png" alt=""></p><p>  <code>visualizer</code>的单个副本按照您的预期在manager上运行，并且<code>web</code>的5个实例遍布整个swarm。你可以通过运行<code>docker stack ps &lt;stack&gt;</code>来确认可视化的结果：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">stack</span> ps getstartedlab</div></pre></td></tr></table></figure></li></ul><pre><code>可视化器是一个独立的服务，可以在包含它的任何应用程序中运行。它不依赖于其他任何东西。现在让我们创建一个具有依赖关系的服务：提供访问者计数器的Redis服务。</code></pre><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>让我们再次通过相同的工作流程来添加用于存储应用程序数据的Redis数据库。</p><ul><li>1.保存这个在最后位置添加Redis服务的新的<code>docker-compose.yml</code>文件。确保替换镜像详情部分的<code>username/repo:tag</code>。</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">version:</span> <span class="string">"3"</span></div><div class="line"><span class="symbol">services:</span></div><div class="line"><span class="symbol">  web:</span></div><div class="line">    <span class="meta"># replace username/repo:tag with your name and image details</span></div><div class="line"><span class="symbol">    image:</span> username/repo:tag</div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      replicas:</span> <span class="number">5</span></div><div class="line"><span class="symbol">      restart_policy:</span></div><div class="line"><span class="symbol">        condition:</span> on-failure</div><div class="line"><span class="symbol">      resources:</span></div><div class="line"><span class="symbol">        limits:</span></div><div class="line"><span class="symbol">          cpus:</span> <span class="string">"0.1"</span></div><div class="line"><span class="symbol">          memory:</span> <span class="number">50</span>M</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"80:80"</span></div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">  visualizer:</span></div><div class="line"><span class="symbol">    image:</span> dockersamples/visualizer:stable</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"8080:8080"</span></div><div class="line"><span class="symbol">    volumes:</span></div><div class="line">      - <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      placement:</span></div><div class="line"><span class="symbol">        constraints:</span> [node.role == manager]</div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">  redis:</span></div><div class="line"><span class="symbol">    image:</span> redis</div><div class="line"><span class="symbol">    ports:</span></div><div class="line">      - <span class="string">"6379:6379"</span></div><div class="line"><span class="symbol">    volumes:</span></div><div class="line">      - <span class="string">"/home/docker/data:/data"</span></div><div class="line"><span class="symbol">    deploy:</span></div><div class="line"><span class="symbol">      placement:</span></div><div class="line"><span class="symbol">        constraints:</span> [node.role == manager]</div><div class="line"><span class="symbol">    command:</span> redis-server --appendonly yes</div><div class="line"><span class="symbol">    networks:</span></div><div class="line">      - webnet</div><div class="line"><span class="symbol">networks:</span></div><div class="line"><span class="symbol">  webnet:</span></div></pre></td></tr></table></figure><p>Redis在Docker库中有一个官方镜像，并已被授予<code>redis</code>作为镜像的简称，所以在这里没有<code>username/repo</code>符号。Redis端口6379已经由Redis预配置为从容器暴露给主机，在我们的Compose文件中，我们将它从主机展示给全世界，因此，如果您愿意，您可以将任何节点的IP输入到Redis桌面管理器中，并管理此Redis实例。</p><p>最重要的是，<code>redis</code>规范中有几件事情使数据在这个堆栈的部署之间持续存在：</p><ul><li><code>redis</code>总是在manager上运行，所以它总是使用相同的文件系统。</li><li><code>redis</code>在主机文件系统中访问任意目录作为容器内的<code>/data</code>，这是Redis存储数据的地方。</li></ul><p>这就是在您的主机物理文件系统中为Redis数据创建“真相源”。如果没有这个，Redis会将其数据存储在容器文件系统中的<code>/data</code>中，如果该容器曾经被重新部署，该数据将被清除。</p><p>这个真相的来源有两个组成部分：</p><ul><li>放置在Redis服务上的放置约束，确保它始终使用相同的主机。</li><li>您创建的容器，允许容器作为<code>./data</code>（位于Redis容器内）访问<code>./data</code>（在主机上）。在容器来来去去时，存储在指定主机上的<code>./data</code>文件仍然存在，从而保持连续性。</li></ul><p>您已准备好部署新的供Redis使用的堆栈了。</p><ul><li>2.在manager上创建一个<code>./data</code>目录。</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ssh myvm1 <span class="string">"mkdir ./data"</span></div></pre></td></tr></table></figure><ul><li><p>3.确保你的shell被配置为与<code>myvm1</code>进行通信(完整的例子在<a href="https://docs.docker.com/get-started/part4/#configure-a-docker-machine-shell-to-the-swarm-manager" target="_blank" rel="external">这里</a>)。</p><ul><li>运行<code>docker-machine ls</code>列出机器，并确保你已经连接到了<code>myvm1</code>，由旁边的星号所指示。</li><li><p>如果需要的话，重新运行<code>docker-machine env myvm1</code>，然后运行下面给出的命令来配置shell。</p><p>在Mac或Linux上，命令如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> myvm1)</div></pre></td></tr></table></figure></li></ul></li></ul><pre><code>在Windows上命令如下：<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env myvm1 | Invoke-Expression</div></pre></td></tr></table></figure></code></pre><ul><li>4.再次运行<code>docker stack deploy</code>。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div></pre></td></tr></table></figure><ul><li>5.运行<code>docker service ls</code>来验证三个服务处于运行状态：</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker service ls</div><div class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</div><div class="line"><span class="function"><span class="title">x7uij6xb4foj</span>        getstartedlab_redis        replicated          1/1                 redis:latest                      *:6379-&gt;</span><span class="number">6379</span>/tcp</div><div class="line"><span class="function"><span class="title">n5rvhm52ykq7</span>        getstartedlab_visualizer   replicated          1/1                 dockersamples/visualizer:stable   *:8080-&gt;</span><span class="number">8080</span>/tcp</div><div class="line"><span class="function"><span class="title">mifd433bti1d</span>        getstartedlab_web          replicated          5/5                 orangesnap/getstarted:latest    *:80-&gt;</span><span class="number">80</span>/tcp</div></pre></td></tr></table></figure><ul><li>6.检查位于你的某个节点的网页，例如<code>http://192.168.99.101</code>，然后看访问者计数器的结果，该计数器现在已经存在并将信息存储在Redis上。</li></ul><p><img src="/img/18_05_02/002.png" alt=""></p><p>另外，请检查任一节点IP地址的端口8080处的可视化工具，并注意查看随<code>web</code>和<code>visualizer</code>工具一起运行的<code>redis</code>服务。</p><p><img src="/img/18_05_02/003.png" alt=""></p>]]></content:encoded>
      
      <comments>http://studyai.site/2018/05/02/Docker%E5%85%A5%E9%97%A8Part5-%E5%A0%86%E6%A0%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门Part4-Swarms</title>
      <link>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/</link>
      <guid>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/</guid>
      <pubDate>Thu, 26 Apr 2018 05:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>安装<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">Docker 1.13或更高的版本</a>。</li><li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">Docker Compos</a>。</li><li>获取预装<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Docker for Mac</a>和<a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="external">Docker for Windows</a>的<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">Docker Machine</a>，但在Linux系统上需要<a href="https://docs.docker.com/machine/install-machine/#installing-machine-directly" target="_blank" rel="external">直接安装它</a>。在没有<em>Hyper-V</em>的Windows 10系统之前以及Windows 10 Home中，使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">Docker Toolbox</a>。</li><li>阅读Part1。</li><li>学习Part2中的如何创建容器。</li><li>确保您已发布了那个<a href="https://docs.docker.com/get-started/part2/#share-your-image" target="_blank" rel="external">推送到仓库的</a><code>friendlyhello</code>镜像。我们在这里使用该共享镜像。</li><li>确定你的镜像作为一个已部署的容器。运行下面这条命令，插入你的<code>username</code>、<code>repo</code>、和<code>tag</code>:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li><li>有一份Part3中的<code>docker-compose.yml</code>。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Part3中，你介绍了在Part2中编写的应用程序，并通过将其转化为service来定义应该如何在生产环境中运行，并在其进程内扩大5倍。</p><p>在Part4部分，您将此应用程序部署到集群上，并在多台机器上运行它。通过将多台机器连接到称为<strong>swarm</strong>的“Dockerized”群集，使多容器，多机器应用成为可能。</p><h2 id="了解Swarm集群"><a href="#了解Swarm集群" class="headerlink" title="了解Swarm集群"></a>了解Swarm集群</h2><p>Swarm是一组运行Docker并加入到集群中的机器。发生这种情况后，您将继续运行您习惯的Docker命令，但现在它们将由<strong>swarm manager</strong>在群集上执行。swarm中的机器可以是物理的或虚拟的。加入swarm后，他们被称为节点。</p><p>swarm管理器可以使用几种策略来运行容器，例如“emptiest node”–它用容器填充最少使用的机器。或者“global”，它可以确保每台机器只获取指定容器的一个实例。您指示swarm manager在Compose文件中使用这些策略，就像您已经使用的策略一样。</p><p>swarm manager是群体中唯一可以执行你的命令，或者授权其他机器作为<strong>worker</strong>加入群体的机器。worker只是提供能力，并没有权力告诉任何其他机器它能做什么和不能做什么。</p><p>到目前为止，您已经在本地机器上以单主机模式使用Docker。但是Docker也可以切换到<strong>swarm模式</strong>，这就是使用群集的原因。立即启用swarm模式使当前的机器成为swarm manager。从此，Docker将运行您在您管理的swarm上执行的命令，而不仅仅是在当前机器上执行。</p><h2 id="设置你的swarm"><a href="#设置你的swarm" class="headerlink" title="设置你的swarm"></a>设置你的swarm</h2><p>一个swarm是由多个节点组成，这些节点可以是物理机或虚拟机。基本概念很简单：运行<code>docker swarm init</code>来启用swarm模式，并使您当前的机器成为swarm管理器，然后在其他机器上运行<code>docker swarm join</code>，使其他机器以worker的身份加入到swarm中。我们将使用虚拟机快速创建一个双机群集，并将其变成swarm。</p><h3 id="创建一个集群"><a href="#创建一个集群" class="headerlink" title="创建一个集群"></a>创建一个集群</h3><h4 id="本地虚拟机（Mac，Linux，Windows-7和8）"><a href="#本地虚拟机（Mac，Linux，Windows-7和8）" class="headerlink" title="本地虚拟机（Mac，Linux，Windows 7和8）"></a>本地虚拟机（Mac，Linux，Windows 7和8）</h4><p>您需要一个可以创建虚拟机（VM）的虚拟机管理程序，因此请为您的计算机的操作系统<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">安装Oracle VirtualBox</a>。</p><blockquote><p>注意：如果你在Windows系统下，并且已经安装了Hyper-V，例如Windows 10，那就没必要安装VirtualBox了，你可以使用Hyper-V替代。如果你正在使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">Docker Toolbox</a>，你应该已经安装好了VirtualBox。</p></blockquote><p>现在，使用<code>docker-machine</code>创建两个虚拟机VM，使用VirtualBox驱动：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker-machine <span class="built_in">create</span> <span class="comment">--driver virtualbox myvm1</span></div><div class="line">docker-machine <span class="built_in">create</span> <span class="comment">--driver virtualbox myvm2</span></div></pre></td></tr></table></figure><h4 id="本地虚拟机（Windows-10-Hyper-V）"><a href="#本地虚拟机（Windows-10-Hyper-V）" class="headerlink" title="本地虚拟机（Windows 10/Hyper-V）"></a>本地虚拟机（Windows 10/Hyper-V）</h4><p>首先，快速为您的虚拟机（VM）创建一个虚拟交换机以便共享，以便它们可以相互连接。</p><ul><li>1.开启 Hyper-V Manager</li><li>2.点击右上角菜单中的<strong>Virtual Switch Manager</strong></li><li>3.单击创建类型为<strong>External</strong>的<strong>虚拟交换机</strong></li><li>4.将它命名为<code>myswitch</code>，然后选中复选框以共享主机的活动网络适配器</li></ul><p>现在，使用我们的节点管理工具<code>docker-machine</code>创建几个虚拟机：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker-machine create -d hyperv --hyperv-<span class="keyword">virtual</span>-<span class="keyword">switch</span> <span class="string">"myswitch"</span> myvm1</div><div class="line">docker-machine create -d hyperv --hyperv-<span class="keyword">virtual</span>-<span class="keyword">switch</span> <span class="string">"myswitch"</span> myvm2</div></pre></td></tr></table></figure><hr><h3 id="列出虚拟机，并显示其IP地址"><a href="#列出虚拟机，并显示其IP地址" class="headerlink" title="列出虚拟机，并显示其IP地址"></a>列出虚拟机，并显示其IP地址</h3><p>你现在创建了两个虚拟机，名叫<code>myvm1</code>和<code>myvm2</code>。</p><p>使用下面的命令来列出这些虚拟机以及他们的IP地址。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine <span class="keyword">ls</span></div></pre></td></tr></table></figure><p>这里是这个命令的输出示例。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</div><div class="line">myvm1   -        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.100</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce   </div><div class="line">myvm2   -        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.101</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div></pre></td></tr></table></figure><h3 id="初始化swarm和节点"><a href="#初始化swarm和节点" class="headerlink" title="初始化swarm和节点"></a>初始化swarm和节点</h3><p>第一台机器作为manager，它负责执行管理命令并认证worker机器加入集群，第二台机器是worker。</p><p>你可以对你的虚拟机通过<code>docker-machine ssh</code>来发送命令。通过执行<code>docker swarm init</code>来指导<code>myvm1</code>来成为swarm manager，然后你会看到像下面这样的输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh myvm1 <span class="string">"docker swarm init --advertise-addr &lt;myvm1 ip&gt;"</span></div><div class="line">Swarm initialized: current node &lt;node ID&gt; is now <span class="keyword">a</span> manager.</div><div class="line"></div><div class="line">To <span class="built_in">add</span> <span class="keyword">a</span> worker <span class="built_in">to</span> this swarm, run <span class="keyword">the</span> following <span class="keyword">command</span>:</div><div class="line"></div><div class="line">  docker swarm join \</div><div class="line">  <span class="comment">--token &lt;token&gt; \</span></div><div class="line">  &lt;myvm ip&gt;:&lt;port&gt;</div><div class="line"></div><div class="line">To <span class="built_in">add</span> <span class="keyword">a</span> manager <span class="built_in">to</span> this swarm, run <span class="string">'docker swarm join-token manager'</span> <span class="keyword">and</span> follow <span class="keyword">the</span> instructions.</div></pre></td></tr></table></figure><blockquote><p><strong>端口2377和2376</strong></p><p>始终使用端口2377（群管理端口）运行<code>docker swarm init</code>和<code>docker swarm join</code>，或根本不指定运行端口，并让其采用默认值。</p><p>由<code>docker-machine ls</code>返回的计算机IP地址包括端口2376，它是Docker守护进程端口。请勿使用此端口，否则<a href="https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2" target="_blank" rel="external">可能会遇到错误</a>。</p><p><strong>无法使用SSH？试试–native-ssh标志</strong></p><p>如果由于某些原因，您无法将命令发送给Swarm管理器，Docker Machine可以<a href="https://docs.docker.com/machine/reference/ssh/#different-types-of-ssh" target="_blank" rel="external">选择让您使用自己的系统的SSH</a>。只需在调用<code>ssh</code>命令时指定<code>--native-ssh</code>标志：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; docker-machine --<span class="keyword">native</span>-ssh ssh myvm1 ...</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>如您所见，对<code>docker swarm init</code>的响应包含一个预配置的<code>docker swarm join</code>命令，您可以在要添加的任何节点上运行该命令。复制这条命令，并通过<code>docker-machine ssh</code>发送到<code>myvm2</code>，使<code>myvm2</code>作为woker的角色来加入到你新创建的集群中。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh myvm2 <span class="string">"docker swarm join \</span></div><div class="line">--token &lt;token&gt; \</div><div class="line">&lt;ip&gt;:2377"</div><div class="line"></div><div class="line">This <span class="keyword">node</span> <span class="title">joined</span> a swarm as a worker.</div></pre></td></tr></table></figure><p>恭喜，您已经创建了您的第一个swarm集群！</p><p>在manager机器上运行<code>docker node ls</code>来查看swarm中的node：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh myvm1 <span class="string">"docker node ls"</span></div><div class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS</div><div class="line">brtu9urxwfd5j0zrmkubhpkbd     myvm2               Ready               <span class="keyword">Active</span></div><div class="line">rihwohkh3ph38fhillhhb84sk *   myvm1               Ready               <span class="keyword">Active</span>              Leader</div></pre></td></tr></table></figure><blockquote><p><strong>离开一个swarm</strong></p><p>如果你的某个节点想要退出集群，你可以在节点上运行<code>docker swarm leave</code>。</p></blockquote><h2 id="发布你的应用到swarm集群"><a href="#发布你的应用到swarm集群" class="headerlink" title="发布你的应用到swarm集群"></a>发布你的应用到swarm集群</h2><p>最困难的部分已经结束了。现在你只需重复第3部分用于部署新swarm的流程即可。请记住，只有像<code>myvm1</code>这样的群集管理器才能执行Docker命令；worker机器只是提供使用而已。</p><h3 id="为swarm-manager配置docker-machine-shell"><a href="#为swarm-manager配置docker-machine-shell" class="headerlink" title="为swarm manager配置docker-machine shell"></a>为swarm manager配置<code>docker-machine</code> shell</h3><p>到目前为止，你已经可以在<code>docker-machine ssh</code>中包裹Docker命令来在虚拟机上执行指令了。另一种选择是运行<code>docker-machine env &lt;machine&gt;</code>来获取并执行一个命令，该命令将当前shell配置为与虚拟机上的Docker守护进程进行通信。此方法对下一步更有利，因为它允许您使用本地<code>docker-compose.yml</code>文件“远程”部署应用程序，而无需将其复制到任何位置。</p><p>键入<code>docker-machine env myvm1</code>，然后复制粘贴并运行作为输出最后一行提供的命令，这样可以将shell配置为swarm manager可以与<code>myvm1</code>进行对话。</p><p>配置shell的命令根据你是Mac，Linux还是Windows而有所不同。</p><h4 id="Mac，Linux"><a href="#Mac，Linux" class="headerlink" title="Mac，Linux"></a>Mac，Linux</h4><p>Mac或Linux上的Docker Machine shell</p><p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker-machine env myvm1</div><div class="line"><span class="built_in">export</span> DOCKER_TLS_VERIFY=<span class="string">"1"</span></div><div class="line"><span class="built_in">export</span> DOCKER_HOST=<span class="string">"tcp://192.168.99.100:2376"</span></div><div class="line"><span class="built_in">export</span> DOCKER_CERT_PATH=<span class="string">"/Users/sam/.docker/machine/machines/myvm1"</span></div><div class="line"><span class="built_in">export</span> DOCKER_MACHINE_NAME=<span class="string">"myvm1"</span></div><div class="line"><span class="comment"># Run this command to configure your shell:</span></div><div class="line"><span class="comment"># eval $(docker-machine env myvm1)</span></div></pre></td></tr></table></figure><p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> myvm1)</div></pre></td></tr></table></figure><p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</div><div class="line">myvm1   *        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.100</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce   </div><div class="line">myvm2   -        virtualbox   Running   tcp://<span class="number">192.168</span><span class="meta">.99</span><span class="meta">.101</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">PS </span>C:\<span class="string">Users\</span><span class="string">sam\</span><span class="string">sandbox\</span><span class="built_in">get-started&gt;</span> <span class="string">docker-machine </span><span class="string">env </span><span class="string">myvm1</span></div><div class="line">$<span class="string">Env:DOCKER_TLS_VERIFY </span>= <span class="string">"1"</span></div><div class="line">$<span class="string">Env:DOCKER_HOST </span>= <span class="string">"tcp://192.168.203.207:2376"</span></div><div class="line">$<span class="string">Env:DOCKER_CERT_PATH </span>= <span class="string">"C:\Users\sam\.docker\machine\machines\myvm1"</span></div><div class="line">$<span class="string">Env:DOCKER_MACHINE_NAME </span>= <span class="string">"myvm1"</span></div><div class="line">$<span class="string">Env:COMPOSE_CONVERT_WINDOWS_PATHS </span>= <span class="string">"true"</span></div><div class="line"><span class="comment"># Run this command to configure your shell:</span></div><div class="line"><span class="comment"># &amp; "C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe" env myvm1 | Invoke-Expression</span></div></pre></td></tr></table></figure><p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env myvm1 | Invoke-Expression</div></pre></td></tr></table></figure><p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PS C:PATH&gt; docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER   STATE     URL                          SWARM   DOCKER        ERRORS</div><div class="line">myvm1   *        hyperv   Running   tcp://<span class="number">192.168</span><span class="meta">.203</span><span class="meta">.207</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div><div class="line">myvm2   -        hyperv   Running   tcp://<span class="number">192.168</span><span class="meta">.200</span><span class="meta">.181</span>:<span class="number">2376</span>           v17<span class="meta">.06</span><span class="meta">.2</span>-ce</div></pre></td></tr></table></figure><h3 id="在swarm-manager上发布应用"><a href="#在swarm-manager上发布应用" class="headerlink" title="在swarm manager上发布应用"></a>在swarm manager上发布应用</h3><p>现在你已经拥有了<code>myvm1</code>，你可以使用它的权力作为swarm manager来部署你的应用，方法是使用第三部分中的<code>docker stack deploy</code>命令将你的本地副本<code>docker-compose.yml</code>发布到<code>myvm1</code>。这个命令也许会花费几秒钟时间来完成这一操作，部署需要花一段时间才能完成。在swarm manager上使用<code>docker service ps &lt;service_name&gt;</code>命令验证所有服务是否已被重新部署。</p><p>您通过<code>docker-machine shell</code>配置链接到<code>myvm1</code>，并且您仍然可以访问本地主机上的文件。确保你和之前在同一个目录下，并且其中包括你在第3部分中创建的<code>docker-compose.yml</code>文件。</p><p>就像之前一样，运行以下命令在<code>myvm1</code>上部署应用程序。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div></pre></td></tr></table></figure><p>就是这样，该应用程序就成功部署在了swarm集群上了！</p><blockquote><p>注意：如果你的镜像保存在了一个私有仓库而不是Docker Hub上，你需要登录到通过命令<code>docker login &lt;your-registry&gt;</code>来登录到这个仓库，并且然后你需要在上面的命令添加<code>--with-registry-auth</code>指令。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker login registry<span class="selector-class">.example</span><span class="selector-class">.com</span></div><div class="line"></div><div class="line">docker stack deploy --with-registry-auth -c docker-compose<span class="selector-class">.yml</span> getstartedlab</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>这使用加密的WAL日志将登录令牌从本地客户端传递到部署服务的群集节点。有了这些信息，这些节点就能够登录到仓库并提取镜像。</p></blockquote><p>现在你可以使用Part3中的docker命令。只有这次注意到services（和相关容器）已经在<code>myvm1</code>和<code>myvm2</code>之间分配了。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ <span class="string">docker </span><span class="string">stack </span><span class="string">ps </span><span class="string">getstartedlab</span></div><div class="line"></div><div class="line"><span class="string">ID </span>           <span class="string">NAME </span>                 <span class="string">IMAGE </span>                  <span class="string">NODE </span>  <span class="string">DESIRED </span><span class="string">STATE</span></div><div class="line"><span class="string">jq2g3qp8nzwx </span> <span class="string">getstartedlab_web.</span>1   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm1 </span> <span class="string">Running</span></div><div class="line"><span class="string">88wgshobzoxl </span> <span class="string">getstartedlab_web.</span>2   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm2 </span> <span class="string">Running</span></div><div class="line"><span class="string">vbb1qbkb0o2z </span> <span class="string">getstartedlab_web.</span>3   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm2 </span> <span class="string">Running</span></div><div class="line"><span class="string">ghii74p9budx </span> <span class="string">getstartedlab_web.</span>4   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm1 </span> <span class="string">Running</span></div><div class="line"><span class="string">0prmarhavs87 </span> <span class="string">getstartedlab_web.</span>5   <span class="string">john/</span><span class="built_in">get-started:part2</span>  <span class="string">myvm2 </span> <span class="string">Running</span></div></pre></td></tr></table></figure><blockquote><p><strong>使用<code>docker-machine env</code>和<code>docker-machine ssh</code>连接到VM</strong></p><ul><li><p>要将shell设置为与<code>myvm2</code>等其他机器通信，只需在相同或不同的shell中重新运行<code>docker-machine env</code>，然后运行给定的命令以指向<code>myvm2</code>。这里指的是当前的shell。如果你更改为未配置的shell或打开一个新的shell，则需要重新运行这些命令。使用<code>docker-machine ls</code>列出机器列表，查看它们所处的状态，获取IP地址，如果有的话，并找出具体连接到的是哪一个地址。更多请参阅<a href="https://docs.docker.com/machine/get-started/#create-a-machine" target="_blank" rel="external">Docker Machine getting started topics</a>。</p></li><li><p>或者，你可以以<code>docker-machine ssh &lt;machine&gt; &quot;&lt;command&gt;&quot;</code>的形式来打包Docker命令，该命令可以直接登陆到VM，但不会立即访问本地主机上的文件。</p></li><li><p>在Mac和Linux上，你可以使用<code>docker-machine scp &lt;file&gt; &lt;machine&gt;:~</code>来在机器间复制文件，但在Windows上，需要使用一个Linux类似<a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git Bash</a>的终端模拟器来完成这类工作。</p></li></ul><p>本教程演示了<code>docker-machine ssh</code>和<code>docker-machine env</code>因为这些都可以通过<code>docker-machine</code>CLI在平台上使用。</p></blockquote><h3 id="访问你的集群"><a href="#访问你的集群" class="headerlink" title="访问你的集群"></a>访问你的集群</h3><p>你可以从<code>myvm1</code>或<code>myvm2</code>的IP地址访问您的应用程序。</p><p>你创建的网络在它们之间共享负载均衡。运行<code>docker-machine ls</code>来获取你的VM的IP地址，并通过浏览器访问其中的任何一个，点击刷新（或者仅仅使用<code>curl</code>来访问）</p><p><img src="/img/18_04_26/002.png" alt=""></p><p>有五个可能的容器ID全部随机循环，体现了负载均衡。</p><p>两个IP地址工作的原因是群中的节点参与<strong>入口路由网格</strong>。这可以确保部署在集群中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。以下是三节点swarm的端口8080上发布的名为<code>my-web</code>的服务的路由网络示意图：</p><p><img src="/img/18_04_26/003.png" alt=""></p><blockquote><p><strong>连接有问题？</strong></p><p>请记住，要使用swarm中的入口网络，在启用swarm模式之前，需要在swarm节点之间打开以下端口：</p><ul><li>端口7946 TCP/UDP （用于容器网络发现）</li><li>端口4789 UDP （用于容器入口网络）</li></ul></blockquote><h2 id="迭代和缩放你的应用程序"><a href="#迭代和缩放你的应用程序" class="headerlink" title="迭代和缩放你的应用程序"></a>迭代和缩放你的应用程序</h2><p>在这里，你可以完成你在Part2和Part3中学到的一切。</p><p>通过修改<code>docker-compose.yml</code>文件，可以缩放应用程序。</p><p>通过编辑代码，来改变应用的行为，然后重新构建，并将新的镜像push上去。（要做到这一点，请按照之前用于构建应用程序和发布镜像的相同步骤）。</p><p>无论是哪种情况，只需要通过再次运行<code>docker stack deploy</code>就可以发布这些变更。</p><p>你可以加入任何虚拟的或物理的机器到这个swarm中，对<code>myvm2</code>使用相同的<code>docker swarm join</code>命令，然后集群的容量就被扩大了。在运行<code>docker stack deploy</code>之后，你的应用程序就可以利用到这些资源了。</p><h2 id="清空并重启"><a href="#清空并重启" class="headerlink" title="清空并重启"></a>清空并重启</h2><h3 id="堆栈和swarm"><a href="#堆栈和swarm" class="headerlink" title="堆栈和swarm"></a>堆栈和swarm</h3><p>你可以通过运行<code>docker stack rm</code>来卸下堆栈。例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stack</span> <span class="keyword">rm</span> getstartedlab</div></pre></td></tr></table></figure><blockquote><p><strong>保留或删除swarm</strong>？</p><p>在稍后，如果您想要使某个worker离开swarm，可以在worker上使用<code>docker-machine ssh myvm2 &quot;docker swarm leave&quot;</code>来卸下woker，如果是manager的话，可以这样执行<code>docker-machine ssh myvm1 &quot;docker swarm leave --force&quot;</code>，但在后面的Part5的教学中，你还需要它，所以暂时保留。</p></blockquote><h3 id="重置docker-machine-shell变量设置"><a href="#重置docker-machine-shell变量设置" class="headerlink" title="重置docker-machine shell变量设置"></a>重置docker-machine shell变量设置</h3><p>你可以通过你当前的shell执行以下命令来重置<code>docker-machine</code>环境变量。</p><p>在Mac或Linux上，命令如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span> $(docker-machine <span class="keyword">env</span> -u)</div></pre></td></tr></table></figure><p>在Windows上，命令如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp; "C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\R</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker-machine.exe" env -u | Invoke-Expression</div></pre></td></tr></table></figure><p>这将shell与<code>docker-machine</code>创建的虚拟机断开连接，并允许你继续在同一个shell中工作，现在使用本机docker命令。更多信息，请见<a href="https://docs.docker.com/machine/get-started/#unset-environment-variables-in-the-current-shell" target="_blank" rel="external">Machine topic on unsetting environment variables</a>。</p><p>重启Docker machines</p><p>如果你关闭本地主机，Docker machines将停止运行。你可以通过运行<code>docker-machine ls</code>来检查机器运行的状态。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls</div><div class="line"><span class="built_in">NAME</span>    ACTIVE   <span class="built_in">DRIVER</span>       STATE     URL   SWARM   DOCKER    ERRORS</div><div class="line">myvm1   -        virtualbox   <span class="built_in">Stopped</span>                 Unknown</div><div class="line">myvm2   -        virtualbox   <span class="built_in">Stopped</span>                 Unknown</div></pre></td></tr></table></figure><p>重启已经停止的机器，运行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine <span class="keyword">start</span> &lt;machine-<span class="keyword">name</span>&gt;</div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ docker-machine <span class="built_in">start</span> myvm1</div><div class="line">Starting <span class="string">"myvm1"</span>...</div><div class="line">(myvm1) Check network <span class="built_in">to</span> re-<span class="built_in">create</span> <span class="keyword">if</span> needed...</div><div class="line">(myvm1) Waiting <span class="keyword">for</span> <span class="keyword">an</span> IP...</div><div class="line">Machine <span class="string">"myvm1"</span> was started.</div><div class="line">Waiting <span class="keyword">for</span> SSH <span class="built_in">to</span> be available...</div><div class="line">Detecting <span class="keyword">the</span> provisioner...</div><div class="line">Started machines may have <span class="built_in">new</span> IP addresses. You may need <span class="built_in">to</span> re-run <span class="keyword">the</span> `docker-machine env` <span class="keyword">command</span>.</div><div class="line"></div><div class="line">$ docker-machine <span class="built_in">start</span> myvm2</div><div class="line">Starting <span class="string">"myvm2"</span>...</div><div class="line">(myvm2) Check network <span class="built_in">to</span> re-<span class="built_in">create</span> <span class="keyword">if</span> needed...</div><div class="line">(myvm2) Waiting <span class="keyword">for</span> <span class="keyword">an</span> IP...</div><div class="line">Machine <span class="string">"myvm2"</span> was started.</div><div class="line">Waiting <span class="keyword">for</span> SSH <span class="built_in">to</span> be available...</div><div class="line">Detecting <span class="keyword">the</span> provisioner...</div><div class="line">Started machines may have <span class="built_in">new</span> IP addresses. You may need <span class="built_in">to</span> re-run <span class="keyword">the</span> `docker-machine env` <span class="keyword">command</span>.</div></pre></td></tr></table></figure><h2 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h2><p>在part4部分，你学习到了什么是swarm，节点在swarm中可以作为worker，也可以作为manager，创建一个swarm，并在上面发布一个应用。你看到Docker的核心命令和part3中并没有什么不同，他们只需要将目标锁定在swarm主机上运行。你还看到了Docker网络的力量，即使它们运行在不同的机器上，也可以跨容器保持请求负载均衡。最后，你学习了如何在集群上迭代和缩放应用程序。以下是您可能想要运行的命令：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver virtualbox myvm1 # Create a VM (<span class="keyword">Mac</span>, Win7, Linux)</div><div class="line">docker-machine create -<span class="keyword">d</span> hyperv --hyperv-virtual-switch <span class="string">"myswitch"</span> myvm1 # Win10</div><div class="line">docker-machine env myvm1                # <span class="keyword">View</span> basic information <span class="keyword">about</span> your node</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker node ls"</span>         # <span class="keyword">List</span> the nodes <span class="keyword">in</span> your swarm</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker node inspect &lt;node ID&gt;"</span>        # <span class="keyword">Inspect</span> a node</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker swarm join-token -q worker"</span>   # <span class="keyword">View</span> join <span class="keyword">token</span></div><div class="line">docker-machine ssh myvm1   # <span class="keyword">Open</span> <span class="keyword">an</span> SSH session with the VM; <span class="keyword">type</span> <span class="string">"exit"</span> to end</div><div class="line">docker node <span class="keyword">ls</span>                # <span class="keyword">View</span> nodes <span class="keyword">in</span> swarm (<span class="keyword">while</span> logged <span class="keyword">on</span> to manager)</div><div class="line">docker-machine ssh myvm2 <span class="string">"docker swarm leave"</span>  # Make the worker leave the swarm</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker swarm leave -f"</span> # Make master leave, kill swarm</div><div class="line">docker-machine <span class="keyword">ls</span> # <span class="keyword">list</span> VMs, asterisk shows <span class="keyword">which</span> VM this <span class="keyword">shell</span> is talking to</div><div class="line">docker-machine start myvm1            # Start a VM that is currently not running</div><div class="line">docker-machine env myvm1      # show environment variables and command <span class="keyword">for</span> myvm1</div><div class="line">eval $(docker-machine env myvm1)         # <span class="keyword">Mac</span> command to connect <span class="keyword">shell</span> to myvm1</div><div class="line">&amp; <span class="string">"C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe"</span> env myvm1 | Invoke-Expression   # Windows command to connect <span class="keyword">shell</span> to myvm1</div><div class="line">docker <span class="keyword">stack</span> deploy -c &lt;<span class="keyword">file</span>&gt; &lt;<span class="keyword">app</span>&gt;  # Deploy <span class="keyword">an</span> <span class="keyword">app</span>; command <span class="keyword">shell</span> must be <span class="keyword">set</span> to talk to manager (myvm1), uses <span class="keyword">local</span> Compose <span class="keyword">file</span></div><div class="line">docker-machine scp docker-compose.yml myvm1:~ # <span class="keyword">Copy</span> <span class="keyword">file</span> to node's home <span class="keyword">dir</span> (only required <span class="keyword">if</span> you <span class="keyword">use</span> ssh to connect to manager and deploy the <span class="keyword">app</span>)</div><div class="line">docker-machine ssh myvm1 <span class="string">"docker stack deploy -c &lt;file&gt; &lt;app&gt;"</span>   # Deploy <span class="keyword">an</span> <span class="keyword">app</span> using ssh (you must have first copied the Compose <span class="keyword">file</span> to myvm1)</div><div class="line">eval $(docker-machine env -<span class="keyword">u</span>)     # Disconnect <span class="keyword">shell</span> from VMs, <span class="keyword">use</span> native docker</div><div class="line">docker-machine stop $(docker-machine <span class="keyword">ls</span> -q)               # Stop all running VMs</div><div class="line">docker-machine <span class="keyword">rm</span> $(docker-machine <span class="keyword">ls</span> -q) # Delete all VMs and their disk images</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://studyai.site/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
